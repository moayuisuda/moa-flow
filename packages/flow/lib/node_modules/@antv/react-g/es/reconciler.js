import ReactReconciler from '../../../react-reconciler/index.js';
import React from 'react';
import '../../../scheduler/index.js';
import { bindShapeEvent, updateProps } from './processProps.js';
import { log } from './util/debug.js';
import { s as scheduler } from '../../../../_virtual/index2.js';

var reconcilor = ReactReconciler({
  getPublicInstance: function getPublicInstance(instance) {
    return instance;
  },
  getRootHostContext: function getRootHostContext(rootContainerInstance) {},
  getChildHostContext: function getChildHostContext(parentHostContext, type, rootContainerInstance) {},
  prepareForCommit: function prepareForCommit(containerInfo) {
    return {};
  },
  resetAfterCommit: function resetAfterCommit(containerInfo) {},
  preparePortalMount: function preparePortalMount(containerInfo) {},
  createInstance: function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
    var canvas = rootContainerInstance;
    var instance = canvas.document.createElement(type, {
      style: props
    });
    bindShapeEvent(props, instance);
    log('createInstance ', type, instance);
    return instance;
  },
  appendInitialChild: function appendInitialChild(parentInstance, child) {
    log('appendInitialChild', parentInstance, child);
    parentInstance.appendChild(child);
  },
  finalizeInitialChildren: function finalizeInitialChildren(parentInstance, type, props, rootContainerInstance, hostContext) {
    return false;
  },
  prepareUpdate: function prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, hostContext) {
    // return hasUpdate(newProps, oldProps);
    return true;
  },
  shouldSetTextContent: function shouldSetTextContent(type, props) {
    return false;
  },
  // shouldDeprioritizeSubtree(type: Type, props: Props): boolean {
  //   return false;
  // },
  createTextInstance: function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {},
  // scheduleDeferredCallback(callback: () => any, options?: { timeout: number }): any {},
  // scheduleDeferredCallback,
  // cancelDeferredCallback(callbackID: any): void {},
  scheduleTimeout: function scheduleTimeout(handler, timeout) {},
  cancelTimeout: function cancelTimeout(handle) {},
  noTimeout: undefined,
  now: scheduler.exports.unstable_now,
  // Temporary workaround for scenario where multiple renderers concurrently
  // render using the same context objects. E.g. React DOM and React ART on the
  // same page. DOM is the primary renderer {}, ART is the secondary renderer.
  isPrimaryRenderer: false,
  supportsMutation: true,
  supportsPersistence: false,
  supportsHydration: false,
  // -------------------
  //      Mutation
  //     (optional)
  // -------------------
  appendChild: function appendChild(parentInstance, child) {
    log('appendChild');
    parentInstance.appendChild(child);
  },
  appendChildToContainer: function appendChildToContainer(container, child) {
    log('appendChildToContainer', container, child);
    container.appendChild(child);
  },
  commitTextUpdate: function commitTextUpdate(textInstance, oldText, newText) {},
  commitMount: function commitMount(instance, type, newProps, internalInstanceHandle) {},
  commitUpdate: function commitUpdate(instance, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
    log('commitUpdate', instance, newProps);
    updateProps(instance, newProps, oldProps);
  },
  insertBefore: function insertBefore(parentInstance, child, beforeChild) {
    parentInstance.insertBefore(child, beforeChild);
  },
  insertInContainerBefore: function insertInContainerBefore(container, child, beforeChild) {
    container.insertBefore(child, beforeChild);
  },
  removeChild: function removeChild(parentInstance, child) {
    log('removeChild', parentInstance, child);
    parentInstance.removeChild(child);
  },
  removeChildFromContainer: function removeChildFromContainer(container, child) {
    container.removeChild(child);
  },
  resetTextContent: function resetTextContent(instance) {},

  /**
   * This method should make the `instance` invisible without removing it from the tree. For example, it can apply visual styling to hide it. It is used by Suspense to hide the tree while the fallback is visible.
   */
  // tslint:enable:max-line-length
  hideInstance: function hideInstance(instance) {},

  /**
   * Same as `hideInstance`, but for nodes created by `createTextInstance`.
   */
  hideTextInstance: function hideTextInstance(textInstance) {},

  /**
   * This method should make the `instance` visible, undoing what `hideInstance` did.
   */
  unhideInstance: function unhideInstance(instance, props) {},

  /**
   * Same as `unhideInstance`, but for nodes created by `createTextInstance`.
   */
  unhideTextInstance: function unhideTextInstance(textInstance, text) {},

  /**
   * This method should mutate the `container` root node and remove all children from it.
   */
  clearContainer: function clearContainer(container) {
    container.removeChildren();
  },
  // -------------------
  //     Persistence
  //     (optional)
  // -------------------
  cloneInstance: function cloneInstance(instance, updatePayload, type, oldProps, newProps, internalInstanceHandle, keepChildren, recyclableInstance) {
    return instance;
  },
  createContainerChildSet: function createContainerChildSet(container) {},
  appendChildToContainerChildSet: function appendChildToContainerChildSet(childSet, child) {},
  finalizeContainerChildren: function finalizeContainerChildren(container, newChildren) {},
  replaceContainerChildren: function replaceContainerChildren(container, newChildren) {},
  // -------------------
  //     Hydration
  //     (optional)
  // -------------------
  canHydrateInstance: function canHydrateInstance(instance, type, props) {
    return instance;
  },
  canHydrateTextInstance: function canHydrateTextInstance(instance, text) {
    return null;
  },
  getNextHydratableSibling: function getNextHydratableSibling(instance) {},
  getFirstHydratableChild: function getFirstHydratableChild(parentInstance) {},
  hydrateInstance: function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {},
  hydrateTextInstance: function hydrateTextInstance(textInstance, text, internalInstanceHandle) {
    return false;
  },
  didNotMatchHydratedContainerTextInstance: function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text) {},
  didNotMatchHydratedTextInstance: function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text) {},
  didNotHydrateContainerInstance: function didNotHydrateContainerInstance(parentContainer, instance) {},
  didNotHydrateInstance: function didNotHydrateInstance(parentType, parentProps, parentInstance, instance) {},
  didNotFindHydratableContainerInstance: function didNotFindHydratableContainerInstance(parentContainer, type, props) {},
  didNotFindHydratableContainerTextInstance: function didNotFindHydratableContainerTextInstance(parentContainer, text) {},
  didNotFindHydratableInstance: function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props) {},
  didNotFindHydratableTextInstance: function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text) {}
});
reconcilor.injectIntoDevTools({
  // findFiberByHostInstance: () => {},
  // @ts-ignore
  bundleType: process.env.NODE_ENV !== 'production' ? 1 : 0,
  version: React.version,
  rendererPackageName: 'react-g',
  rendererConfig: {
    getInspectorDataForViewTag: function getInspectorDataForViewTag(tag) {
      console.log(tag);
    }
  }
});
/**
 * render react-g component to target g element
 * 将react-g组件渲染到任意的g实例（Canvas/Group/Shape）中
 * @param component react-g component
 * @param target g element, Canvas/Group/Shape instance
 * @param callback callback after render finished
 * @returns void
 */

var render = function render(component, target, callback) {
  var container = reconcilor.createContainer(target, 1, false, null);
  reconcilor.updateContainer(component, container, null, callback);
};

export { reconcilor, render };
