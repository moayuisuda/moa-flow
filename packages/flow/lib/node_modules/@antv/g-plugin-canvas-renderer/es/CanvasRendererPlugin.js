import { __read, __spreadArray, __assign, __decorate, __metadata } from '../../../tslib/tslib.es6.js';
import { ElementEvent, RenderReason, AABB, Shape, getEuler, fromRotationTranslationScale, CSSGradientValue, GradientPatternType, CanvasConfig, DefaultCamera, ContextService, RenderingContext, DisplayObjectPool, RenderingPluginContribution, Camera } from '@antv/g';
import { inject, singleton } from 'mana-syringe';
import RBush from '../../../rbush/index.js';
import { PathGeneratorFactory } from './shapes/paths/index.js';
import { StyleRendererFactory } from './shapes/styles/interfaces.js';
import './shapes/styles/Default.js';
import './shapes/styles/Image.js';
import './shapes/styles/Text.js';
import { GradientPool } from './shapes/GradientPool.js';
import { ImagePool } from './shapes/ImagePool.js';
import { RBushNode } from './components/RBushNode.js';
import isArray from '../../../lodash-es/isArray.js';
import isNil from '../../../lodash-es/isNil.js';
import { fromValues, create } from '../../../gl-matrix/esm/vec3.js';
import { getTranslation, getScaling, getRotation } from '../../../gl-matrix/esm/mat4.js';
import { create as create$1 } from '../../../gl-matrix/esm/quat.js';

var RBushRoot = 'RBushRoot';
/**
 * support 2 modes in rendering:
 * * immediate
 * * delayed: render at the end of frame with dirty-rectangle
 */

var CanvasRendererPlugin =
/** @class */
function () {
  function CanvasRendererPlugin() {
    this.removedRBushNodeAABBs = [];
    this.renderQueue = [];
    this.restoreStack = [];
    this.clearFullScreen = false;
    this.enableBatch = false;
    this.batchedStyleHash = '';
    this.batchedDisplayObject = null;
    /**
     * sync to RBush later
     */

    this.toSync = new Set();
  }

  CanvasRendererPlugin_1 = CanvasRendererPlugin;

  CanvasRendererPlugin.prototype.syncRTree = function () {
    var _this = this; // bounds changed, need re-inserting its children


    var bulk = [];
    Array.from(this.toSync) // some objects may be removed since last frame
    .filter(function (object) {
      return object.isConnected;
    }).forEach(function (node) {
      // @ts-ignore
      var rBushNode = node.rBushNode; // clear dirty node

      if (rBushNode) {
        _this.rBush.remove(rBushNode.aabb);
      }

      var renderBounds = node.getRenderBounds();

      if (renderBounds) {
        var _a = __read(renderBounds.getMin(), 2),
            minX = _a[0],
            minY = _a[1];

        var _b = __read(renderBounds.getMax(), 2),
            maxX = _b[0],
            maxY = _b[1];

        rBushNode.aabb = {
          id: node.entity,
          minX: minX,
          minY: minY,
          maxX: maxX,
          maxY: maxY
        };
      }

      if (rBushNode.aabb) {
        bulk.push(rBushNode.aabb);
      }
    }); // use bulk inserting, which is ~2-3 times faster
    // @see https://github.com/mourner/rbush#bulk-inserting-data

    this.rBush.load(bulk);
    this.toSync.clear();
  };

  CanvasRendererPlugin.prototype.pushToSync = function (list) {
    var _this = this;

    list.forEach(function (i) {
      _this.toSync.add(i);
    });
  };

  CanvasRendererPlugin.prototype.apply = function (renderingService) {
    var _this = this;

    var handleMounted = function handleMounted(e) {
      var object = e.target; // @ts-ignore

      object.rBushNode = new RBushNode();

      _this.pushToSync(e.composedPath().slice(0, -2));
    };

    var handleUnmounted = function handleUnmounted(e) {
      var object = e.target; // remove r-bush node
      // @ts-ignore

      var rBushNode = object.rBushNode;

      if (rBushNode.aabb) {
        _this.rBush.remove(rBushNode.aabb);

        _this.toSync.delete(object); // save removed aabbs for dirty-rectangle rendering later


        _this.removedRBushNodeAABBs.push(rBushNode.aabb);
      }
    };

    var handleBoundsChanged = function handleBoundsChanged(e) {
      var _a;

      var object = e.target; // skip if this object mounted on another scenegraph root

      if (((_a = object.ownerDocument) === null || _a === void 0 ? void 0 : _a.documentElement) !== _this.renderingContext.root) {
        return;
      }

      var affectChildren = e.detail.affectChildren;

      if (affectChildren) {
        object.forEach(function (node) {
          _this.pushToSync([node]);
        });
      }

      _this.pushToSync(e.composedPath().slice(0, -2));
    };

    renderingService.hooks.init.tap(CanvasRendererPlugin_1.tag, function () {
      _this.renderingContext.root.addEventListener(ElementEvent.MOUNTED, handleMounted);

      _this.renderingContext.root.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);

      _this.renderingContext.root.addEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
    });
    renderingService.hooks.destroy.tap(CanvasRendererPlugin_1.tag, function () {
      _this.renderingContext.root.removeEventListener(ElementEvent.MOUNTED, handleMounted);

      _this.renderingContext.root.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);

      _this.renderingContext.root.removeEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
    });
    renderingService.hooks.beginFrame.tap(CanvasRendererPlugin_1.tag, function () {
      var context = _this.contextService.getContext();

      var enableDirtyRectangleRendering = _this.canvasConfig.renderer.getConfig().enableDirtyRectangleRendering; // clear fullscreen when:
      // 1. dirty rectangle rendering disabled
      // 2. camera changed


      _this.clearFullScreen = !enableDirtyRectangleRendering || _this.renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED);

      if (context) {
        context.save();

        if (_this.clearFullScreen) {
          context.clearRect(0, 0, _this.canvasConfig.width, _this.canvasConfig.height);
        } // account for camera's world matrix


        _this.applyTransform(context, _this.camera.getOrthoMatrix());
      }
    }); // render at the end of frame

    renderingService.hooks.endFrame.tap(CanvasRendererPlugin_1.tag, function () {
      _this.syncRTree();

      var _a = _this.canvasConfig.renderer.getConfig(),
          enableDirtyRectangleRendering = _a.enableDirtyRectangleRendering,
          enableDirtyRectangleRenderingDebug = _a.enableDirtyRectangleRenderingDebug;

      var context = _this.contextService.getContext();

      var dirtyObjects = _this.renderQueue;

      if (enableDirtyRectangleRendering) {
        // eg. camera changed
        if (!_this.clearFullScreen) {
          // merge removed AABB
          var dirtyRenderBounds = _this.safeMergeAABB.apply(_this, __spreadArray([_this.mergeDirtyAABBs( // should not ignore group since clipPath may affect its children
          // this.renderQueue.filter((o) => o.nodeName !== Shape.GROUP)),
          _this.renderQueue)], __read(_this.removedRBushNodeAABBs.map(function (_a) {
            var minX = _a.minX,
                minY = _a.minY,
                maxX = _a.maxX,
                maxY = _a.maxY;
            var aabb = new AABB();
            aabb.setMinMax(fromValues(minX, minY, 0), fromValues(maxX, maxY, 0));
            return aabb;
          })), false));

          _this.removedRBushNodeAABBs = [];

          if (AABB.isEmpty(dirtyRenderBounds)) {
            _this.renderQueue = [];
            return;
          } // clear & clip dirty rectangle


          var _b = _this.convertAABB2Rect(dirtyRenderBounds),
              x = _b.x,
              y = _b.y,
              width = _b.width,
              height = _b.height;

          context.clearRect(x, y, width, height);
          context.beginPath();
          context.rect(x, y, width, height);
          context.clip(); // draw dirty rectangle

          if (enableDirtyRectangleRenderingDebug) {
            context.lineWidth = 4;
            context.strokeStyle = "rgba(".concat(Math.random() * 255, ", ").concat(Math.random() * 255, ", ").concat(Math.random() * 255, ", 1)");
            context.strokeRect(x, y, width, height);
          } // search objects intersect with dirty rectangle


          dirtyObjects = _this.searchDirtyObjects(dirtyRenderBounds);
        } // do rendering


        dirtyObjects // sort by z-index
        .sort(function (a, b) {
          return a.sortable.renderOrder - b.sortable.renderOrder;
        }).forEach(function (object) {
          // culled object should not be rendered
          if (object && object.isVisible()) {
            _this.renderDisplayObject(object, renderingService);
          }
        });

        if (_this.enableBatch && _this.batchedStyleHash) {
          _this.flush(context, renderingService);
        } // save dirty AABBs in last frame


        _this.renderQueue.forEach(function (object) {
          _this.saveDirtyAABB(object);
        }); // clear queue


        _this.renderQueue = [];
      } // pop restore stack, eg. root -> parent -> child


      _this.restoreStack.forEach(function (s) {
        context.restore();
      }); // clear restore stack


      _this.restoreStack = [];
      _this.clearFullScreen = false;
      context.restore();
    });
    renderingService.hooks.render.tap(CanvasRendererPlugin_1.tag, function (object) {
      var enableDirtyRectangleRendering = _this.canvasConfig.renderer.getConfig().enableDirtyRectangleRendering;

      if (!enableDirtyRectangleRendering) {
        // render immediately
        _this.renderDisplayObject(object, renderingService);
      } else {
        // render at the end of frame
        _this.renderQueue.push(object);
      }
    });
  };

  CanvasRendererPlugin.prototype.flush = function (context, renderingService) {
    if (this.batchedDisplayObject) {
      var styleRenderer = this.styleRendererFactory(this.batchedDisplayObject.nodeName);

      if (styleRenderer) {
        // apply attributes to context
        this.applyAttributesToContext(context, this.batchedDisplayObject, renderingService); // close path first

        context.closePath();
        styleRenderer.render(context, this.batchedDisplayObject.parsedStyle, this.batchedDisplayObject);
        context.restore();
      }

      this.batchedStyleHash = '';
      this.batchedDisplayObject = null;
    }
  };

  CanvasRendererPlugin.prototype.renderDisplayObject = function (object, renderingService) {
    var _this = this;

    var context = this.contextService.getContext(); // restore to its parent

    var parent = this.restoreStack[this.restoreStack.length - 1];

    while (parent && object.parentNode !== parent) {
      context.restore();
      this.restoreStack.pop();
      parent = this.restoreStack[this.restoreStack.length - 1];
    }

    var nodeName = object.nodeName;
    var styleRenderer = this.styleRendererFactory(nodeName);
    var startBatch = false;

    if (this.enableBatch && styleRenderer) {
      var hash = styleRenderer.hash(object.attributes);

      if (this.batchedStyleHash && hash !== this.batchedStyleHash) {
        this.flush(context, renderingService);
      }

      if (!this.batchedStyleHash) {
        this.batchedStyleHash = hash;
        this.batchedDisplayObject = object;
        startBatch = true;
      }
    } // reset transformation


    context.save(); // apply RTS transformation in world space

    this.applyTransform(context, object.getLocalTransform()); // clip path

    var clipPathShape = object.style.clipPath;

    if (clipPathShape) {
      context.save(); // apply clip shape's RTS

      this.applyTransform(context, clipPathShape.getLocalTransform()); // generate path in local space

      var generatePath_1 = this.pathGeneratorFactory(clipPathShape.nodeName);

      if (generatePath_1) {
        this.useAnchor(context, clipPathShape, function () {
          context.beginPath();
          generatePath_1(context, clipPathShape.parsedStyle);
          context.closePath();
        });
      }

      context.restore();
      context.clip();
    } // fill & stroke


    if (!this.enableBatch) {
      context.save(); // apply attributes to context

      this.applyAttributesToContext(context, object, renderingService);
    } // apply anchor in local space


    this.useAnchor(context, object, function () {
      // generate path in local space
      var generatePath = _this.pathGeneratorFactory(object.nodeName);

      if (generatePath) {
        if (startBatch || !_this.enableBatch) {
          context.beginPath();
        }

        generatePath(context, object.parsedStyle);

        if (!_this.enableBatch && object.nodeName !== Shape.LINE && object.nodeName !== Shape.PATH && object.nodeName !== Shape.POLYLINE) {
          context.closePath();
        }
      } // fill & stroke


      if (styleRenderer && !_this.enableBatch) {
        styleRenderer.render(context, object.parsedStyle, object);
      }
    }); // restore applied attributes, eg. shadowBlur shadowColor...

    if (!this.enableBatch) {
      context.restore();
    } // finish rendering, clear dirty flag


    object.renderable.dirty = false;
    this.restoreStack.push(object);
  };

  CanvasRendererPlugin.prototype.convertAABB2Rect = function (aabb) {
    var min = aabb.getMin();
    var max = aabb.getMax(); // expand the rectangle a bit to avoid artifacts
    // @see https://www.yuque.com/antv/ou292n/bi8nix#ExvCu

    var minX = Math.floor(min[0]);
    var minY = Math.floor(min[1]);
    var maxX = Math.ceil(max[0]);
    var maxY = Math.ceil(max[1]);
    var width = maxX - minX;
    var height = maxY - minY;
    return {
      x: minX,
      y: minY,
      width: width,
      height: height
    };
  };
  /**
   * TODO: merge dirty rectangles with some strategies.
   * For now, we just simply merge all the rectangles into one.
   * @see https://idom.me/articles/841.html
   */


  CanvasRendererPlugin.prototype.mergeDirtyAABBs = function (dirtyObjects) {
    // merge into a big AABB
    var aabb = new AABB();
    dirtyObjects.forEach(function (object) {
      var renderBounds = object.getRenderBounds();
      aabb.add(renderBounds);
      var dirtyRenderBounds = object.renderable.dirtyRenderBounds;

      if (dirtyRenderBounds) {
        aabb.add(dirtyRenderBounds);
      }
    });
    return aabb;
  };

  CanvasRendererPlugin.prototype.searchDirtyObjects = function (dirtyRectangle) {
    var _this = this; // search in r-tree, get all affected nodes


    var _a = __read(dirtyRectangle.getMin(), 2),
        minX = _a[0],
        minY = _a[1];

    var _b = __read(dirtyRectangle.getMax(), 2),
        maxX = _b[0],
        maxY = _b[1];

    var rBushNodes = this.rBush.search({
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY
    });
    return rBushNodes.map(function (_a) {
      var id = _a.id;
      return _this.displayObjectPool.getByEntity(id);
    });
  };

  CanvasRendererPlugin.prototype.saveDirtyAABB = function (object) {
    var renderable = object.renderable;

    if (!renderable.dirtyRenderBounds) {
      renderable.dirtyRenderBounds = new AABB();
    }

    var renderBounds = object.getRenderBounds();

    if (renderBounds) {
      // save last dirty aabb
      renderable.dirtyRenderBounds.update(renderBounds.center, renderBounds.halfExtents);
    }
  };

  CanvasRendererPlugin.prototype.applyTransform = function (context, transform) {
    var _a = __read(getTranslation(create(), transform), 2),
        tx = _a[0],
        ty = _a[1];

    var _b = __read(getScaling(create(), transform), 2),
        sx = _b[0],
        sy = _b[1];

    var rotation = getRotation(create$1(), transform); // eslint-disable-next-line @typescript-eslint/no-unused-vars

    var _c = __read(getEuler(create(), rotation), 3),
        eux = _c[0];
        _c[1];
        var euz = _c[2]; // gimbal lock at 90 degrees


    var rts = fromRotationTranslationScale(eux || euz, tx, ty, sx, sy); // @see https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Transformations

    context.transform(rts[0], rts[1], rts[3], rts[4], rts[6], rts[7]);
  };

  CanvasRendererPlugin.prototype.getColor = function (parsedColor, object, context, renderingService) {
    var color;

    if (parsedColor instanceof CSSGradientValue) {
      if (parsedColor.type === GradientPatternType.LinearGradient || parsedColor.type === GradientPatternType.RadialGradient) {
        var bounds = object.getGeometryBounds();
        var width = bounds && bounds.halfExtents[0] * 2 || 0;
        var height = bounds && bounds.halfExtents[1] * 2 || 0;
        color = this.gradientPool.getOrCreateGradient(__assign(__assign({
          type: parsedColor.type
        }, parsedColor.value), {
          width: width,
          height: height
        }), context);
      } else if (parsedColor.type === GradientPatternType.Pattern) {
        var pattern = this.imagePool.getPatternSync(parsedColor.value);

        if (pattern) {
          color = pattern;
        } else {
          this.imagePool.createPattern(parsedColor.value, context).then(function () {
            // set dirty rectangle flag
            object.renderable.dirty = true;
            renderingService.dirtify();
          });
        }
      }
    } else {
      // constant, eg. rgba(255,255,255,1)
      color = parsedColor.toString();
    }

    return color;
  };

  CanvasRendererPlugin.prototype.applyAttributesToContext = function (context, object, renderingService) {
    var _a = object.parsedStyle,
        stroke = _a.stroke,
        fill = _a.fill,
        opacity = _a.opacity,
        lineDash = _a.lineDash,
        lineDashOffset = _a.lineDashOffset,
        filter = _a.filter,
        shadowColor = _a.shadowColor,
        shadowBlur = _a.shadowBlur,
        shadowOffsetX = _a.shadowOffsetX,
        shadowOffsetY = _a.shadowOffsetY; // @see https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/setLineDash

    if (lineDash && isArray(lineDash)) {
      context.setLineDash(lineDash.map(function (segment) {
        return segment.value;
      }));
    } // @see https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/lineDashOffset


    if (!isNil(lineDashOffset)) {
      context.lineDashOffset = lineDashOffset.value;
    }

    if (!isNil(opacity)) {
      context.globalAlpha *= opacity.value;
    }

    if (!isNil(stroke)) {
      context.strokeStyle = this.getColor(stroke, object, context, renderingService);
    }

    if (!isNil(fill)) {
      context.fillStyle = this.getColor(fill, object, context, renderingService);
    }

    if (!isNil(filter)) {
      // use raw filter string
      context.filter = object.style.filter;
    }

    if (!isNil(shadowColor)) {
      context.shadowColor = shadowColor.toString();
      context.shadowBlur = shadowBlur && shadowBlur.value || 0;
      context.shadowOffsetX = shadowOffsetX && shadowOffsetX.value || 0;
      context.shadowOffsetY = shadowOffsetY && shadowOffsetY.value || 0;
    }
  };

  CanvasRendererPlugin.prototype.useAnchor = function (context, object, callback) {
    var contentBounds = object.getGeometryBounds();

    if (contentBounds) {
      var halfExtents = contentBounds.halfExtents; // apply anchor, use true size, not include stroke,
      // eg. bounds = true size + half lineWidth

      var anchor = (object.parsedStyle || {}).anchor;
      context.translate(-(anchor && anchor[0].value || 0) * halfExtents[0] * 2, -(anchor && anchor[1].value || 0) * halfExtents[1] * 2);
      callback();
    } else {
      callback();
    }
  };

  CanvasRendererPlugin.prototype.safeMergeAABB = function () {
    var aabbs = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      aabbs[_i] = arguments[_i];
    }

    var merged = new AABB();
    aabbs.forEach(function (aabb) {
      merged.add(aabb);
    });
    return merged;
  };

  var CanvasRendererPlugin_1;
  CanvasRendererPlugin.tag = 'CanvasRendererPlugin';

  __decorate([inject(CanvasConfig), __metadata("design:type", Object)], CanvasRendererPlugin.prototype, "canvasConfig", void 0);

  __decorate([inject(DefaultCamera), __metadata("design:type", Camera)], CanvasRendererPlugin.prototype, "camera", void 0);

  __decorate([inject(ContextService), __metadata("design:type", Object)], CanvasRendererPlugin.prototype, "contextService", void 0);

  __decorate([inject(RenderingContext), __metadata("design:type", Object)], CanvasRendererPlugin.prototype, "renderingContext", void 0);

  __decorate([inject(ImagePool), __metadata("design:type", ImagePool)], CanvasRendererPlugin.prototype, "imagePool", void 0);

  __decorate([inject(GradientPool), __metadata("design:type", GradientPool)], CanvasRendererPlugin.prototype, "gradientPool", void 0);

  __decorate([inject(PathGeneratorFactory), __metadata("design:type", Function)], CanvasRendererPlugin.prototype, "pathGeneratorFactory", void 0);

  __decorate([inject(StyleRendererFactory), __metadata("design:type", Function)], CanvasRendererPlugin.prototype, "styleRendererFactory", void 0);

  __decorate([inject(DisplayObjectPool), __metadata("design:type", DisplayObjectPool)], CanvasRendererPlugin.prototype, "displayObjectPool", void 0);

  __decorate([inject(RBushRoot), __metadata("design:type", RBush)], CanvasRendererPlugin.prototype, "rBush", void 0);

  CanvasRendererPlugin = CanvasRendererPlugin_1 = __decorate([singleton({
    contrib: RenderingPluginContribution
  })], CanvasRendererPlugin);
  return CanvasRendererPlugin;
}();

export { CanvasRendererPlugin, RBushRoot };
