import { __decorate } from '../../../../../tslib/tslib.es6.js';
import { Shape } from '@antv/g';
import { singleton } from 'mana-syringe';
import { StyleRenderer } from './interfaces.js';
import isNil from '../../../../../lodash-es/isNil.js';

var DefaultRenderer =
/** @class */
function () {
  function DefaultRenderer() {}

  DefaultRenderer.prototype.hash = function (parsedStyle) {
    // const { fill, opacity, fillOpacity, stroke, strokeOpacity, lineWidth, lineCap, lineJoin } =
    //   parsedStyle;
    // return fill + opacity + fillOpacity + stroke + strokeOpacity + lineWidth + lineCap + lineJoin;
    return '';
  };

  DefaultRenderer.prototype.render = function (context, parsedStyle) {
    var fill = parsedStyle.fill,
        opacity = parsedStyle.opacity,
        fillOpacity = parsedStyle.fillOpacity,
        stroke = parsedStyle.stroke,
        strokeOpacity = parsedStyle.strokeOpacity,
        lineWidth = parsedStyle.lineWidth,
        lineCap = parsedStyle.lineCap,
        lineJoin = parsedStyle.lineJoin,
        shadowColor = parsedStyle.shadowColor,
        filter = parsedStyle.filter,
        miterLimit = parsedStyle.miterLimit;
    var hasFill = !isNil(fill);
    var hasStroke = !isNil(stroke);
    var isFillTransparent = fill.alpha === 0;

    if (hasFill) {
      if (!isNil(fillOpacity) && fillOpacity.value !== 1) {
        context.globalAlpha = fillOpacity.value;
        context.fill();
        context.globalAlpha = opacity.value;
      } else {
        context.fill();
      }
    }

    if (hasStroke) {
      if (lineWidth && lineWidth.value > 0) {
        var applyOpacity = !isNil(strokeOpacity) && strokeOpacity.value !== 1;

        if (applyOpacity) {
          context.globalAlpha = strokeOpacity.value;
        }

        context.lineWidth = lineWidth.value;

        if (!isNil(miterLimit)) {
          context.miterLimit = miterLimit;
        }

        if (!isNil(lineCap)) {
          context.lineCap = lineCap.value;
        }

        if (!isNil(lineJoin)) {
          context.lineJoin = lineJoin.value;
        }

        var oldShadowBlur = void 0;
        var oldShadowColor = void 0;
        var oldFilter = void 0;
        var hasShadowColor = !isNil(shadowColor);
        var hasFilter = !isNil(filter);

        if (hasShadowColor) {
          // prevent inner shadow when drawing stroke, toggle shadowBlur & filter(drop-shadow)
          // save shadow blur
          oldShadowBlur = context.shadowBlur;
          oldShadowColor = context.shadowColor;

          if (!isNil(oldShadowBlur)) {
            context.shadowColor = 'transparent';
            context.shadowBlur = 0;
          }
        }

        if (hasFilter) {
          // save drop-shadow filter
          oldFilter = context.filter;

          if (!isNil(oldFilter) && oldFilter.indexOf('drop-shadow') > -1) {
            context.filter = oldFilter.replace(/drop-shadow\([^)]*\)/, '').trim() || 'none';
          }
        }

        var drawStroke = hasFill && !isFillTransparent;

        if (drawStroke) {
          context.stroke();
        } // restore shadow blur


        if (hasShadowColor) {
          context.shadowColor = oldShadowColor;
          context.shadowBlur = oldShadowBlur;
        } // restore filters


        if (hasFilter) {
          context.filter = oldFilter;
        }

        if (!drawStroke) {
          context.stroke();
        }
      }
    }
  };

  DefaultRenderer = __decorate([singleton({
    token: [{
      token: StyleRenderer,
      named: Shape.CIRCLE
    }, {
      token: StyleRenderer,
      named: Shape.ELLIPSE
    }, {
      token: StyleRenderer,
      named: Shape.RECT
    }, {
      token: StyleRenderer,
      named: Shape.LINE
    }, {
      token: StyleRenderer,
      named: Shape.POLYLINE
    }, {
      token: StyleRenderer,
      named: Shape.POLYGON
    }, {
      token: StyleRenderer,
      named: Shape.PATH
    }]
  })], DefaultRenderer);
  return DefaultRenderer;
}();

export { DefaultRenderer };
