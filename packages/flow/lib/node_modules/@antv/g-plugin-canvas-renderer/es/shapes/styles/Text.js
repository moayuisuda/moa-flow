import { __decorate } from '../../../../../tslib/tslib.es6.js';
import { UnitType, Shape } from '@antv/g';
import { singleton } from 'mana-syringe';
import { StyleRenderer } from './interfaces.js';
import isNil from '../../../../../lodash-es/isNil.js';

var TextRenderer =
/** @class */
function () {
  function TextRenderer() {}

  TextRenderer.prototype.hash = function (parsedStyle) {
    return '';
  };

  TextRenderer.prototype.render = function (context, parsedStyle, object) {
    var _a = parsedStyle,
        lineWidth = _a.lineWidth,
        textAlign = _a.textAlign,
        textBaseline = _a.textBaseline,
        lineJoin = _a.lineJoin,
        _b = _a.miterLimit,
        miterLimit = _b === void 0 ? 0 : _b,
        _c = _a.letterSpacing,
        letterSpacing = _c === void 0 ? 0 : _c,
        stroke = _a.stroke,
        fill = _a.fill,
        fillOpacity = _a.fillOpacity,
        strokeOpacity = _a.strokeOpacity,
        opacity = _a.opacity,
        metrics = _a.metrics,
        dx = _a.dx,
        dy = _a.dy;
    var font = metrics.font,
        lines = metrics.lines,
        height = metrics.height,
        lineHeight = metrics.lineHeight,
        lineMetrics = metrics.lineMetrics;
    context.font = font;
    context.lineWidth = lineWidth.value;
    context.textAlign = textAlign.value;
    context.textBaseline = textBaseline.value;
    context.lineJoin = lineJoin.value;
    context.miterLimit = miterLimit;
    var linePositionY = 0; // handle vertical text baseline

    if (textBaseline.value === 'middle') {
      linePositionY = -height / 2 - lineHeight / 2;
    } else if (textBaseline.value === 'bottom' || textBaseline.value === 'alphabetic' || textBaseline.value === 'ideographic') {
      linePositionY = -height;
    } else if (textBaseline.value === 'top' || textBaseline.value === 'hanging') {
      linePositionY = -lineHeight;
    } // account for dx & dy


    var offsetX = 0;

    if (dx && dx.unit === UnitType.kPixels) {
      offsetX += dx.value;
    }

    if (dy && dy.unit === UnitType.kPixels) {
      linePositionY += dy.value;
    } // draw lines line by line


    for (var i = 0; i < lines.length; i++) {
      var linePositionX = lineWidth.value / 2 + offsetX;
      linePositionY += lineHeight; // no need to re-position X, cause we already set text align
      // @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/textAlign

      if (!isNil(stroke) && lineWidth && lineWidth.value) {
        this.drawLetterSpacing(context, lines[i], lineMetrics[i], textAlign.value, linePositionX, linePositionY, letterSpacing, fillOpacity.value, strokeOpacity.value, opacity.value, true);
      }

      if (!isNil(fill)) {
        this.drawLetterSpacing(context, lines[i], lineMetrics[i], textAlign.value, linePositionX, linePositionY, letterSpacing, fillOpacity.value, strokeOpacity.value, opacity.value);
      }
    }
  };

  TextRenderer.prototype.drawLetterSpacing = function (context, text, lineMetrics, textAlign, x, y, letterSpacing, fillOpacity, strokeOpacity, opacity, isStroke) {
    if (isStroke === void 0) {
      isStroke = false;
    } // letterSpacing of 0 means normal, render all texts directly


    if (letterSpacing === 0) {
      if (isStroke) {
        this.strokeText(context, text, x, y, strokeOpacity);
      } else {
        this.fillText(context, text, x, y, fillOpacity, opacity);
      }

      return;
    } // draw text using left align


    var currentTextAlign = context.textAlign;
    context.textAlign = 'left';
    var currentPosition = x;

    if (textAlign === 'center') {
      currentPosition = x - lineMetrics.width / 2;
    } else if (textAlign === 'right' || textAlign === 'end') {
      currentPosition = x - lineMetrics.width;
    }

    var stringArray = Array.from(text);
    var previousWidth = context.measureText(text).width;
    var currentWidth = 0;

    for (var i = 0; i < stringArray.length; ++i) {
      var currentChar = stringArray[i];

      if (isStroke) {
        this.strokeText(context, currentChar, currentPosition, y, strokeOpacity);
      } else {
        this.fillText(context, currentChar, currentPosition, y, fillOpacity, opacity);
      }

      currentWidth = context.measureText(text.substring(i + 1)).width;
      currentPosition += previousWidth - currentWidth + letterSpacing;
      previousWidth = currentWidth;
    }

    context.textAlign = currentTextAlign;
  };

  TextRenderer.prototype.fillText = function (context, text, x, y, fillOpacity, opacity) {
    var currentGlobalAlpha;
    var applyOpacity = !isNil(fillOpacity) && fillOpacity !== 1;

    if (applyOpacity) {
      currentGlobalAlpha = context.globalAlpha;
      context.globalAlpha = fillOpacity * opacity;
    }

    context.fillText(text, x, y);

    if (applyOpacity) {
      context.globalAlpha = currentGlobalAlpha;
    }
  };

  TextRenderer.prototype.strokeText = function (context, text, x, y, strokeOpacity) {
    var currentGlobalAlpha;
    var applyOpacity = !isNil(strokeOpacity) && strokeOpacity !== 1;

    if (applyOpacity) {
      currentGlobalAlpha = context.globalAlpha;
      context.globalAlpha = strokeOpacity;
    }

    context.strokeText(text, x, y);

    if (applyOpacity) {
      context.globalAlpha = currentGlobalAlpha;
    }
  };

  TextRenderer = __decorate([singleton({
    token: {
      token: StyleRenderer,
      named: Shape.TEXT
    }
  })], TextRenderer);
  return TextRenderer;
}();

export { TextRenderer };
