import { __awaiter, __generator, __values, __decorate, __metadata } from '../../../../tslib/tslib.es6.js';
import { inject, singleton } from '../../../../mana-syringe/es/decorator.js';
import '../../../../mana-syringe/es/container.js';
import '../../../../mana-syringe/es/core.js';
import '../../../../mana-syringe/es/contribution/contribution-protocol.js';
import '../../../../inversify/lib/inversify.js';
import '../../../../mana-syringe/es/register.js';
import '../../../../mana-syringe/es/contribution/index.js';
import { FederatedPointerEvent } from '../dom/FederatedPointerEvent.js';
import { FederatedWheelEvent } from '../dom/FederatedWheelEvent.js';
import '../services/SceneGraphService.js';
import { ContextService } from '../services/ContextService.js';
import { RenderingContext } from '../services/RenderingContext.js';
import { RenderingService, RenderingPluginContribution } from '../services/RenderingService.js';
import { EventService } from '../services/EventService.js';
import '../services/SceneGraphSelector.js';
import '../services/TextService.js';
import '../services/OffscreenCanvasCreator.js';
import '../services/aabb/interfaces.js';
import '../services/aabb/CircleUpdater.js';
import '../services/aabb/EllipseUpdater.js';
import '../services/aabb/RectUpdater.js';
import '../services/aabb/TextUpdater.js';
import '../services/aabb/LineUpdater.js';
import '../services/aabb/PolylineUpdater.js';
import '../services/aabb/PathUpdater.js';
import '../shapes/AABB.js';
import '../shapes/BoundingSphere.js';
import '../shapes/Frustum.js';
import '../shapes/Plane.js';
import '../shapes/Ray.js';
import { Point } from '../shapes/Point.js';
import '../shapes/Rectangle.js';
import { CanvasConfig } from '../types.js';
import { TOUCH_TO_POINTER, MOUSE_POINTER_ID } from '../utils/event.js';
import isUndefined from '../../../../lodash-es/isUndefined.js';

/**
 * support mouse & touch events
 * @see https://github.com/pixijs/pixi.js/blob/dev/packages/interaction/README.md
 *
 * also provide some extra events such as `drag`
 */

var EventPlugin =
/** @class */
function () {
  function EventPlugin() {
    var _this = this;

    this.autoPreventDefault = true;
    this.rootPointerEvent = new FederatedPointerEvent(null);
    this.rootWheelEvent = new FederatedWheelEvent(null);

    this.onPointerMove = function (nativeEvent) {
      var e_1, _a;

      var _b, _c;

      var canvas = (_c = (_b = _this.renderingContext.root) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.defaultView;
      if (canvas.supportTouchEvent && nativeEvent.pointerType === 'touch') return;

      var normalizedEvents = _this.normalizeToPointerEvent(nativeEvent, canvas);

      try {
        for (var normalizedEvents_1 = __values(normalizedEvents), normalizedEvents_1_1 = normalizedEvents_1.next(); !normalizedEvents_1_1.done; normalizedEvents_1_1 = normalizedEvents_1.next()) {
          var normalizedEvent = normalizedEvents_1_1.value;

          var event_1 = _this.bootstrapEvent(_this.rootPointerEvent, normalizedEvent, canvas);

          _this.eventService.mapEvent(event_1);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (normalizedEvents_1_1 && !normalizedEvents_1_1.done && (_a = normalizedEvents_1.return)) _a.call(normalizedEvents_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }

      _this.setCursor(_this.eventService.cursor);
    };
  }

  EventPlugin_1 = EventPlugin;

  EventPlugin.prototype.apply = function (renderingService) {
    var _this = this;

    var canvas = this.renderingContext.root.ownerDocument.defaultView;
    this.eventService.setPickHandler(function (position) {
      return __awaiter(_this, void 0, void 0, function () {
        var picked;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              return [4
              /*yield*/
              , this.renderingService.hooks.pick.promise({
                position: position,
                picked: [],
                topmost: true // we only concern the topmost element

              })];

            case 1:
              picked = _a.sent().picked;
              return [2
              /*return*/
              , picked[0] || null];
          }
        });
      });
    });
    renderingService.hooks.pointerWheel.tap(EventPlugin_1.tag, function (nativeEvent) {
      var wheelEvent = _this.normalizeWheelEvent(nativeEvent);

      _this.eventService.mapEvent(wheelEvent);
    });
    renderingService.hooks.pointerDown.tap(EventPlugin_1.tag, function (nativeEvent) {
      var e_2, _a;

      if (canvas.supportTouchEvent && nativeEvent.pointerType === 'touch') {
        return;
      }

      var events = _this.normalizeToPointerEvent(nativeEvent, canvas);

      if (_this.autoPreventDefault && events[0].isNormalized) {
        var cancelable = nativeEvent.cancelable || !('cancelable' in nativeEvent);

        if (cancelable) {
          nativeEvent.preventDefault();
        }
      }

      try {
        for (var events_1 = __values(events), events_1_1 = events_1.next(); !events_1_1.done; events_1_1 = events_1.next()) {
          var event_2 = events_1_1.value;

          var federatedEvent = _this.bootstrapEvent(_this.rootPointerEvent, event_2, canvas);

          _this.eventService.mapEvent(federatedEvent);
        }
      } catch (e_2_1) {
        e_2 = {
          error: e_2_1
        };
      } finally {
        try {
          if (events_1_1 && !events_1_1.done && (_a = events_1.return)) _a.call(events_1);
        } finally {
          if (e_2) throw e_2.error;
        }
      }

      _this.setCursor(_this.eventService.cursor);
    });
    renderingService.hooks.pointerUp.tap(EventPlugin_1.tag, function (nativeEvent) {
      var e_3, _a;

      if (canvas.supportTouchEvent && nativeEvent.pointerType === 'touch') return; // account for element in SVG

      var $element = _this.contextService.getDomElement();

      var outside = $element && nativeEvent.target && nativeEvent.target !== $element && // @ts-ignore
      $element.contains && // @ts-ignore
      !$element.contains(nativeEvent.target) ? 'outside' : '';

      var normalizedEvents = _this.normalizeToPointerEvent(nativeEvent, canvas);

      try {
        for (var normalizedEvents_2 = __values(normalizedEvents), normalizedEvents_2_1 = normalizedEvents_2.next(); !normalizedEvents_2_1.done; normalizedEvents_2_1 = normalizedEvents_2.next()) {
          var normalizedEvent = normalizedEvents_2_1.value;

          var event_3 = _this.bootstrapEvent(_this.rootPointerEvent, normalizedEvent, canvas);

          event_3.type += outside;

          _this.eventService.mapEvent(event_3);
        }
      } catch (e_3_1) {
        e_3 = {
          error: e_3_1
        };
      } finally {
        try {
          if (normalizedEvents_2_1 && !normalizedEvents_2_1.done && (_a = normalizedEvents_2.return)) _a.call(normalizedEvents_2);
        } finally {
          if (e_3) throw e_3.error;
        }
      }

      _this.setCursor(_this.eventService.cursor);
    });
    renderingService.hooks.pointerMove.tap(EventPlugin_1.tag, this.onPointerMove);
    renderingService.hooks.pointerOver.tap(EventPlugin_1.tag, this.onPointerMove);
    renderingService.hooks.pointerOut.tap(EventPlugin_1.tag, this.onPointerMove);
  };

  EventPlugin.prototype.bootstrapEvent = function (event, nativeEvent, view) {
    event.view = view;
    event.originalEvent = null;
    event.nativeEvent = nativeEvent;
    event.pointerId = nativeEvent.pointerId;
    event.width = nativeEvent.width;
    event.height = nativeEvent.height;
    event.isPrimary = nativeEvent.isPrimary;
    event.pointerType = nativeEvent.pointerType;
    event.pressure = nativeEvent.pressure;
    event.tangentialPressure = nativeEvent.tangentialPressure;
    event.tiltX = nativeEvent.tiltX;
    event.tiltY = nativeEvent.tiltY;
    event.twist = nativeEvent.twist;
    this.transferMouseData(event, nativeEvent);

    var _a = this.eventService.client2Viewport(new Point(nativeEvent.clientX, nativeEvent.clientY)),
        x = _a.x,
        y = _a.y;

    event.viewport.x = x;
    event.viewport.y = y;

    var _b = this.eventService.viewport2Canvas(event.viewport),
        canvasX = _b.x,
        canvasY = _b.y;

    event.canvas.x = canvasX;
    event.canvas.y = canvasY;
    event.global.copyFrom(event.canvas);
    event.offset.copyFrom(event.canvas);
    event.isTrusted = nativeEvent.isTrusted;

    if (event.type === 'pointerleave') {
      event.type = 'pointerout';
    }

    if (event.type.startsWith('mouse')) {
      event.type = event.type.replace('mouse', 'pointer');
    }

    if (event.type.startsWith('touch')) {
      event.type = TOUCH_TO_POINTER[event.type] || event.type;
    }

    return event;
  };

  EventPlugin.prototype.normalizeWheelEvent = function (nativeEvent) {
    var event = this.rootWheelEvent;
    this.transferMouseData(event, nativeEvent);
    event.deltaMode = nativeEvent.deltaMode;
    event.deltaX = nativeEvent.deltaX;
    event.deltaY = nativeEvent.deltaY;
    event.deltaZ = nativeEvent.deltaZ;

    var _a = this.eventService.client2Viewport(new Point(nativeEvent.clientX, nativeEvent.clientY)),
        x = _a.x,
        y = _a.y;

    event.viewport.x = x;
    event.viewport.y = y;

    var _b = this.eventService.viewport2Canvas(event.viewport),
        canvasX = _b.x,
        canvasY = _b.y;

    event.canvas.x = canvasX;
    event.canvas.y = canvasY;
    event.global.copyFrom(event.canvas);
    event.offset.copyFrom(event.canvas);
    event.nativeEvent = nativeEvent;
    event.type = nativeEvent.type;
    return event;
  };
  /**
   * Transfers base & mouse event data from the nativeEvent to the federated event.
   */


  EventPlugin.prototype.transferMouseData = function (event, nativeEvent) {
    event.isTrusted = nativeEvent.isTrusted;
    event.timeStamp = performance.now();
    event.type = nativeEvent.type;
    event.altKey = nativeEvent.altKey;
    event.button = nativeEvent.button;
    event.buttons = nativeEvent.buttons;
    event.client.x = nativeEvent.clientX;
    event.client.y = nativeEvent.clientY;
    event.ctrlKey = nativeEvent.ctrlKey;
    event.metaKey = nativeEvent.metaKey;
    event.movement.x = nativeEvent.movementX;
    event.movement.y = nativeEvent.movementY;
    event.page.x = nativeEvent.pageX;
    event.page.y = nativeEvent.pageY;
    event.screen.x = nativeEvent.screenX;
    event.screen.y = nativeEvent.screenY;
    event.relatedTarget = null;
  };

  EventPlugin.prototype.setCursor = function (cursor) {
    this.contextService.applyCursorStyle(cursor || this.canvasConfig.cursor || 'default');
  };

  EventPlugin.prototype.normalizeToPointerEvent = function (event, canvas) {
    var normalizedEvents = [];

    if (canvas.isTouchEvent(event)) {
      for (var i = 0; i < event.changedTouches.length; i++) {
        var touch = event.changedTouches[i]; // use changedTouches instead of touches since touchend has no touches
        // @see https://stackoverflow.com/a/10079076

        if (isUndefined(touch.button)) touch.button = event.touches.length ? 1 : 0;
        if (isUndefined(touch.buttons)) touch.buttons = event.touches.length ? 1 : 0;

        if (isUndefined(touch.isPrimary)) {
          touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';
        }

        if (isUndefined(touch.width)) touch.width = touch.radiusX || 1;
        if (isUndefined(touch.height)) touch.height = touch.radiusY || 1;
        if (isUndefined(touch.tiltX)) touch.tiltX = 0;
        if (isUndefined(touch.tiltY)) touch.tiltY = 0;
        if (isUndefined(touch.pointerType)) touch.pointerType = 'touch'; // @see https://developer.mozilla.org/zh-CN/docs/Web/API/Touch/identifier

        if (isUndefined(touch.pointerId)) touch.pointerId = touch.identifier || 0;
        if (isUndefined(touch.pressure)) touch.pressure = touch.force || 0.5;
        if (isUndefined(touch.twist)) touch.twist = 0;
        if (isUndefined(touch.tangentialPressure)) touch.tangentialPressure = 0;
        touch.isNormalized = true;
        touch.type = event.type; // ref to nativeEvent
        // touch.nativeEvent = event;
        // touch.isLast = event.changedTouches.length - 1 === i;

        normalizedEvents.push(touch);
      }
    } else if (canvas.isMouseEvent(event)) {
      var tempEvent = event;
      if (isUndefined(tempEvent.isPrimary)) tempEvent.isPrimary = true;
      if (isUndefined(tempEvent.width)) tempEvent.width = 1;
      if (isUndefined(tempEvent.height)) tempEvent.height = 1;
      if (isUndefined(tempEvent.tiltX)) tempEvent.tiltX = 0;
      if (isUndefined(tempEvent.tiltY)) tempEvent.tiltY = 0;
      if (isUndefined(tempEvent.pointerType)) tempEvent.pointerType = 'mouse';
      if (isUndefined(tempEvent.pointerId)) tempEvent.pointerId = MOUSE_POINTER_ID;
      if (isUndefined(tempEvent.pressure)) tempEvent.pressure = 0.5;
      if (isUndefined(tempEvent.twist)) tempEvent.twist = 0;
      if (isUndefined(tempEvent.tangentialPressure)) tempEvent.tangentialPressure = 0;
      tempEvent.isNormalized = true;
      normalizedEvents.push(tempEvent);
    } else {
      normalizedEvents.push(event);
    }

    return normalizedEvents;
  };

  var EventPlugin_1;
  EventPlugin.tag = 'EventPlugin';

  __decorate([inject(CanvasConfig), __metadata("design:type", Object)], EventPlugin.prototype, "canvasConfig", void 0);

  __decorate([inject(ContextService), __metadata("design:type", Object)], EventPlugin.prototype, "contextService", void 0);

  __decorate([inject(RenderingService), __metadata("design:type", RenderingService)], EventPlugin.prototype, "renderingService", void 0);

  __decorate([inject(RenderingContext), __metadata("design:type", Object)], EventPlugin.prototype, "renderingContext", void 0);

  __decorate([inject(EventService), __metadata("design:type", EventService)], EventPlugin.prototype, "eventService", void 0);

  EventPlugin = EventPlugin_1 = __decorate([singleton({
    contrib: RenderingPluginContribution
  })], EventPlugin);
  return EventPlugin;
}();

export { EventPlugin };
