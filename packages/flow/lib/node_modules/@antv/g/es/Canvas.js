import { __extends } from '../../../tslib/tslib.es6.js';
import '../../../inversify/lib/inversify.js';
import '../../../mana-syringe/es/core.js';
import '../../../mana-syringe/es/inversify/index.js';
import { GlobalContainer } from '../../../mana-syringe/es/container.js';
import '../../../mana-syringe/es/contribution/contribution-protocol.js';
import '../../../mana-syringe/es/register.js';
import '../../../mana-syringe/es/contribution/index.js';
import { requestAnimationFrame as raf, cancelAnimationFrame as caf } from '../../../request-animation-frame-polyfill/dist/index.esm.min.js';
import { CanvasConfig } from './types.js';
import { cleanExistedCanvas, isBrowser } from './utils/canvas.js';
import { DisplayObject } from './display-objects/DisplayObject.js';
import './services/SceneGraphService.js';
import { ContextService } from './services/ContextService.js';
import { RenderingContext, RenderReason } from './services/RenderingContext.js';
import { RenderingService } from './services/RenderingService.js';
import { EventService } from './services/EventService.js';
import './services/SceneGraphSelector.js';
import './services/TextService.js';
import './services/OffscreenCanvasCreator.js';
import './services/aabb/interfaces.js';
import './services/aabb/CircleUpdater.js';
import './services/aabb/EllipseUpdater.js';
import './services/aabb/RectUpdater.js';
import './services/aabb/TextUpdater.js';
import './services/aabb/LineUpdater.js';
import './services/aabb/PolylineUpdater.js';
import './services/aabb/PathUpdater.js';
import { Camera, CameraEvent, DefaultCamera, CameraProjectionMode } from './camera/Camera.js';
import { containerModule } from './canvas-module.js';
import { ElementEvent } from './dom/interfaces.js';
import { EventTarget } from './dom/EventTarget.js';
import './dom/Node.js';
import './dom/Element.js';
import { Document } from './dom/Document.js';
import './dom/FederatedEvent.js';
import './dom/FederatedMouseEvent.js';
import './dom/FederatedPointerEvent.js';
import './dom/FederatedWheelEvent.js';
import './dom/Animation.js';
import './dom/AnimationEvent.js';
import './dom/AnimationEffectTiming.js';
import './dom/CustomEvent.js';
import './dom/MutationEvent.js';
import './dom/KeyframeEffect.js';
import './dom/AnimationTimeline.js';
import { CustomElementRegistry } from './dom/CustomElementRegistry.js';

var CanvasEvent;

(function (CanvasEvent) {
  CanvasEvent["READY"] = "ready";
  CanvasEvent["BEFORE_RENDER"] = "beforerender";
  CanvasEvent["AFTER_RENDER"] = "afterrender";
  CanvasEvent["BEFORE_DESTROY"] = "beforedestroy";
  CanvasEvent["AFTER_DESTROY"] = "afterdestroy";
  CanvasEvent["RESIZE"] = "resize";
})(CanvasEvent || (CanvasEvent = {}));
/**
 * can be treated like Window in DOM
 * provide some extra methods like `window`, such as:
 * * `window.requestAnimationFrame`
 * * `window.devicePixelRatio`
 *
 * prototype chains: Canvas(Window) -> EventTarget
 */


var Canvas =
/** @class */
function (_super) {
  __extends(Canvas, _super);

  function Canvas(config) {
    var _this = _super.call(this) || this;
    /**
     * child container of current canvas, use hierarchy container
     */


    _this.container = GlobalContainer.createChild();
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element
     */

    _this.Element = DisplayObject;
    _this.inited = false; // create document

    _this.document = new Document();
    _this.document.defaultView = _this; // create registry of custom elements

    _this.customElements = new CustomElementRegistry();
    var container = config.container,
        canvas = config.canvas,
        offscreenCanvas = config.offscreenCanvas,
        width = config.width,
        height = config.height,
        devicePixelRatio = config.devicePixelRatio,
        renderer = config.renderer,
        background = config.background,
        requestAnimationFrame = config.requestAnimationFrame,
        cancelAnimationFrame = config.cancelAnimationFrame,
        createImage = config.createImage,
        supportPointerEvent = config.supportPointerEvent,
        supportTouchEvent = config.supportTouchEvent,
        isTouchEvent = config.isTouchEvent,
        isMouseEvent = config.isMouseEvent;
    cleanExistedCanvas(container, _this);
    var canvasWidth = width;
    var canvasHeight = height;
    var dpr = devicePixelRatio; // use user-defined <canvas> or OffscreenCanvas

    if (canvas) {
      // infer width & height with dpr
      dpr = devicePixelRatio || isBrowser && window.devicePixelRatio || 1;
      dpr = dpr >= 1 ? Math.ceil(dpr) : 1;
      canvasWidth = width || canvas.width / dpr;
      canvasHeight = height || canvas.height / dpr;
    }
    /**
     * implements `Window` interface
     */


    _this.devicePixelRatio = dpr;
    _this.requestAnimationFrame = requestAnimationFrame !== null && requestAnimationFrame !== void 0 ? requestAnimationFrame : raf.bind(globalThis);
    _this.cancelAnimationFrame = cancelAnimationFrame !== null && cancelAnimationFrame !== void 0 ? cancelAnimationFrame : caf.bind(globalThis);
    /**
     * limits query
     */

    _this.supportTouchEvent = supportTouchEvent !== null && supportTouchEvent !== void 0 ? supportTouchEvent : 'ontouchstart' in globalThis;
    _this.supportPointerEvent = supportPointerEvent !== null && supportPointerEvent !== void 0 ? supportPointerEvent : !!globalThis.PointerEvent;
    _this.isTouchEvent = isTouchEvent !== null && isTouchEvent !== void 0 ? isTouchEvent : function (event) {
      return _this.supportTouchEvent && event instanceof globalThis.TouchEvent;
    };
    _this.isMouseEvent = isMouseEvent !== null && isMouseEvent !== void 0 ? isMouseEvent : function (event) {
      return !globalThis.MouseEvent || event instanceof globalThis.MouseEvent && (!_this.supportPointerEvent || !(event instanceof globalThis.PointerEvent));
    };

    _this.initRenderingContext({
      container: container,
      canvas: canvas,
      width: canvasWidth,
      height: canvasHeight,
      renderer: renderer,
      offscreenCanvas: offscreenCanvas,
      devicePixelRatio: dpr,
      cursor: 'default',
      background: background,
      createImage: createImage
    });

    _this.initDefaultCamera(canvasWidth, canvasHeight);

    _this.initRenderer(renderer);

    return _this;
  }

  Canvas.prototype.initRenderingContext = function (mergedConfig) {
    var _this = this;

    this.container.register({
      token: CanvasConfig,
      useValue: mergedConfig
    }); // bind rendering context, shared by all renderers

    this.container.register({
      token: RenderingContext,
      useValue: {
        /**
         * the root node in scene graph
         */
        root: this.document.documentElement,
        renderReasons: new Set(),
        force: false,
        dirty: false
      }
    });
    this.document.documentElement.addEventListener(ElementEvent.CHILD_INSERTED, function (e) {
      _this.mountChildren(e.detail.child);
    });
    this.document.documentElement.addEventListener(ElementEvent.CHILD_REMOVED, function (e) {
      _this.unmountChildren(e.detail.child);
    });
  };

  Canvas.prototype.initDefaultCamera = function (width, height) {
    // set a default ortho camera
    var camera = new Camera().setPosition(width / 2, height / 2, 500).setFocalPoint(width / 2, height / 2, 0).setOrthographic(width / -2, width / 2, height / 2, height / -2, 0.1, 1000); // keep ref since it will use raf in camera animation

    camera.canvas = this; // redraw when camera changed

    var context = this.container.get(RenderingContext);
    camera.on(CameraEvent.UPDATED, function () {
      context.renderReasons.add(RenderReason.CAMERA_CHANGED);
    }); // bind camera

    this.container.register({
      token: DefaultCamera,
      useValue: camera
    });
  };

  Canvas.prototype.getConfig = function () {
    return this.container.get(CanvasConfig);
  };

  Canvas.prototype.getContainer = function () {
    return this.container;
  };
  /**
   * get the root displayObject in scenegraph
   * @alias this.document.documentElement
   */


  Canvas.prototype.getRoot = function () {
    return this.document.documentElement;
  };
  /**
   * get the camera of canvas
   */


  Canvas.prototype.getCamera = function () {
    return this.container.get(DefaultCamera);
  };

  Canvas.prototype.getContextService = function () {
    return this.container.get(ContextService);
  };

  Canvas.prototype.getEventService = function () {
    return this.eventService;
  };

  Canvas.prototype.getRenderingService = function () {
    return this.renderingService;
  };

  Canvas.prototype.getRenderingContext = function () {
    return this.container.get(RenderingContext);
  };

  Canvas.prototype.getStats = function () {
    return this.getRenderingService().getStats();
  };

  Object.defineProperty(Canvas.prototype, "ready", {
    // /**
    //  * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Window/getComputedStyle
    //  */
    // getComputedStyle(node: DisplayObject) {
    //   return node.computedStyle;
    // }
    get: function get() {
      var _this = this;

      if (!this.readyPromise) {
        this.readyPromise = new Promise(function (resolve) {
          _this.resolveReadyPromise = function () {
            resolve(_this);
          };
        });

        if (this.inited) {
          this.resolveReadyPromise();
        }
      }

      return this.readyPromise;
    },
    enumerable: false,
    configurable: true
  });

  Canvas.prototype.destroy = function (destroyScenegraph) {
    if (destroyScenegraph === void 0) {
      destroyScenegraph = true;
    }

    this.emit(CanvasEvent.BEFORE_DESTROY, function () {});

    if (this.frameId) {
      var cancelRAF_1 = this.getConfig().cancelAnimationFrame || cancelAnimationFrame;
      cancelRAF_1(this.frameId);
    } // unmount all children


    var root = this.getRoot();
    this.unmountChildren(root); // root.children.forEach((child: DisplayObject) => {
    //   this.unmountChildren(child);
    // });

    if (destroyScenegraph) {
      // destroy Document
      this.document.destroy();
    } // destroy services


    this.getContextService().destroy();
    this.getRenderingService().destroy();
    this.emit(CanvasEvent.AFTER_DESTROY, {});
  };
  /**
   * compatible with G 3.0
   * @deprecated
   * @alias resize
   */


  Canvas.prototype.changeSize = function (width, height) {
    this.resize(width, height);
  };

  Canvas.prototype.resize = function (width, height) {
    // update canvas' config
    var canvasConfig = this.container.get(CanvasConfig);
    canvasConfig.width = width;
    canvasConfig.height = height; // resize context

    this.getContextService().resize(width, height); // resize camera

    var camera = this.container.get(DefaultCamera);
    var projectionMode = camera.getProjectionMode();
    camera.setPosition(width / 2, height / 2, 500).setFocalPoint(width / 2, height / 2, 0);

    if (projectionMode === CameraProjectionMode.ORTHOGRAPHIC) {
      camera.setOrthographic(width / -2, width / 2, height / 2, height / -2, camera.getNear(), camera.getFar());
    } else {
      camera.setAspect(width / height);
    }

    this.emit(CanvasEvent.RESIZE, {
      width: width,
      height: height
    });
  }; // proxy to document.documentElement


  Canvas.prototype.appendChild = function (child, index) {
    return this.document.documentElement.appendChild(child, index);
  };

  Canvas.prototype.insertBefore = function (newChild, refChild) {
    return this.document.documentElement.insertBefore(newChild, refChild);
  };

  Canvas.prototype.removeChild = function (child, destroy) {
    if (destroy === void 0) {
      destroy = true;
    }

    return this.document.documentElement.removeChild(child, destroy);
  };

  Canvas.prototype.removeChildren = function (destroy) {
    if (destroy === void 0) {
      destroy = true;
    }

    this.document.documentElement.removeChildren(destroy);
  };

  Canvas.prototype.render = function () {
    this.emit(CanvasEvent.BEFORE_RENDER, {});

    if (this.container.isBound(RenderingService)) {
      var renderingService = this.container.get(RenderingService);
      renderingService.render(this.getConfig());
    }

    this.emit(CanvasEvent.AFTER_RENDER, {});
  };

  Canvas.prototype.run = function () {
    var _this = this;

    var tick = function tick() {
      _this.render();

      _this.frameId = requestAnimationFrame(tick);
    };

    tick();
  };

  Canvas.prototype.initRenderer = function (renderer) {
    var _this = this;

    if (!renderer) {
      throw new Error('Renderer is required.');
    } // reset


    this.inited = false;
    this.readyPromise = undefined;
    this.loadCommonContainerModule();
    this.loadRendererContainerModule(renderer); // init context

    var contextService = this.container.get(ContextService);
    this.renderingService = this.container.get(RenderingService);
    this.eventService = this.container.get(EventService);
    contextService.init();
    this.renderingService.init().then(function () {
      _this.emit(CanvasEvent.READY, {});

      if (_this.readyPromise) {
        _this.resolveReadyPromise();
      }

      _this.inited = true;
    });

    if (renderer.getConfig().enableAutoRendering) {
      this.run();
    }

    this.getRoot().forEach(function (node) {
      var renderable = node.renderable;

      if (renderable) {
        renderable.renderBoundsDirty = true;
        renderable.boundsDirty = true;
        renderable.dirty = true;
      }
    }); // keep current scenegraph unchanged, just trigger mounted event

    this.mountChildren(this.getRoot());
  };

  Canvas.prototype.loadCommonContainerModule = function () {
    this.container.unload(containerModule);
    this.container.load(containerModule, true);
  };

  Canvas.prototype.loadRendererContainerModule = function (renderer) {
    var _this = this; // load other container modules provided by g-canvas/g-svg/g-webgl


    var plugins = renderer.getPlugins();
    plugins.forEach(function (plugin) {
      plugin.init(_this.container);
    });
  };

  Canvas.prototype.setRenderer = function (renderer) {
    var _this = this; // update canvas' config


    var canvasConfig = this.getConfig();

    if (canvasConfig.renderer === renderer) {
      return;
    }

    var oldRenderer = canvasConfig.renderer;
    canvasConfig.renderer = renderer; // keep all children undestroyed

    this.destroy(false); // destroy all plugins

    oldRenderer === null || oldRenderer === void 0 ? void 0 : oldRenderer.getPlugins().reverse().forEach(function (plugin) {
      plugin.destroy(_this.container);
    });
    this.initRenderer(renderer);
  };

  Canvas.prototype.setCursor = function (cursor) {
    this.getContextService().applyCursorStyle(cursor);
  };

  Canvas.prototype.unmountChildren = function (parent) {
    var _this = this;

    var path = [];
    parent.forEach(function (child) {
      if (child.isConnected) {
        path.push(child);
      }
    }); // unmount from leaf to root

    path.reverse().forEach(function (child) {
      child.emit(ElementEvent.UNMOUNTED, {}); // skip document.documentElement

      if (child !== _this.document.documentElement) {
        child.ownerDocument = null;
      }

      child.isConnected = false;
    });
  };

  Canvas.prototype.mountChildren = function (parent) {
    var _this = this;

    parent.forEach(function (child) {
      if (!child.isConnected) {
        child.ownerDocument = _this.document;
        child.isConnected = true;
        child.emit(ElementEvent.MOUNTED, {});
      }
    });
  };

  Canvas.prototype.client2Viewport = function (client) {
    return this.getEventService().client2Viewport(client);
  };

  Canvas.prototype.viewport2Client = function (canvas) {
    return this.getEventService().viewport2Client(canvas);
  };

  Canvas.prototype.viewport2Canvas = function (viewport) {
    return this.getEventService().viewport2Canvas(viewport);
  };

  Canvas.prototype.canvas2Viewport = function (canvas) {
    return this.getEventService().canvas2Viewport(canvas);
  };
  /**
   * @deprecated
   * @alias client2Viewport
   */


  Canvas.prototype.getPointByClient = function (clientX, clientY) {
    return this.client2Viewport({
      x: clientX,
      y: clientY
    });
  };
  /**
   * @deprecated
   * @alias viewport2Client
   */


  Canvas.prototype.getClientByPoint = function (x, y) {
    return this.viewport2Client({
      x: x,
      y: y
    });
  };

  return Canvas;
}(EventTarget);

export { Canvas, CanvasEvent };
