import { __extends, __values } from '../../../../tslib/tslib.es6.js';
import { Shape } from '../types.js';
import { EventTarget } from './EventTarget.js';

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Node
 */

var Node =
/** @class */
function (_super) {
  __extends(Node, _super);

  function Node() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.shadow = false;
    /**
     * points to canvas.document
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/ownerDocument
     */

    _this.ownerDocument = null;
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/isConnected
     * @example
        circle.isConnected; // false
        canvas.appendChild(circle);
        circle.isConnected; // true
     */

    _this.isConnected = false;
    /**
     * Returns node's node document's document base URL.
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node
     */

    _this.baseURI = '';
    /**
     * Returns the children.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/childNodes
     */

    _this.childNodes = [];
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType
     */

    _this.nodeType = 0;
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeName
     */

    _this.nodeName = '';
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeValue
     */

    _this.nodeValue = null;
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/ParentNode
     */

    _this.parentNode = null;
    return _this;
  }

  Node.isNode = function (target) {
    return !!target.childNodes;
  };

  Object.defineProperty(Node.prototype, "textContent", {
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/textContent
     */
    get: function get() {
      var e_1, _a;

      var out = '';

      if (this.nodeName === Shape.TEXT) {
        // @ts-ignore
        out += this.style.text;
      }

      try {
        for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
          var child = _c.value;

          if (child.nodeName === Shape.TEXT) {
            out += child.nodeValue;
          } else {
            out += child.textContent;
          }
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally {
          if (e_1) throw e_1.error;
        }
      }

      return out;
    },
    set: function set(content) {
      var _this = this; // remove all children


      this.childNodes.slice().forEach(function (child) {
        _this.removeChild(child, true);
      });

      if (this.nodeName === Shape.TEXT) {
        // @ts-ignore
        this.style.text = "".concat(content);
      }
    },
    enumerable: false,
    configurable: true
  });
  /**
   * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/getRootNode
   */

  Node.prototype.getRootNode = function (opts) {
    if (opts === void 0) {
      opts = {};
    }

    if (this.parentNode) {
      return this.parentNode.getRootNode(opts);
    }

    if (opts.composed && this.host) {
      return this.host.getRootNode(opts);
    }

    return this;
  };

  Node.prototype.hasChildNodes = function () {
    return this.childNodes.length > 0;
  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars


  Node.prototype.isDefaultNamespace = function (namespace) {
    throw new Error('Method not implemented.');
  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars


  Node.prototype.lookupNamespaceURI = function (prefix) {
    throw new Error('Method not implemented.');
  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars


  Node.prototype.lookupPrefix = function (namespace) {
    throw new Error('Method not implemented.');
  };

  Node.prototype.normalize = function () {
    throw new Error('Method not implemented.');
  };
  /**
   * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/isEqualNode
   */


  Node.prototype.isEqualNode = function (otherNode) {
    // TODO: compare 2 nodes, not sameness
    return this === otherNode;
  };

  Node.prototype.isSameNode = function (otherNode) {
    return this.isEqualNode(otherNode);
  };

  Object.defineProperty(Node.prototype, "parent", {
    /**
     * @deprecated
     * @alias parentNode
     */
    get: function get() {
      return this.parentNode;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Node.prototype, "parentElement", {
    get: function get() {
      return null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Node.prototype, "nextSibling", {
    get: function get() {
      return null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Node.prototype, "previousSibling", {
    get: function get() {
      return null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Node.prototype, "firstChild", {
    get: function get() {
      return this.childNodes.length > 0 ? this.childNodes[0] : null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Node.prototype, "lastChild", {
    get: function get() {
      return this.childNodes.length > 0 ? this.childNodes[this.childNodes.length - 1] : null;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
   * @see https://github.com/b-fuze/deno-dom/blob/master/src/dom/node.ts#L338
   */

  Node.prototype.compareDocumentPosition = function (other) {
    var _a;

    if (other === this) {
      // same node
      return 0;
    }

    if (!(other instanceof Node)) {
      throw new TypeError('Node.compareDocumentPosition: Argument 1 does not implement interface Node.');
    }

    var node1Root = other; // eslint-disable-next-line @typescript-eslint/no-this-alias

    var node2Root = this;
    var node1Hierarchy = [node1Root];
    var node2Hierarchy = [node2Root];

    while ((_a = node1Root.parentNode) !== null && _a !== void 0 ? _a : node2Root.parentNode) {
      node1Root = node1Root.parentNode ? (node1Hierarchy.push(node1Root.parentNode), node1Root.parentNode) : node1Root;
      node2Root = node2Root.parentNode ? (node2Hierarchy.push(node2Root.parentNode), node2Root.parentNode) : node2Root;
    } // Check if they don't share the same root node


    if (node1Root !== node2Root) {
      return Node.DOCUMENT_POSITION_DISCONNECTED | Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | Node.DOCUMENT_POSITION_PRECEDING;
    }

    var longerHierarchy = node1Hierarchy.length > node2Hierarchy.length ? node1Hierarchy : node2Hierarchy;
    var shorterHierarchy = longerHierarchy === node1Hierarchy ? node2Hierarchy : node1Hierarchy; // Check if either is a container of the other

    if (longerHierarchy[longerHierarchy.length - shorterHierarchy.length] === shorterHierarchy[0]) {
      return longerHierarchy === node1Hierarchy ? // other is a child of this
      Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_FOLLOWING : // this is a child of other
      Node.DOCUMENT_POSITION_CONTAINS | Node.DOCUMENT_POSITION_PRECEDING;
    } // Find their first common ancestor and see whether they
    // are preceding or following


    var longerStart = longerHierarchy.length - shorterHierarchy.length;

    for (var i = shorterHierarchy.length - 1; i >= 0; i--) {
      var shorterHierarchyNode = shorterHierarchy[i];
      var longerHierarchyNode = longerHierarchy[longerStart + i]; // We found the first common ancestor

      if (longerHierarchyNode !== shorterHierarchyNode) {
        var siblings = shorterHierarchyNode.parentNode.childNodes;

        if (siblings.indexOf(shorterHierarchyNode) < siblings.indexOf(longerHierarchyNode)) {
          // Shorter is before longer
          if (shorterHierarchy === node1Hierarchy) {
            // Other is before this
            return Node.DOCUMENT_POSITION_PRECEDING;
          } else {
            // This is before other
            return Node.DOCUMENT_POSITION_FOLLOWING;
          }
        } else {
          // Longer is before shorter
          if (longerHierarchy === node1Hierarchy) {
            // Other is before this
            return Node.DOCUMENT_POSITION_PRECEDING;
          } else {
            // Other is after this
            return Node.DOCUMENT_POSITION_FOLLOWING;
          }
        }
      }
    }

    return Node.DOCUMENT_POSITION_FOLLOWING;
  };
  /**
   * @deprecated
   * @alias contains
   */


  Node.prototype.contain = function (other) {
    return this.contains(other);
  };

  Node.prototype.contains = function (other) {
    // the node itself, one of its direct children
    var tmp = other; // @see https://developer.mozilla.org/en-US/docs/Web/API/Node/contains

    while (tmp && this !== tmp) {
      tmp = tmp.parentNode;
    }

    return !!tmp;
  };

  Node.prototype.getAncestor = function (n) {
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    var temp = this;

    while (n > 0 && temp) {
      temp = temp.parentNode;
      n--;
    }

    return temp;
  };

  Node.prototype.forEach = function (callback) {
    if (!callback(this)) {
      this.childNodes.forEach(function (child) {
        child.forEach(callback);
      });
    }
  };
  /**
   * Both nodes are in different documents or different trees in the same document.
   */


  Node.DOCUMENT_POSITION_DISCONNECTED = 1;
  /**
   * otherNode precedes the node in either a pre-order depth-first traversal
   * of a tree containing both (e.g., as an ancestor or previous sibling or a descendant of a previous sibling or previous sibling of an ancestor) or (if they are disconnected) in an arbitrary but consistent ordering.
   */

  Node.DOCUMENT_POSITION_PRECEDING = 2;
  /**
   * otherNode follows the node in either a pre-order depth-first traversal of a tree containing both (e.g., as a descendant or following sibling or a descendant of a following sibling or following sibling of an ancestor) or (if they are disconnected) in an arbitrary but consistent ordering.
   */

  Node.DOCUMENT_POSITION_FOLLOWING = 4;
  /**
   * otherNode is an ancestor of the node.
   */

  Node.DOCUMENT_POSITION_CONTAINS = 8;
  /**
   * otherNode is a descendant of the node.
   */

  Node.DOCUMENT_POSITION_CONTAINED_BY = 16;
  /**
   * The result relies upon arbitrary and/or implementation-specific behavior and is not guaranteed to be portable.
   */

  Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;
  return Node;
}(EventTarget);

export { Node };
