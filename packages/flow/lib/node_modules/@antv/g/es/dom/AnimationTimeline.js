import { __spreadArray, __read } from '../../../../tslib/tslib.es6.js';
import { Animation } from './Animation.js';

function compareAnimations(leftAnimation, rightAnimation) {
  return Number(leftAnimation.id) - Number(rightAnimation.id);
}
/**
 * @see https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/web-animations-js/index.d.ts
 */

var AnimationTimeline =
/** @class */
function () {
  function AnimationTimeline(document) {
    var _this = this;

    this.document = document;
    /**
     * all active animations
     */

    this.animations = [];
    this.ticking = false;
    this.timelineTicking = false;
    this.hasRestartedThisFrame = false;
    this.animationsWithPromises = [];
    this.inTick = false;
    this.pendingEffects = [];
    this.currentTime = null;
    this.rafId = 0;
    this.rafCallbacks = [];

    this.webAnimationsNextTick = function (t) {
      _this.currentTime = t;

      _this.discardAnimations();

      if (_this.animations.length === 0) {
        _this.timelineTicking = false;
      } else {
        _this.requestAnimationFrame(_this.webAnimationsNextTick);
      }
    };

    this.processRafCallbacks = function (t) {
      var processing = _this.rafCallbacks;
      _this.rafCallbacks = [];
      if (t < Number(_this.currentTime)) t = Number(_this.currentTime);

      _this.animations.sort(compareAnimations);

      _this.animations = _this.tick(t, true, _this.animations)[0];
      processing.forEach(function (entry) {
        entry[1](t);
      });

      _this.applyPendingEffects();
    };
  }

  AnimationTimeline.prototype.getAnimations = function () {
    this.discardAnimations();
    return this.animations.slice();
  };

  AnimationTimeline.prototype.isTicking = function () {
    return this.inTick;
  };

  AnimationTimeline.prototype.play = function (effect) {
    var animation = new Animation(effect, this);
    this.animations.push(animation);
    this.restartWebAnimationsNextTick();
    animation.updatePromises();
    animation.play();
    animation.updatePromises();
    return animation;
  }; // RAF is supposed to be the last script to occur before frame rendering but not
  // all browsers behave like this. This function is for synchonously updating an
  // animation's effects whenever its state is mutated by script to work around
  // incorrect script execution ordering by the browser.


  AnimationTimeline.prototype.applyDirtiedAnimation = function (animation) {
    var _this = this;

    if (this.inTick) {
      return;
    } // update active animations in displayobject


    animation.markTarget();
    var animations = animation.targetAnimations();
    animations.sort(compareAnimations); // clear inactive animations

    var inactiveAnimations = this.tick(Number(this.currentTime), false, animations.slice())[1];
    inactiveAnimations.forEach(function (animation) {
      var index = _this.animations.indexOf(animation);

      if (index !== -1) {
        _this.animations.splice(index, 1);
      }
    });
    this.applyPendingEffects();
  };

  AnimationTimeline.prototype.restart = function () {
    if (!this.ticking) {
      this.ticking = true;
      this.requestAnimationFrame(function () {});
      this.hasRestartedThisFrame = true;
    }

    return this.hasRestartedThisFrame;
  };

  AnimationTimeline.prototype.destroy = function () {
    this.document.defaultView.cancelAnimationFrame(this.frameId);
  };

  AnimationTimeline.prototype.applyPendingEffects = function () {
    this.pendingEffects.forEach(function (effect) {
      effect === null || effect === void 0 ? void 0 : effect.applyInterpolations();
    });
    this.pendingEffects = [];
  };

  AnimationTimeline.prototype.updateAnimationsPromises = function () {
    this.animationsWithPromises = this.animationsWithPromises.filter(function (animation) {
      return animation.updatePromises();
    });
  };

  AnimationTimeline.prototype.discardAnimations = function () {
    this.updateAnimationsPromises();
    this.animations = this.animations.filter(function (animation) {
      return animation.playState !== 'finished' && animation.playState !== 'idle';
    });
  };

  AnimationTimeline.prototype.restartWebAnimationsNextTick = function () {
    if (!this.timelineTicking) {
      this.timelineTicking = true;
      this.requestAnimationFrame(this.webAnimationsNextTick);
    }
  };

  AnimationTimeline.prototype.rAF = function (f) {
    var id = this.rafId++;

    if (this.rafCallbacks.length === 0) {
      this.frameId = this.document.defaultView.requestAnimationFrame(this.processRafCallbacks);
    }

    this.rafCallbacks.push([id, f]);
    return id;
  };

  AnimationTimeline.prototype.requestAnimationFrame = function (f) {
    var _this = this;

    return this.rAF(function (x) {
      _this.updateAnimationsPromises();

      f(x);

      _this.updateAnimationsPromises();
    });
  };

  AnimationTimeline.prototype.tick = function (t, isAnimationFrame, updatingAnimations) {
    var _a, _b;

    var _this = this;

    this.inTick = true;
    this.hasRestartedThisFrame = false;
    this.currentTime = t;
    this.ticking = false;
    var newPendingClears = [];
    var newPendingEffects = [];
    var activeAnimations = [];
    var inactiveAnimations = [];
    updatingAnimations.forEach(function (animation) {
      animation.tick(t, isAnimationFrame);

      if (!animation._inEffect) {
        newPendingClears.push(animation.effect);
        animation.unmarkTarget();
      } else {
        newPendingEffects.push(animation.effect);
        animation.markTarget();
      }

      if (animation._needsTick) _this.ticking = true;
      var alive = animation._inEffect || animation._needsTick;
      animation._inTimeline = alive;

      if (alive) {
        activeAnimations.push(animation);
      } else {
        inactiveAnimations.push(animation);
      }
    });

    (_a = this.pendingEffects).push.apply(_a, __spreadArray([], __read(newPendingClears), false));

    (_b = this.pendingEffects).push.apply(_b, __spreadArray([], __read(newPendingEffects), false));

    if (this.ticking) this.requestAnimationFrame(function () {});
    this.inTick = false;
    return [activeAnimations, inactiveAnimations];
  };

  return AnimationTimeline;
}();

export { AnimationTimeline, compareAnimations };
