import { __read, __spreadArray } from '../../../../tslib/tslib.es6.js';
import CubicUtil from '../../../g-math/es/cubic.js';
import '../types.js';

function midPoint(a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var bx = b[0];
  var by = b[1];
  return [ax + (bx - ax) * t, ay + (by - ay) * t];
}

function splitCubic(pts, t) {
  if (t === void 0) {
    t = 0.5;
  }

  var p0 = pts.slice(0, 2);
  var p1 = pts.slice(2, 4);
  var p2 = pts.slice(4, 6);
  var p3 = pts.slice(6, 8);
  var p4 = midPoint(p0, p1, t);
  var p5 = midPoint(p1, p2, t);
  var p6 = midPoint(p2, p3, t);
  var p7 = midPoint(p4, p5, t);
  var p8 = midPoint(p5, p6, t);
  var p9 = midPoint(p7, p8, t);
  return [// @ts-ignore
  ['C'].concat(p4, p7, p9), // @ts-ignore
  ['C'].concat(p8, p6, p3)];
}

function getCurveArray(segments) {
  return segments.map(function (segment, i, pathArray) {
    // @ts-ignore
    var segmentData = i && pathArray[i - 1].slice(-2).concat(segment.slice(1)); // @ts-ignore

    var curveLength = i ? CubicUtil.length.apply(CubicUtil, __spreadArray([], __read(segmentData), false)) : 0;
    var subsegs;

    if (i) {
      // must be [segment,segment]
      subsegs = curveLength ? splitCubic(segmentData) : [segment, segment];
    } else {
      subsegs = [segment];
    }

    return {
      s: segment,
      ss: subsegs,
      l: curveLength
    };
  });
}

function equalizeSegments(path1, path2, TL) {
  var c1 = getCurveArray(path1);
  var c2 = getCurveArray(path2);
  var L1 = c1.length;
  var L2 = c2.length;
  var l1 = c1.filter(function (x) {
    return x.l;
  }).length;
  var l2 = c2.filter(function (x) {
    return x.l;
  }).length;
  var m1 = c1.filter(function (x) {
    return x.l;
  }).reduce(function (a, _a) {
    var l = _a.l;
    return a + l;
  }, 0) / l1 || 0;
  var m2 = c2.filter(function (x) {
    return x.l;
  }).reduce(function (a, _a) {
    var l = _a.l;
    return a + l;
  }, 0) / l2 || 0;
  var tl = TL || Math.max(L1, L2);
  var mm = [m1, m2];
  var dif = [tl - L1, tl - L2];
  var canSplit = 0;
  var result = [c1, c2].map(function (x, i) {
    // @ts-ignore
    return x.l === tl ? x.map(function (y) {
      return y.s;
    }) : x.map(function (y, j) {
      canSplit = j && dif[i] && y.l >= mm[i];
      dif[i] -= canSplit ? 1 : 0;
      return canSplit ? y.ss : [y.s];
    }).flat();
  });
  return result[0].length === result[1].length ? result : equalizeSegments(result[0], result[1], tl);
}
function getDrawDirection(pathArray) {
  return getPathArea(pathArray) >= 0;
}

function getCubicSegArea(x0, y0, x1, y1, x2, y2, x3, y3) {
  // https://stackoverflow.com/a/15845996
  return 3 * ((y3 - y0) * (x1 + x2) - (x3 - x0) * (y1 + y2) + y1 * (x0 - x2) - x1 * (y0 - y2) + y3 * (x2 + x0 / 3) - x3 * (y2 + y0 / 3)) / 20;
}

function getPathArea(pathArray) {
  var x = 0;
  var y = 0;
  var mx = 0;
  var my = 0;
  var len = 0;
  return pathArray.map(function (seg) {
    var _a;

    switch (seg[0]) {
      case 'M':
      case 'Z':
        mx = seg[0] === 'M' ? seg[1] : mx;
        my = seg[0] === 'M' ? seg[2] : my;
        x = mx;
        y = my;
        return 0;

      default:
        // @ts-ignore
        len = getCubicSegArea.apply(0, [x, y].concat(seg.slice(1)));
        _a = __read(seg.slice(-2), 2), x = _a[0], y = _a[1];
        return len;
    }
  }).reduce(function (a, b) {
    return a + b;
  }, 0);
} // reverse CURVE based pathArray segments only

function reverseCurve(pathArray) {
  var rotatedCurve = pathArray.slice(1).map(function (x, i, curveOnly) {
    // @ts-ignore
    return !i ? pathArray[0].slice(1).concat(x.slice(1)) : curveOnly[i - 1].slice(-2).concat(x.slice(1));
  }) // @ts-ignore
  .map(function (x) {
    return x.map(function (y, i) {
      return x[x.length - i - 2 * (1 - i % 2)];
    });
  }).reverse(); // @ts-ignore

  return [['M'].concat(rotatedCurve[0].slice(0, 2))].concat(rotatedCurve.map(function (x) {
    return ['C'].concat(x.slice(2));
  }));
}
function clonePath(pathArray) {
  // @ts-ignore
  return pathArray.map(function (x) {
    if (Array.isArray(x)) {
      // @ts-ignore
      return clonePath(x);
    }

    return !Number.isNaN(+x) ? +x : x;
  });
}

function getRotations(a) {
  var segCount = a.length;
  var pointCount = segCount - 1;
  return a.map(function (f, idx) {
    return a.map(function (p, i) {
      var oldSegIdx = idx + i;
      var seg;

      if (i === 0 || a[oldSegIdx] && a[oldSegIdx][0] === 'M') {
        seg = a[oldSegIdx]; // @ts-ignore

        return ['M'].concat(seg.slice(-2));
      }

      if (oldSegIdx >= segCount) oldSegIdx -= pointCount;
      return a[oldSegIdx];
    });
  });
}

function distanceSquareRoot(a, b) {
  return Math.sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]));
}

function getRotatedCurve(a, b) {
  var segCount = a.length - 1;
  var lineLengths = [];
  var computedIndex = 0;
  var sumLensSqrd = 0;
  var rotations = getRotations(a);
  rotations.forEach(function (r, i) {
    a.slice(1).forEach(function (s, j) {
      // @ts-ignore
      sumLensSqrd += distanceSquareRoot(a[(i + j) % segCount].slice(-2), b[j % segCount].slice(-2));
    });
    lineLengths[i] = sumLensSqrd;
    sumLensSqrd = 0;
  });
  computedIndex = lineLengths.indexOf(Math.min.apply(null, lineLengths));
  return rotations[computedIndex];
}

export { clonePath, equalizeSegments, getDrawDirection, getPathArea, getRotatedCurve, reverseCurve };
