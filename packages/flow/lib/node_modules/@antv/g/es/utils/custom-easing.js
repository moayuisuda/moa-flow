import { __read } from '../../../../tslib/tslib.es6.js';
import { bezier } from './bezier-easing.js';

var convertToDash = function convertToDash(str) {
  str = str.replace(/([A-Z])/g, function (letter) {
    return "-".concat(letter.toLowerCase());
  }); // Remove first dash

  return str.charAt(0) === '-' ? str.substr(1) : str;
};
var limit = function limit(value, min, max) {
  return Math.min(Math.max(value, min), max);
};
/**
  Easing Functions from anime.js, they are tried and true, so, its better to use them instead of other alternatives
*/

var Quad = function Quad(t) {
  return Math.pow(t, 2);
};
var Cubic = function Cubic(t) {
  return Math.pow(t, 3);
};
var Quart = function Quart(t) {
  return Math.pow(t, 4);
};
var Quint = function Quint(t) {
  return Math.pow(t, 5);
};
var Expo = function Expo(t) {
  return Math.pow(t, 6);
};
var Sine = function Sine(t) {
  return 1 - Math.cos(t * Math.PI / 2);
};
var Circ = function Circ(t) {
  return 1 - Math.sqrt(1 - t * t);
};
var Back = function Back(t) {
  return t * t * (3 * t - 2);
};
var Bounce = function Bounce(t) {
  var pow2,
      b = 4;

  while (t < ((pow2 = Math.pow(2, --b)) - 1) / 11) {}

  return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - t, 2);
};
var Elastic = function Elastic(t, params) {
  if (params === void 0) {
    params = [];
  }

  var _a = __read(params, 2),
      _b = _a[0],
      amplitude = _b === void 0 ? 1 : _b,
      _c = _a[1],
      period = _c === void 0 ? 0.5 : _c;

  var a = limit(Number(amplitude), 1, 10);
  var p = limit(Number(period), 0.1, 2);
  if (t === 0 || t === 1) return t;
  return -a * Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - p / (Math.PI * 2) * Math.asin(1 / a)) * (Math.PI * 2) / p);
};
var Spring = function Spring(t, params, duration) {
  if (params === void 0) {
    params = [];
  }

  var _a = __read(params, 4),
      _b = _a[0],
      mass = _b === void 0 ? 1 : _b,
      _c = _a[1],
      stiffness = _c === void 0 ? 100 : _c,
      _d = _a[2],
      damping = _d === void 0 ? 10 : _d,
      _e = _a[3],
      velocity = _e === void 0 ? 0 : _e;

  mass = limit(mass, 0.1, 1000);
  stiffness = limit(stiffness, 0.1, 1000);
  damping = limit(damping, 0.1, 1000);
  velocity = limit(velocity, 0.1, 1000);
  var w0 = Math.sqrt(stiffness / mass);
  var zeta = damping / (2 * Math.sqrt(stiffness * mass));
  var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
  var a = 1;
  var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;
  var progress = duration ? duration * t / 1000 : t;

  if (zeta < 1) {
    progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));
  } else {
    progress = (a + b * progress) * Math.exp(-progress * w0);
  }

  if (t === 0 || t === 1) return t;
  return 1 - progress;
};
/**
 * The spring easing function will only look smooth at certain durations, with certain parameters.
 * This functions returns the optimal duration to create a smooth springy animation based on physics
 *
 * Note: it can also be used to determine the optimal duration of other types of easing function, but be careful of 'in-'
 * easing functions, because of the nature of the function it can sometimes create an infinite loop, I suggest only using
 * `getEasingDuration` for `spring`, specifically 'out-spring' and 'spring'
 */
// export const getEasingDuration = (easing: string | TypeEasingFunction = 'spring') => {
//   if (EasingDurationCache.has(easing)) return EasingDurationCache.get(easing);
//   // eslint-disable-next-line @typescript-eslint/no-use-before-define
//   const easingFunction = typeof easing == 'function' ? easing : getEasingFunction(easing as string);
//   const params = typeof easing == 'function' ? [] : parseEasingParameters(easing);
//   const frame = 1 / 6;
//   let elapsed = 0;
//   let rest = 0;
//   let count = 0;
//   while (++count < INTINITE_LOOP_LIMIT) {
//     elapsed += frame;
//     if (easingFunction(elapsed, params, undefined) === 1) {
//       rest++;
//       if (rest >= 16) break;
//     } else {
//       rest = 0;
//     }
//   }
//   const duration = elapsed * frame * 1000;
//   EasingDurationCache.set(easing, duration);
//   return duration;
// };

/**
  These Easing Functions are based off of the Sozi Project's easing functions
  https://github.com/sozi-projects/Sozi/blob/d72e44ebd580dc7579d1e177406ad41e632f961d/src/js/player/Timing.js
*/

var Steps = function Steps(t, params) {
  if (params === void 0) {
    params = [];
  }

  var _a = __read(params, 2),
      _b = _a[0],
      steps = _b === void 0 ? 10 : _b,
      type = _a[1];

  var trunc = type == 'start' ? Math.ceil : Math.floor;
  return trunc(limit(t, 0, 1) * steps) / steps;
}; // @ts-ignore

var Bezier = function Bezier(t, params) {
  if (params === void 0) {
    params = [];
  }

  var _a = __read(params, 4),
      mX1 = _a[0],
      mY1 = _a[1],
      mX2 = _a[2],
      mY2 = _a[3];

  return bezier(mX1, mY1, mX2, mY2)(t);
};
/** The default `ease-in` easing function */

var easein = bezier(0.42, 0.0, 1.0, 1.0);
/** Converts easing functions to their `out`counter parts */

var EaseOut = function EaseOut(ease) {
  return function (t, params, duration) {
    if (params === void 0) {
      params = [];
    }

    return 1 - ease(1 - t, params, duration);
  };
};
/** Converts easing functions to their `in-out` counter parts */

var EaseInOut = function EaseInOut(ease) {
  return function (t, params, duration) {
    if (params === void 0) {
      params = [];
    }

    return t < 0.5 ? ease(t * 2, params, duration) / 2 : 1 - ease(t * -2 + 2, params, duration) / 2;
  };
};
/** Converts easing functions to their `out-in` counter parts */

var EaseOutIn = function EaseOutIn(ease) {
  return function (t, params, duration) {
    if (params === void 0) {
      params = [];
    }

    return t < 0.5 ? (1 - ease(1 - t * 2, params, duration)) / 2 : (ease(t * 2 - 1, params, duration) + 1) / 2;
  };
};
/**
 * The default list of easing functions, do note this is different from {@link EASING}
 */

var EasingFunctions = {
  steps: Steps,
  'step-start': function stepStart(t) {
    return Steps(t, [1, 'start']);
  },
  'step-end': function stepEnd(t) {
    return Steps(t, [1, 'end']);
  },
  linear: function linear(t) {
    return t;
  },
  'cubic-bezier': Bezier,
  ease: function ease(t) {
    return Bezier(t, [0.25, 0.1, 0.25, 1.0]);
  },
  in: easein,
  out: EaseOut(easein),
  'in-out': EaseInOut(easein),
  'out-in': EaseOutIn(easein),
  'in-quad': Quad,
  'out-quad': EaseOut(Quad),
  'in-out-quad': EaseInOut(Quad),
  'out-in-quad': EaseOutIn(Quad),
  'in-cubic': Cubic,
  'out-cubic': EaseOut(Cubic),
  'in-out-cubic': EaseInOut(Cubic),
  'out-in-cubic': EaseOutIn(Cubic),
  'in-quart': Quart,
  'out-quart': EaseOut(Quart),
  'in-out-quart': EaseInOut(Quart),
  'out-in-quart': EaseOutIn(Quart),
  'in-quint': Quint,
  'out-quint': EaseOut(Quint),
  'in-out-quint': EaseInOut(Quint),
  'out-in-quint': EaseOutIn(Quint),
  'in-expo': Expo,
  'out-expo': EaseOut(Expo),
  'in-out-expo': EaseInOut(Expo),
  'out-in-expo': EaseOutIn(Expo),
  'in-sine': Sine,
  'out-sine': EaseOut(Sine),
  'in-out-sine': EaseInOut(Sine),
  'out-in-sine': EaseOutIn(Sine),
  'in-circ': Circ,
  'out-circ': EaseOut(Circ),
  'in-out-circ': EaseInOut(Circ),
  'out-in-circ': EaseOutIn(Circ),
  'in-back': Back,
  'out-back': EaseOut(Back),
  'in-out-back': EaseInOut(Back),
  'out-in-back': EaseOutIn(Back),
  'in-bounce': Bounce,
  'out-bounce': EaseOut(Bounce),
  'in-out-bounce': EaseInOut(Bounce),
  'out-in-bounce': EaseOutIn(Bounce),
  'in-elastic': Elastic,
  'out-elastic': EaseOut(Elastic),
  'in-out-elastic': EaseInOut(Elastic),
  'out-in-elastic': EaseOutIn(Elastic),
  spring: Spring,
  'spring-in': Spring,
  'spring-out': EaseOut(Spring),
  'spring-in-out': EaseInOut(Spring),
  'spring-out-in': EaseOutIn(Spring)
};
/**
 * Convert string easing to their proper form
 */

var complexEasingSyntax = function complexEasingSyntax(ease) {
  return convertToDash(ease).replace(/^ease-/, '') // Remove the "ease-" keyword
  .replace(/(\(|\s).+/, '') // Remove the function brackets and parameters
  .toLowerCase().trim();
};
/** Re-maps a number from one range to another. Numbers outside the range are not clamped to 0 and 1, because out-of-range values are often intentional and useful. */

var getEasingFunction = function getEasingFunction(ease) {
  return EasingFunctions[complexEasingSyntax(ease)] || EasingFunctions.linear;
}; // /**
//  * Allows you to register new easing functions
//  */
// export const registerEasingFunction = (key: string, fn: TypeEasingFunction) => {
//   Object.assign(EasingFunctions, {
//     [key]: fn,
//   });
// };
// /**
//  * Allows you to register multiple new easing functions
//  */
// export const registerEasingFunctions = (...obj: typeof EasingFunctions[]) => {
//   Object.assign(EasingFunctions, ...obj);
// };

export { Back, Bezier, Bounce, Circ, Cubic, EaseInOut, EaseOut, EaseOutIn, EasingFunctions, Elastic, Expo, Quad, Quart, Quint, Sine, Spring, Steps, complexEasingSyntax, convertToDash, easein, getEasingFunction, limit };
