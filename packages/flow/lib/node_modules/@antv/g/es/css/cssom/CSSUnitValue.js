import { __extends } from '../../../../../tslib/tslib.es6.js';
import { DCHECK } from '../../utils/assert.js';
import '../../../../../inversify/lib/inversify.js';
import '../../../../../mana-syringe/es/core.js';
import '../../../../../mana-syringe/es/inversify/index.js';
import '../../../../../mana-syringe/es/container.js';
import '../../../../../mana-syringe/es/contribution/contribution-protocol.js';
import '../../../../../mana-syringe/es/register.js';
import '../../../../../mana-syringe/es/contribution/index.js';
import { UnitType } from './types.js';
import './CSSColorValue.js';
import './CSSKeywordValue.js';
import './CSSMathOperator.js';
import { CSSMathInvert } from './CSSMathInvert.js';
import './CSSMathMax.js';
import './CSSMathMin.js';
import './CSSMathNegate.js';
import './CSSMathProduct.js';
import './CSSMathSum.js';
import './CSSMathValue.js';
import './CSSMathVariadic.js';
import { CSSNumericValue } from './CSSNumericValue.js';
import { CSSNumericValueType } from './CSSNumericValueType.js';
import './CSSRGB.js';
import './CSSGradientValue.js';
import { CSSStyleValue, CSSStyleValueType } from './CSSStyleValue.js';
import './CSSTransformValue.js';
import './CSSTranslate.js';
import '../parser/dimension.js';
import '../../types.js';
import '../../shapes/Rectangle.js';
import '../parser/filter.js';
import '../parser/transform.js';
import '../properties/CSSPropertyLengthOrPercentage.js';
import '../properties/CSSPropertyLocalPosition.js';
import '../properties/CSSPropertyOpacity.js';
import '../properties/CSSPropertyColor.js';
import '../properties/CSSPropertyFilter.js';
import '../properties/CSSPropertyLineDash.js';
import '../properties/CSSPropertyShadowBlur.js';
import '../properties/CSSPropertyOffsetPath.js';
import '../properties/CSSPropertyOffsetDistance.js';
import '../properties/CSSPropertyAnchor.js';
import '../properties/CSSPropertyZIndex.js';
import '../properties/CSSPropertyTransform.js';
import '../properties/CSSPropertyTransformOrigin.js';
import '../properties/CSSPropertyPath.js';
import '../properties/CSSPropertyPoints.js';
import '../properties/CSSPropertyClipPath.js';
import '../properties/CSSPropertyText.js';
import '../properties/CSSPropertyTextTransform.js';
import '../StyleValueRegistry.js';
import '../LayoutRegistry.js';
import '../../utils/custom-easing.js';

/**
 * The CSSUnitValue interface of the CSS_Object_Model represents values that contain a single unit type.
 * For example, "42px" would be represented by a CSSNumericValue.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/CSSUnitValue
 */
/**
 * Represents numeric values that can be expressed as a single number plus a
 * unit (or a naked number or percentage).
 * @see https://drafts.css-houdini.org/css-typed-om/#cssunitvalue
 */

var CSSUnitValue =
/** @class */
function (_super) {
  __extends(CSSUnitValue, _super);

  function CSSUnitValue(value, unitOrName) {
    if (unitOrName === void 0) {
      unitOrName = UnitType.kNumber;
    }

    var _this = this;

    var unit;

    if (typeof unitOrName === 'string') {
      unit = CSSUnitValue.unitFromName(unitOrName);
    } else {
      unit = unitOrName;
    }

    DCHECK(CSSUnitValue.isValidUnit(unit));
    _this = _super.call(this, new CSSNumericValueType(unit)) || this;
    _this.unit = unit;
    _this.value = value;
    return _this;
  } // static fromCSSValue(value: CSSNumericLiteralValue) {
  //   let unit = value.type;
  //   if (unit === UnitType.kInteger) unit = UnitType.kNumber;
  //   if (!this.isValidUnit(unit)) return null;
  //   return new CSSUnitValue(value.getDoubleValue(), unit);
  // }


  CSSUnitValue.toCanonicalUnit = function (unit) {
    return this.canonicalUnitTypeForCategory(this.unitTypeToUnitCategory(unit));
  };

  CSSUnitValue.toCanonicalUnitIfPossible = function (unit) {
    var canonical_unit = this.toCanonicalUnit(unit);
    if (canonical_unit === UnitType.kUnknown) return unit;
    return canonical_unit;
  };

  CSSUnitValue.formatInfinityOrNaN = function (number, suffix) {
    if (suffix === void 0) {
      suffix = '';
    }

    var result = '';

    if (!Number.isFinite(number)) {
      if (number > 0) result = 'infinity';else result = '-infinity';
    } else {
      DCHECK(Number.isNaN(number));
      result = 'NaN';
    }

    return result += suffix;
  };

  CSSUnitValue.formatNumber = function (number, suffix) {
    if (suffix === void 0) {
      suffix = '';
    }

    return number + suffix;
  };

  CSSUnitValue.prototype.clone = function () {
    return new CSSUnitValue(this.value, this.unit);
  };

  CSSUnitValue.prototype.convertTo = function (target_unit) {
    if (this.unit === target_unit) {
      return new CSSUnitValue(this.value, this.unit);
    } // Instead of defining the scale factors for every unit to every other unit,
    // we simply convert to the canonical unit and back since we already have
    // the scale factors for canonical units.


    var canonical_unit = CSSUnitValue.toCanonicalUnit(this.unit);

    if (canonical_unit !== CSSUnitValue.toCanonicalUnit(target_unit) || canonical_unit === UnitType.kUnknown) {
      return null;
    }

    var scale_factor = CSSStyleValue.conversionToCanonicalUnitsScaleFactor(this.unit) / CSSStyleValue.conversionToCanonicalUnitsScaleFactor(target_unit);
    return new CSSUnitValue(this.value * scale_factor, target_unit);
  };

  CSSUnitValue.prototype.equals = function (other) {
    var other_unit_value = other;
    return this.value === other_unit_value.value && this.unit === other_unit_value.unit;
  };

  CSSUnitValue.prototype.getType = function () {
    return CSSStyleValueType.kUnitType;
  }; // toCSSValue() {
  //   return new CSSNumericLiteralValue(this.value, this.unit);
  // }
  // // const CSSPrimitiveValue* ToCSSValueWithProperty(CSSPropertyID) const final;
  // toCalcExpressionNode() {
  //   return CSSMathExpressionNumericLiteral.create(
  //     new CSSNumericLiteralValue(this.value, this.unit),
  //   );
  // }


  CSSUnitValue.prototype.sumValue = function () {
    var sum = [];
    var unit_map = {};

    if (this.unit !== UnitType.kNumber) {
      unit_map[CSSUnitValue.toCanonicalUnitIfPossible(this.unit)] = 1;
    }

    sum.push({
      value: this.value * CSSStyleValue.conversionToCanonicalUnitsScaleFactor(this.unit),
      units: unit_map
    });
    return sum;
  };

  CSSUnitValue.prototype.negate = function () {
    return new CSSUnitValue(-this.value, this.unit);
  };

  CSSUnitValue.prototype.invert = function () {
    if (this.unit === UnitType.kNumber) {
      if (this.value === 0) return null;
      return new CSSUnitValue(1.0 / this.value, this.unit);
    }

    return CSSMathInvert.create(this);
  };

  CSSUnitValue.prototype.buildCSSText = function (n, p, result) {
    var text;

    switch (this.unit) {
      case UnitType.kUnknown:
        // FIXME
        break;

      case UnitType.kInteger:
        text = Number(this.value).toFixed(0);
        break;

      case UnitType.kNumber:
      case UnitType.kPercentage:
      case UnitType.kEms:
      case UnitType.kQuirkyEms:
      case UnitType.kExs:
      case UnitType.kRems:
      case UnitType.kChs:
      case UnitType.kPixels:
      case UnitType.kCentimeters:
      case UnitType.kDotsPerPixel:
      case UnitType.kDotsPerInch:
      case UnitType.kDotsPerCentimeter:
      case UnitType.kMillimeters:
      case UnitType.kQuarterMillimeters:
      case UnitType.kInches:
      case UnitType.kPoints:
      case UnitType.kPicas:
      case UnitType.kUserUnits:
      case UnitType.kDegrees:
      case UnitType.kRadians:
      case UnitType.kGradians:
      case UnitType.kMilliseconds:
      case UnitType.kSeconds:
      case UnitType.kHertz:
      case UnitType.kKilohertz:
      case UnitType.kTurns:
      case UnitType.kFraction:
      case UnitType.kViewportWidth:
      case UnitType.kViewportHeight:
      case UnitType.kViewportInlineSize:
      case UnitType.kViewportBlockSize:
      case UnitType.kViewportMin:
      case UnitType.kViewportMax:
      case UnitType.kSmallViewportWidth:
      case UnitType.kSmallViewportHeight:
      case UnitType.kSmallViewportInlineSize:
      case UnitType.kSmallViewportBlockSize:
      case UnitType.kSmallViewportMin:
      case UnitType.kSmallViewportMax:
      case UnitType.kLargeViewportWidth:
      case UnitType.kLargeViewportHeight:
      case UnitType.kLargeViewportInlineSize:
      case UnitType.kLargeViewportBlockSize:
      case UnitType.kLargeViewportMin:
      case UnitType.kLargeViewportMax:
      case UnitType.kDynamicViewportWidth:
      case UnitType.kDynamicViewportHeight:
      case UnitType.kDynamicViewportInlineSize:
      case UnitType.kDynamicViewportBlockSize:
      case UnitType.kDynamicViewportMin:
      case UnitType.kDynamicViewportMax:
      case UnitType.kContainerWidth:
      case UnitType.kContainerHeight:
      case UnitType.kContainerInlineSize:
      case UnitType.kContainerBlockSize:
      case UnitType.kContainerMin:
      case UnitType.kContainerMax:
        {
          var kMinInteger = -999999;
          var kMaxInteger = 999999;
          var value = this.value;
          var unit = CSSUnitValue.unitTypeToString(this.unit);

          if (value < kMinInteger || value > kMaxInteger) {
            var unit_1 = CSSUnitValue.unitTypeToString(this.unit);

            if (!Number.isFinite(value) || Number.isNaN(value)) {
              text = CSSUnitValue.formatInfinityOrNaN(value, unit_1);
            } else {
              text = CSSUnitValue.formatNumber(value, unit_1);
            }
          } else {
            text = "".concat(value).concat(unit);
          }
        }
    }

    result += text;
    return result;
  };

  return CSSUnitValue;
}(CSSNumericValue);

export { CSSUnitValue };
