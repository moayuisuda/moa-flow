import { __extends } from '../../../../../tslib/tslib.es6.js';
import { CSSMathValue } from './CSSMathValue.js';
import { ParenLess, Nested } from './types.js';
import './CSSColorValue.js';
import './CSSKeywordValue.js';
import './CSSMathOperator.js';
import './CSSMathMax.js';
import './CSSMathMin.js';
import './CSSMathNegate.js';
import './CSSMathProduct.js';
import './CSSMathSum.js';
import './CSSMathVariadic.js';
import './CSSNumericValue.js';
import { CSSNumericValueType } from './CSSNumericValueType.js';
import './CSSRGB.js';
import './CSSGradientValue.js';
import { CSSStyleValueType } from './CSSStyleValue.js';
import './CSSTransformValue.js';
import './CSSTranslate.js';
import './CSSUnitValue.js';

var CSSMathInvert =
/** @class */
function (_super) {
  __extends(CSSMathInvert, _super);

  function CSSMathInvert(value, type) {
    var _this = _super.call(this, type) || this;

    _this.value = value;
    _this.operator = 'invert';
    return _this;
  }

  CSSMathInvert.create = function (value) {
    var type = CSSNumericValueType.negateExponents(value.type_);
    return new CSSMathInvert(value, type);
  };

  CSSMathInvert.prototype.clone = function () {
    return new CSSMathInvert(this.value, this.type_);
  };

  CSSMathInvert.prototype.getType = function () {
    return CSSStyleValueType.kInvertType;
  };

  CSSMathInvert.prototype.equals = function (other) {
    if (other.getType() !== CSSStyleValueType.kInvertType) {
      return false;
    } // We can safely cast here as we know 'other' has the same type as us.


    var other_invert = other;
    return this.value.equals(other_invert.value);
  };

  CSSMathInvert.prototype.sumValue = function () {
    var sum = this.value.sumValue();

    if (sum.length === 0 || sum.length !== 1 || sum[0].value === 0) {
      return null;
    }

    Object.keys(sum[0].units).forEach(function (key) {
      sum[0].units[key] *= -1;
    });
    sum[0].value = 1.0 / sum[0].value;
    return sum;
  }; // toCalcExpressionNode(): CSSMathExpressionNode {
  //   const right_side = this.value.toCalcExpressionNode();
  //   if (!right_side) {
  //     return null;
  //   }
  //   // return CSSMathExpressionOperation::CreateArithmeticOperation(
  //   //   CSSMathExpressionNumericLiteral::Create(
  //   //       1, UnitType.kNumber),
  //   //   right_side, CSSMathOperator.kDivide);
  //   return null;
  // }


  CSSMathInvert.prototype.buildCSSText = function (nested, paren_less, result) {
    if (paren_less == ParenLess.kNo) {
      result += nested === Nested.kYes ? '(' : 'calc(';
    }

    result += '1 / ';
    result = this.value.buildCSSText(Nested.kYes, ParenLess.kNo, result);

    if (paren_less === ParenLess.kNo) {
      result += ')';
    }

    return result;
  };

  return CSSMathInvert;
}(CSSMathValue);

export { CSSMathInvert };
