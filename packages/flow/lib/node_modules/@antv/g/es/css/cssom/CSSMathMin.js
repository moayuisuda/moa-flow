import { __extends, __values } from '../../../../../tslib/tslib.es6.js';
import { typeCheck, CSSMathVariadic } from './CSSMathVariadic.js';
import { Nested, ParenLess } from './types.js';
import './CSSColorValue.js';
import './CSSKeywordValue.js';
import './CSSMathOperator.js';
import './CSSMathInvert.js';
import './CSSMathMax.js';
import './CSSMathNegate.js';
import './CSSMathProduct.js';
import './CSSMathSum.js';
import './CSSMathValue.js';
import './CSSNumericValue.js';
import { CSSNumericValueType } from './CSSNumericValueType.js';
import './CSSRGB.js';
import './CSSGradientValue.js';
import { CSSStyleValueType } from './CSSStyleValue.js';
import './CSSTransformValue.js';
import './CSSTranslate.js';
import './CSSUnitValue.js';

// @see https://drafts.css-houdini.org/css-typed-om/#cssmathsum

var CSSMathMin =
/** @class */
function (_super) {
  __extends(CSSMathMin, _super);

  function CSSMathMin() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.operator = 'min';
    return _this;
  }

  CSSMathMin.create = function (values) {
    var error = false;
    var final_type = typeCheck(values, CSSNumericValueType.add, error);
    return error ? null : new CSSMathMin(values, final_type);
  };

  CSSMathMin.prototype.clone = function () {
    return new CSSMathMin(this.values, this.type_);
  };

  CSSMathMin.prototype.getType = function () {
    return CSSStyleValueType.kMinType;
  };

  CSSMathMin.prototype.sumValue = function () {
    var e_1, _a;

    var cur_min = this.numericValues()[0].sumValue();

    if (!cur_min.length) {
      return null;
    }

    try {
      for (var _b = __values(this.numericValues()), _c = _b.next(); !_c.done; _c = _b.next()) {
        var value = _c.value;
        var child_sum = value.sumValue();

        if (!child_sum.length || JSON.stringify(child_sum[0].units) !== JSON.stringify(cur_min[0].units)) {
          return null;
        }

        if (child_sum[0].value < cur_min[0].value) {
          cur_min = child_sum;
        }
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_1) throw e_1.error;
      }
    }

    return cur_min;
  }; // toCalcExpressionNode() {
  //   const operands: CSSMathExpressionOperation[] = [];
  //   for (const value of this.numericValues()) {
  //     const operand = value.toCalcExpressionNode();
  //     if (!operand) {
  //       continue;
  //     }
  //     operands.push(operand as CSSMathExpressionOperation);
  //   }
  //   return CSSMathExpressionOperation.createComparisonFunction(operands, CSSMathOperator.kMin);
  // }


  CSSMathMin.prototype.buildCSSText = function (nested, paren_less, result) {
    var e_2, _a;

    result += 'min(';
    var first_iteration = true;

    try {
      for (var _b = __values(this.numericValues()), _c = _b.next(); !_c.done; _c = _b.next()) {
        var value = _c.value;
        if (!first_iteration) result += ', ';
        first_iteration = false;
        result = value.buildCSSText(Nested.kYes, ParenLess.kYes, result);
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_2) throw e_2.error;
      }
    }

    result += ')';
    return result;
  };

  return CSSMathMin;
}(CSSMathVariadic);

export { CSSMathMin };
