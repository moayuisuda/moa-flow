import { __read, __spreadArray } from '../../../../../tslib/tslib.es6.js';
import pathToCurve from '../../../../path-util/esm/path-2-curve.js';
import pathToAbsolute from '../../../../path-util/esm/path-2-absolute.js';
import getSegments from '../../../../path-util/esm/path-2-segments.js';
import CubicUtil from '../../../../g-math/es/cubic.js';
import { equalizeSegments, getDrawDirection, reverseCurve, clonePath, getRotatedCurve } from '../../utils/path.js';
import { Rectangle } from '../../shapes/Rectangle.js';

function parsePath(path) {
  var absolutePath = pathToAbsolute(path);
  var hasArc = hasArcOrBezier(absolutePath);
  var clonedAbsolutePath = absolutePath.slice();

  var _a = extractPolygons(clonedAbsolutePath),
      polygons = _a.polygons,
      polylines = _a.polylines; // convert to curves to do morphing & picking later
  // @see http://thednp.github.io/kute.js/svgCubicMorph.html


  var _b = __read(pathToCurve(clonedAbsolutePath, true), 2),
      curve = _b[0],
      zCommandIndexes = _b[1];

  var segments = getSegments(clonedAbsolutePath);

  var _c = calcLength(curve),
      totalLength = _c.totalLength,
      curveSegments = _c.curveSegments;

  return {
    absolutePath: absolutePath,
    hasArc: hasArc,
    segments: segments,
    polygons: polygons,
    polylines: polylines,
    curve: curve,
    totalLength: totalLength,
    curveSegments: curveSegments,
    zCommandIndexes: zCommandIndexes,
    rect: getPathBBox(curve)
  };
}

function hasArcOrBezier(path) {
  var hasArc = false;
  var count = path.length;

  for (var i = 0; i < count; i++) {
    var params = path[i];
    var cmd = params[0];

    if (cmd === 'C' || cmd === 'A' || cmd === 'Q') {
      hasArc = true;
      break;
    }
  }

  return hasArc;
}

function extractPolygons(pathArray) {
  var polygons = [];
  var polylines = [];
  var points = []; // 防止第一个命令不是 'M'

  for (var i = 0; i < pathArray.length; i++) {
    var params = pathArray[i];
    var cmd = params[0];

    if (cmd === 'M') {
      // 遇到 'M' 判定是否是新数组，新数组中没有点
      if (points.length) {
        // 如果存在点，则说明没有遇到 'Z'，开始了一个新的多边形
        polylines.push(points);
        points = []; // 创建新的点
      }

      points.push([params[1], params[2]]);
    } else if (cmd === 'Z') {
      if (points.length) {
        // 存在点
        polygons.push(points);
        points = []; // 开始新的点集合
      } // 如果不存在点，同时 'Z'，则说明是错误，不处理

    } else {
      points.push([params[1], params[2]]);
    }
  } // 说明 points 未放入 polygons 或者 polyline
  // 仅当只有一个 M，没有 Z 时会发生这种情况


  if (points.length > 0) {
    polylines.push(points);
  }

  return {
    polygons: polygons,
    polylines: polylines
  };
}

function calcLength(curve) {
  var totalLength = 0;
  var tempLength = 0; // 每段 curve 对应起止点的长度比例列表，形如: [[0, 0.25], [0.25, 0.6]. [0.6, 0.9], [0.9, 1]]

  var curveSegments = [];
  var segmentT;
  var segmentL;
  var segmentN;
  var l;

  if (!curve) {
    return {
      curveSegments: [],
      totalLength: totalLength
    };
  }

  curve.forEach(function (segment, i) {
    segmentN = curve[i + 1];
    l = segment.length;

    if (segmentN) {
      totalLength += CubicUtil.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]) || 0;
    }
  });

  if (totalLength === 0) {
    return {
      curveSegments: [],
      totalLength: totalLength
    };
  }

  curve.forEach(function (segment, i) {
    segmentN = curve[i + 1];
    l = segment.length;

    if (segmentN) {
      segmentT = [];
      segmentT[0] = tempLength / totalLength;
      segmentL = CubicUtil.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]); // 当 path 不连续时，segmentL 可能为空，为空时需要作为 0 处理

      tempLength += segmentL || 0;
      segmentT[1] = tempLength / totalLength;
      curveSegments.push(segmentT);
    }
  });
  return {
    curveSegments: curveSegments,
    totalLength: totalLength
  };
}

function getPathBBox(segments) {
  var x = 0;
  var y = 0;
  var X = [];
  var Y = [];
  segments.forEach(function (segment) {
    var _a = __read(segment.slice(-2), 2),
        s1 = _a[0],
        s2 = _a[1];

    if (segment[0] === 'M') {
      x = s1;
      y = s2;
      X.push(s1);
      Y.push(s2);
    } else if (segment[0] === 'C') {
      // @ts-ignore
      var dim = CubicUtil.box.apply(CubicUtil, __spreadArray([], __read([x, y].concat(segment.slice(1))), false));
      X = X.concat(dim.x, dim.x + dim.width);
      Y = Y.concat(dim.y, dim.y + dim.height);
      x = s1;
      y = s2;
    }
  });
  var xTop = Math.min.apply(0, X);
  var yTop = Math.min.apply(0, Y);
  var xBot = Math.max.apply(0, X);
  var yBot = Math.max.apply(0, Y);
  var width = xBot - xTop;
  var height = yBot - yTop;
  return new Rectangle(xTop, yTop, width, height);
}

function mergePaths(left, right, object) {
  var curve1 = left.curve;
  var curve2 = right.curve;
  var curves = [curve1, curve2];

  if (curve1.length !== curve2.length) {
    curves = equalizeSegments(curve1, curve2);
  }

  var curve0 = getDrawDirection(curves[0]) !== getDrawDirection(curves[1]) ? reverseCurve(curves[0]) : clonePath(curves[0]);
  return [curve0, getRotatedCurve(curves[1], curve0), function (pathArray) {
    // need converting to path string?
    return pathArray;
  }];
}

export { mergePaths, parsePath };
