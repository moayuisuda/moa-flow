import { __decorate } from '../../../../../tslib/tslib.es6.js';
import { singleton } from '../../../../../mana-syringe/es/decorator.js';
import '../../../../../mana-syringe/es/container.js';
import '../../../../../mana-syringe/es/core.js';
import '../../../../../mana-syringe/es/contribution/contribution-protocol.js';
import '../../../../../inversify/lib/inversify.js';
import '../../../../../mana-syringe/es/register.js';
import '../../../../../mana-syringe/es/contribution/index.js';
import { UnitType } from '../cssom/types.js';
import '../cssom/CSSColorValue.js';
import '../cssom/CSSKeywordValue.js';
import '../cssom/CSSMathOperator.js';
import '../cssom/CSSMathInvert.js';
import '../cssom/CSSMathMax.js';
import '../cssom/CSSMathMin.js';
import '../cssom/CSSMathNegate.js';
import '../cssom/CSSMathProduct.js';
import '../cssom/CSSMathSum.js';
import '../cssom/CSSMathValue.js';
import '../cssom/CSSMathVariadic.js';
import '../cssom/CSSNumericValue.js';
import '../cssom/CSSNumericValueType.js';
import '../cssom/CSSRGB.js';
import '../cssom/CSSGradientValue.js';
import '../cssom/CSSStyleValue.js';
import '../cssom/CSSTransformValue.js';
import '../cssom/CSSTranslate.js';
import { CSSUnitValue } from '../cssom/CSSUnitValue.js';
import { parseLengthOrPercentage, mergeDimensions } from '../parser/dimension.js';
import '../../types.js';
import '../../shapes/Rectangle.js';
import '../parser/filter.js';
import '../parser/transform.js';

/**
 * <length> & <percentage>
 */

var CSSPropertyLengthOrPercentage =
/** @class */
function () {
  function CSSPropertyLengthOrPercentage() {
    this.parser = parseLengthOrPercentage;
    this.mixer = mergeDimensions;
  }
  /**
   * according to parent's bounds
   *
   * @example
   * CSS.percent(50) -> CSS.px(0.5 * parent.width)
   */


  CSSPropertyLengthOrPercentage.prototype.calculator = function (name, oldParsed, computed, object, registry) {
    if (CSSUnitValue.isRelativeUnit(computed.unit)) {
      if (computed.unit === UnitType.kPercentage) {
        // try to resolve according to parent's geometry bounds
        // if (object.parentElement) {
        //   // registry.registerParentGeometryBoundsChangedHandler(object, name);
        //   return this.calculateUsedValueWithParentBounds(object, name);
        // } else {
        //   registry.addUnresolveProperty(object, name);
        //   // defer calculation after mounted
        //   // object.addEventListener(
        //   //   ElementEvent.MOUNTED,
        //   //   () => {
        //   //     registry.registerParentGeometryBoundsChangedHandler(object, name);
        //   //   },
        //   //   { once: true },
        //   // );
        // }
        return new CSSUnitValue(0, 'px');
      } else if (computed.unit === UnitType.kEms) {
        // TODO: handle ems
        return new CSSUnitValue(0, 'px');
      }
    } else {
      // remove listener if exists
      // registry.unregisterParentGeometryBoundsChangedHandler(object, name);
      // return absolute value
      return computed.clone();
    }
  };

  CSSPropertyLengthOrPercentage.prototype.nameToBoundsIndex = function (name) {
    if (name === 'x' || name === 'cx' || name === 'width') {
      return 0;
    } else if (name === 'y' || name === 'cy' || name === 'height') {
      return 1;
    }

    return 2;
  };

  CSSPropertyLengthOrPercentage.prototype.calculateUsedValueWithParentBounds = function (object, name) {
    var bounds = object.parentElement.getGeometryBounds();
    var computedValue = object.computedStyle[name].value;
    return new CSSUnitValue(bounds.halfExtents[this.nameToBoundsIndex(name)] * 2 * computedValue / 100, 'px');
  };

  CSSPropertyLengthOrPercentage = __decorate([singleton()], CSSPropertyLengthOrPercentage);
  return CSSPropertyLengthOrPercentage;
}();

export { CSSPropertyLengthOrPercentage };
