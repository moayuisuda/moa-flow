import { __spreadArray, __read } from '../../../../../tslib/tslib.es6.js';
import '../cssom/types.js';
import '../cssom/CSSColorValue.js';
import '../cssom/CSSKeywordValue.js';
import '../cssom/CSSMathOperator.js';
import '../cssom/CSSMathInvert.js';
import '../cssom/CSSMathMax.js';
import '../cssom/CSSMathMin.js';
import '../cssom/CSSMathNegate.js';
import '../cssom/CSSMathProduct.js';
import '../cssom/CSSMathSum.js';
import '../cssom/CSSMathValue.js';
import '../cssom/CSSMathVariadic.js';
import '../cssom/CSSNumericValue.js';
import '../cssom/CSSNumericValueType.js';
import { CSSRGB } from '../cssom/CSSRGB.js';
import { CSSGradientValue, GradientPatternType } from '../cssom/CSSGradientValue.js';
import '../cssom/CSSStyleValue.js';
import '../cssom/CSSTransformValue.js';
import '../cssom/CSSTranslate.js';
import '../cssom/CSSUnitValue.js';
import isString from '../../../../../lodash-es/isString.js';
import color from '../../../../../d3-color/src/color.js';
import clamp from '../../../../../lodash-es/clamp.js';

var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
/**
 * @see https://github.com/WebKit/WebKit/blob/main/Source/WebCore/css/parser/CSSParser.cpp#L97
 */

function parseColor(colorStr) {
  if (colorStr === void 0) {
    colorStr = '';
  }

  if (colorStr === 'transparent') {
    // transparent black
    return new CSSRGB(0, 0, 0, 0);
  } else if (colorStr === 'currentColor') {
    // @see https://github.com/adobe-webplatform/Snap.svg/issues/526
    colorStr = 'black';
  }

  var type = colorStr[0];

  if (colorStr[1] === '(' || colorStr[2] === '(') {
    if (type === 'l') {
      var parsedLineGradient = parseLineGradient(colorStr);

      if (parsedLineGradient) {
        return new CSSGradientValue(GradientPatternType.LinearGradient, parsedLineGradient);
      }
    } else if (type === 'r') {
      var parsedRadialGradient = parseRadialGradient(colorStr);

      if (parsedRadialGradient) {
        if (isString(parsedRadialGradient)) {
          colorStr = parsedRadialGradient;
        } else {
          return new CSSGradientValue(GradientPatternType.RadialGradient, parsedRadialGradient);
        }
      }
    } else if (type === 'p') {
      var pattern = parsePattern(colorStr);

      if (pattern) {
        return new CSSGradientValue(GradientPatternType.Pattern, pattern);
      }
    }
  } // constants


  var color$1 = color(colorStr);
  var rgba = [0, 0, 0, 0];

  if (color$1 !== null) {
    rgba[0] = color$1.r || 0;
    rgba[1] = color$1.g || 0;
    rgba[2] = color$1.b || 0;
    rgba[3] = color$1.opacity;
  }

  return new (CSSRGB.bind.apply(CSSRGB, __spreadArray([void 0], __read(rgba), false)))(); // return {
  //   type: PARSED_COLOR_TYPE.Constant,
  //   value: rgba,
  //   formatted:
  //     // rgba(255,255,255,0) -> [NaN, NaN, NaN, 0]
  //     // @see https://github.com/d3/d3-color/issues/52
  //     (color && `rgba(${color.r || 0},${color.g || 0},${color.b || 0},${color.opacity})`) ||
  //     'rgba(0,0,0,0)',
  // };
}
function mergeColors(left, right) {
  // only support constant value, exclude gradient & pattern
  if (!(left instanceof CSSRGB) || !(right instanceof CSSRGB)) {
    return;
  }

  return [[Number(left.r), Number(left.g), Number(left.b), Number(left.alpha)], [Number(right.r), Number(right.g), Number(right.b), Number(right.alpha)], function (color) {
    var rgba = color.slice();

    if (rgba[3]) {
      for (var i = 0; i < 3; i++) {
        rgba[i] = Math.round(clamp(rgba[i], 0, 255));
      }
    }

    rgba[3] = clamp(rgba[3], 0, 1);
    return "rgba(".concat(rgba.join(','), ")");
  }];
}

function parsePattern(patternStr) {
  var arr = regexPR.exec(patternStr);

  if (arr) {
    var repetition = arr[1];
    var src = arr[2];

    switch (repetition) {
      case 'a':
        repetition = 'repeat';
        break;

      case 'x':
        repetition = 'repeat-x';
        break;

      case 'y':
        repetition = 'repeat-y';
        break;

      case 'n':
        repetition = 'no-repeat';
        break;

      default:
        repetition = 'no-repeat';
    }

    return {
      src: src,
      repetition: repetition,
      hash: patternStr
    };
  }

  return null;
}

function parseLineGradient(gradientStr) {
  var _a;

  var arr = regexLG.exec(gradientStr);

  if (arr) {
    var angle = parseFloat(arr[1]) % 360 * (Math.PI / 180);
    var steps = ((_a = arr[2].match(regexColorStop)) === null || _a === void 0 ? void 0 : _a.map(function (stop) {
      return stop.split(':');
    })) || [];

    var _b = __read([1, 1], 2),
        maxX = _b[0],
        maxY = _b[1];

    var _c = __read([0, 0], 2),
        minX = _c[0],
        minY = _c[1];

    var start = void 0;
    var end = void 0;

    if (angle >= 0 && angle < 1 / 2 * Math.PI) {
      start = {
        x: minX,
        y: minY
      };
      end = {
        x: maxX,
        y: maxY
      };
    } else if (1 / 2 * Math.PI <= angle && angle < Math.PI) {
      start = {
        x: maxX,
        y: minY
      };
      end = {
        x: minX,
        y: maxY
      };
    } else if (Math.PI <= angle && angle < 3 / 2 * Math.PI) {
      start = {
        x: maxX,
        y: maxY
      };
      end = {
        x: minX,
        y: minY
      };
    } else {
      start = {
        x: minX,
        y: maxY
      };
      end = {
        x: maxX,
        y: minY
      };
    }

    var tanTheta = Math.tan(angle);
    var tanTheta2 = tanTheta * tanTheta;
    var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
    var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;
    return {
      x0: start.x,
      y0: start.y,
      x1: x,
      y1: y,
      steps: steps,
      hash: gradientStr
    };
  }

  return null;
}

function parseRadialGradient(gradientStr) {
  var _a;

  var arr = regexRG.exec(gradientStr);

  if (arr) {
    var fx = parseFloat(arr[1]);
    var fy = parseFloat(arr[2]);
    var fr = parseFloat(arr[3]);
    var steps = ((_a = arr[4].match(regexColorStop)) === null || _a === void 0 ? void 0 : _a.map(function (stop) {
      return stop.split(':');
    })) || []; // 环半径为0时，默认无渐变，取渐变序列的最后一个颜色

    if (fr === 0) {
      var colors = arr[4].match(regexColorStop);
      return colors[colors.length - 1].split(':')[1];
    }

    return {
      x0: fx,
      y0: fy,
      r0: 0,
      x1: 0.5,
      y1: 0.5,
      r1: fr,
      steps: steps,
      hash: gradientStr
    };
  }

  return null;
}

export { mergeColors, parseColor };
