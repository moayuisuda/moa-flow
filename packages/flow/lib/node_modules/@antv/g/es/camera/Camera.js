import { __extends } from '../../../../tslib/tslib.es6.js';
import '../../../../inversify/lib/inversify.js';
import { Syringe } from '../../../../mana-syringe/es/core.js';
import '../../../../mana-syringe/es/inversify/index.js';
import '../../../../mana-syringe/es/container.js';
import '../../../../mana-syringe/es/contribution/contribution-protocol.js';
import '../../../../mana-syringe/es/register.js';
import '../../../../mana-syringe/es/contribution/index.js';
import '../../../../eventemitter3/index.js';
import '../shapes/AABB.js';
import '../shapes/BoundingSphere.js';
import { Frustum } from '../shapes/Frustum.js';
import '../shapes/Plane.js';
import '../shapes/Ray.js';
import '../shapes/Point.js';
import '../shapes/Rectangle.js';
import { makePerspective, createVec3, getAngle } from '../utils/math.js';
import { parseEasingFunction } from '../utils/animation.js';
import isString from '../../../../lodash-es/isString.js';
import isNumber from '../../../../lodash-es/isNumber.js';
import { invert, create, fromTranslation, multiply, scale, ortho, rotateY, rotateX, lookAt, fromQuat, translate, clone as clone$1, identity, fromRotationTranslationScaleOrigin, copy as copy$1 } from '../../../../gl-matrix/esm/mat4.js';
import { fromValues, subtract, create as create$1, length, transformMat4, clone, add, scale as scale$1, copy, normalize, transformMat3, lerp, dist } from '../../../../gl-matrix/esm/vec3.js';
import { setAxisAngle, create as create$2, multiply as multiply$1 } from '../../../../gl-matrix/esm/quat.js';
import { transformMat4 as transformMat4$1, create as create$3 } from '../../../../gl-matrix/esm/vec4.js';
import { fromMat4, create as create$4 } from '../../../../gl-matrix/esm/mat3.js';
import { e as eventemitter3 } from '../../../../../_virtual/index4.js';

var DefaultCamera = Syringe.defineToken('DefaultCamera');
var CameraType;

(function (CameraType) {
  /**
   * Performs all the rotational operations with the focal point instead of the camera position.
   * This type of camera is useful in applications(like CAD) where 3D objects are being designed or explored.
   * Camera cannot orbits over the north & south poles.
   * @see http://voxelent.com/tutorial-cameras/
   *
   * In Three.js it's used in OrbitControls.
   * @see https://threejs.org/docs/#examples/zh/controls/OrbitControls
   */
  CameraType[CameraType["ORBITING"] = 0] = "ORBITING";
  /**
   * It's similar to the ORBITING camera, but it allows the camera to orbit over the north or south poles.
   *
   * In Three.js it's used in OrbitControls.
   * @see https://threejs.org/docs/#examples/en/controls/TrackballControls
   */

  CameraType[CameraType["EXPLORING"] = 1] = "EXPLORING";
  /**
   * Performs all the rotational operations with the camera position.
   * It's useful in first person shooting games.
   * Camera cannot orbits over the north & south poles.
   *
   * In Three.js it's used in FirstPersonControls.
   * @see https://threejs.org/docs/#examples/en/controls/FirstPersonControls
   */

  CameraType[CameraType["TRACKING"] = 2] = "TRACKING";
})(CameraType || (CameraType = {}));
/**
 * CameraType must be TRACKING
 */


var CameraTrackingMode;

(function (CameraTrackingMode) {
  CameraTrackingMode[CameraTrackingMode["DEFAULT"] = 0] = "DEFAULT";
  CameraTrackingMode[CameraTrackingMode["ROTATIONAL"] = 1] = "ROTATIONAL";
  CameraTrackingMode[CameraTrackingMode["TRANSLATIONAL"] = 2] = "TRANSLATIONAL";
  CameraTrackingMode[CameraTrackingMode["CINEMATIC"] = 3] = "CINEMATIC";
})(CameraTrackingMode || (CameraTrackingMode = {}));

var CameraProjectionMode;

(function (CameraProjectionMode) {
  CameraProjectionMode[CameraProjectionMode["ORTHOGRAPHIC"] = 0] = "ORTHOGRAPHIC";
  CameraProjectionMode[CameraProjectionMode["PERSPECTIVE"] = 1] = "PERSPECTIVE";
})(CameraProjectionMode || (CameraProjectionMode = {}));

var CameraEvent = {
  UPDATED: 'updated'
};
var DEG_2_RAD = Math.PI / 180;
var RAD_2_DEG = 180 / Math.PI;
var MIN_DISTANCE = 0.0002;
/**
 * 参考「WebGL Insights - 23.Designing Cameras for WebGL Applications」，基于 Responsible Camera 思路设计
 * @see https://github.com/d13g0/nucleo.js/blob/master/source/camera/Camera.js
 *
 * 保存相机参数，定义相机动作：
 * 1. dolly 沿 n 轴移动
 * 2. pan 沿 u v 轴移动
 * 3. rotate 以方位角旋转
 * 4. 移动到 Landmark，具有平滑的动画效果，其间禁止其他用户交互
 */

var Camera =
/** @class */
function (_super) {
  __extends(Camera, _super);

  function Camera(type, trackingMode) {
    if (type === void 0) {
      type = CameraType.EXPLORING;
    }

    if (trackingMode === void 0) {
      trackingMode = CameraTrackingMode.DEFAULT;
    }

    var _this = _super.call(this) || this;
    /**
     * 相机矩阵
     */


    _this.matrix = create();
    /**
     * u 轴
     * @see http://learnwebgl.brown37.net/07_cameras/camera_introduction.html#a-camera-definition
     */

    _this.right = fromValues(1, 0, 0);
    /**
     * v 轴 +Y is down
     */

    _this.up = fromValues(0, 1, 0);
    /**
     * n 轴 +Z is inside
     */

    _this.forward = fromValues(0, 0, 1);
    /**
     * 相机位置
     */

    _this.position = fromValues(0, 0, 1);
    /**
     * 视点位置
     */

    _this.focalPoint = fromValues(0, 0, 0);
    /**
     * 视点到相机位置的向量
     * focalPoint - position
     */

    _this.distanceVector = fromValues(0, 0, -1);
    /**
     * 相机位置到视点距离
     * length(focalPoint - position)
     */

    _this.distance = 1;
    /**
     * @see https://en.wikipedia.org/wiki/Azimuth
     */

    _this.azimuth = 0;
    _this.elevation = 0;
    _this.roll = 0;
    _this.relAzimuth = 0;
    _this.relElevation = 0;
    _this.relRoll = 0;
    /**
     * 沿 n 轴移动时，保证移动速度从快到慢
     */

    _this.dollyingStep = 0;
    _this.maxDistance = Infinity;
    _this.minDistance = -Infinity;
    /**
     * zoom factor of the camera, default is 1
     * eg. https://threejs.org/docs/#api/en/cameras/OrthographicCamera.zoom
     */

    _this.zoom = 1;
    /**
     * invert the horizontal coordinate system HCS
     */

    _this.rotateWorld = false;
    /**
     * 投影矩阵参数
     */

    /**
     * field of view [0-360]
     * @see http://en.wikipedia.org/wiki/Angle_of_view
     */

    _this.fov = 30;
    _this.near = 0.1;
    _this.far = 1000;
    _this.aspect = 1;
    _this.projectionMatrix = create();
    _this.projectionMatrixInverse = create();
    _this.jitteredProjectionMatrix = undefined;
    _this.enableUpdate = true; // private following = undefined;

    _this.type = CameraType.EXPLORING;
    _this.trackingMode = CameraTrackingMode.DEFAULT;
    _this.projectionMode = CameraProjectionMode.PERSPECTIVE;
    /**
     * for culling use
     */

    _this.frustum = new Frustum();
    /**
     * switch between multiple landmarks
     */

    _this.landmarks = [];
    /**
     * ortho matrix for Canvas2D & SVG
     */

    _this.orthoMatrix = create();

    _this.setType(type, trackingMode);

    return _this;
  }

  Camera.prototype.isOrtho = function () {
    return this.projectionMode === CameraProjectionMode.ORTHOGRAPHIC;
  };

  Camera.prototype.getProjectionMode = function () {
    return this.projectionMode;
  };

  Camera.prototype.getPerspective = function () {
    // account for TAA
    return this.jitteredProjectionMatrix || this.projectionMatrix;
  };

  Camera.prototype.getPerspectiveInverse = function () {
    return this.projectionMatrixInverse;
  };

  Camera.prototype.getFrustum = function () {
    return this.frustum;
  };

  Camera.prototype.getPosition = function () {
    return this.position;
  };

  Camera.prototype.getFocalPoint = function () {
    return this.focalPoint;
  };

  Camera.prototype.getDollyingStep = function () {
    return this.dollyingStep;
  };

  Camera.prototype.getNear = function () {
    return this.near;
  };

  Camera.prototype.getFar = function () {
    return this.far;
  };

  Camera.prototype.getZoom = function () {
    return this.zoom;
  };

  Camera.prototype.getOrthoMatrix = function () {
    return this.orthoMatrix;
  };

  Camera.prototype.getView = function () {
    return this.view;
  };

  Camera.prototype.setEnableUpdate = function (enabled) {
    this.enableUpdate = enabled;
  };

  Camera.prototype.setType = function (type, trackingMode) {
    this.type = type;

    if (this.type === CameraType.EXPLORING) {
      this.setWorldRotation(true);
    } else {
      this.setWorldRotation(false);
    }

    this._getAngles();

    if (this.type === CameraType.TRACKING && trackingMode !== undefined) {
      this.setTrackingMode(trackingMode);
    }

    return this;
  };

  Camera.prototype.setProjectionMode = function (projectionMode) {
    this.projectionMode = projectionMode;
    return this;
  };

  Camera.prototype.setTrackingMode = function (trackingMode) {
    if (this.type !== CameraType.TRACKING) {
      throw new Error('Impossible to set a tracking mode if the camera is not of tracking type');
    }

    this.trackingMode = trackingMode;
    return this;
  };
  /**
   * If flag is true, it reverses the azimuth and elevation angles.
   * Subsequent calls to rotate, setAzimuth, setElevation,
   * changeAzimuth or changeElevation will cause the inverted effect.
   * setRoll or changeRoll is not affected by this method.
   *
   * This inversion is useful when one wants to simulate that the world
   * is moving, instead of the camera.
   *
   * By default the camera angles are not reversed.
   * @param {Boolean} flag the boolean flag to reverse the angles.
   */


  Camera.prototype.setWorldRotation = function (flag) {
    this.rotateWorld = flag;

    this._getAngles();

    return this;
  };
  /**
   * 计算 MV 矩阵，为相机矩阵的逆矩阵
   */


  Camera.prototype.getViewTransform = function () {
    return invert(create(), this.matrix);
  };

  Camera.prototype.getWorldTransform = function () {
    return this.matrix;
  };

  Camera.prototype.jitterProjectionMatrix = function (x, y) {
    var translation = fromTranslation(create(), [x, y, 0]);
    this.jitteredProjectionMatrix = multiply(create(), translation, this.projectionMatrix);
  };

  Camera.prototype.clearJitterProjectionMatrix = function () {
    this.jitteredProjectionMatrix = undefined;
  };
  /**
   * 设置相机矩阵
   */


  Camera.prototype.setMatrix = function (matrix) {
    this.matrix = matrix;

    this._update();

    return this;
  };

  Camera.prototype.setFov = function (fov) {
    this.setPerspective(this.near, this.far, fov, this.aspect);
    return this;
  };

  Camera.prototype.setAspect = function (aspect) {
    this.setPerspective(this.near, this.far, this.fov, aspect);
    return this;
  };

  Camera.prototype.setNear = function (near) {
    if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
      this.setPerspective(near, this.far, this.fov, this.aspect);
    } else {
      this.setOrthographic(this.left, this.rright, this.top, this.bottom, near, this.far);
    }

    return this;
  };

  Camera.prototype.setFar = function (far) {
    if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
      this.setPerspective(this.near, far, this.fov, this.aspect);
    } else {
      this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, far);
    }

    return this;
  };
  /**
   * Sets an offset in a larger frustum, used in PixelPicking
   */


  Camera.prototype.setViewOffset = function (fullWidth, fullHeight, x, y, width, height) {
    this.aspect = fullWidth / fullHeight;

    if (this.view === undefined) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }

    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;

    if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
      this.setPerspective(this.near, this.far, this.fov, this.aspect);
    } else {
      this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
    }

    return this;
  };

  Camera.prototype.clearViewOffset = function () {
    if (this.view !== undefined) {
      this.view.enabled = false;
    }

    if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
      this.setPerspective(this.near, this.far, this.fov, this.aspect);
    } else {
      this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
    }

    return this;
  };

  Camera.prototype.setZoom = function (zoom) {
    this.zoom = zoom;

    if (this.projectionMode === CameraProjectionMode.ORTHOGRAPHIC) {
      this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
    } else if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
      this.setPerspective(this.near, this.far, this.fov, this.aspect);
    }

    return this;
  };

  Camera.prototype.setPerspective = function (near, far, fov, aspect) {
    var _a;

    this.projectionMode = CameraProjectionMode.PERSPECTIVE;
    this.fov = fov;
    this.near = near;
    this.far = far;
    this.aspect = aspect;
    var top = this.near * Math.tan(DEG_2_RAD * 0.5 * this.fov) / this.zoom;
    var height = 2 * top;
    var width = this.aspect * height;
    var left = -0.5 * width;

    if ((_a = this.view) === null || _a === void 0 ? void 0 : _a.enabled) {
      var fullWidth = this.view.fullWidth;
      var fullHeight = this.view.fullHeight;
      left += this.view.offsetX * width / fullWidth;
      top -= this.view.offsetY * height / fullHeight;
      width *= this.view.width / fullWidth;
      height *= this.view.height / fullHeight;
    }

    makePerspective(this.projectionMatrix, left, left + width, top, top - height, near, this.far); // flipY since the origin of OpenGL/WebGL is bottom-left compared with top-left in Canvas2D

    scale(this.projectionMatrix, this.projectionMatrix, fromValues(1, -1, 1));
    invert(this.projectionMatrixInverse, this.projectionMatrix);
    this.triggerUpdate();
    return this;
  };

  Camera.prototype.setOrthographic = function (l, r, t, b, near, far) {
    var _a;

    this.projectionMode = CameraProjectionMode.ORTHOGRAPHIC;
    this.rright = r;
    this.left = l;
    this.top = t;
    this.bottom = b;
    this.near = near;
    this.far = far;
    var dx = (this.rright - this.left) / (2 * this.zoom);
    var dy = (this.top - this.bottom) / (2 * this.zoom);
    var cx = (this.rright + this.left) / 2;
    var cy = (this.top + this.bottom) / 2;
    var left = cx - dx;
    var right = cx + dx;
    var top = cy + dy;
    var bottom = cy - dy;

    if ((_a = this.view) === null || _a === void 0 ? void 0 : _a.enabled) {
      var scaleW = (this.rright - this.left) / this.view.fullWidth / this.zoom;
      var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }

    ortho(this.projectionMatrix, left, right, bottom, top, near, far); // flipY since the origin of OpenGL/WebGL is bottom-left compared with top-left in Canvas2D

    scale(this.projectionMatrix, this.projectionMatrix, fromValues(1, -1, 1));
    invert(this.projectionMatrixInverse, this.projectionMatrix);

    this._getOrthoMatrix();

    this.triggerUpdate();
    return this;
  };
  /**
   * Move the camera in world coordinates.
   * It will keep looking at the current focal point.
   *
   * support scalars or vectors.
   * @example
   * setPosition(1, 2, 3);
   * setPosition([1, 2, 3]);
   */


  Camera.prototype.setPosition = function (x, y, z) {
    if (y === void 0) {
      y = this.position[1];
    }

    if (z === void 0) {
      z = this.position[2];
    }

    var position = createVec3(x, y, z);

    this._setPosition(position);

    this.setFocalPoint(this.focalPoint);
    this.triggerUpdate();
    return this;
  };
  /**
   * Sets the focal point of this camera in world coordinates.
   *
   * support scalars or vectors.
   * @example
   * setFocalPoint(1, 2, 3);
   * setFocalPoint([1, 2, 3]);
   */


  Camera.prototype.setFocalPoint = function (x, y, z) {
    if (y === void 0) {
      y = this.focalPoint[1];
    }

    if (z === void 0) {
      z = this.focalPoint[2];
    }

    var up = fromValues(0, 1, 0);
    this.focalPoint = createVec3(x, y, z);

    if (this.trackingMode === CameraTrackingMode.CINEMATIC) {
      var d = subtract(create$1(), this.focalPoint, this.position);
      x = d[0];
      y = d[1];
      z = d[2];
      var r = length(d);
      var el = Math.asin(y / r) * RAD_2_DEG;
      var az = 90 + Math.atan2(z, x) * RAD_2_DEG;
      var m = create();
      rotateY(m, m, az * DEG_2_RAD);
      rotateX(m, m, el * DEG_2_RAD);
      up = transformMat4(create$1(), [0, 1, 0], m);
    }

    invert(this.matrix, lookAt(create(), this.position, this.focalPoint, up));

    this._getAxes();

    this._getDistance();

    this._getAngles();

    this.triggerUpdate();
    return this;
  };

  Camera.prototype.getDistance = function () {
    return this.distance;
  };
  /**
   * Moves the camera towards/from the focal point.
   */


  Camera.prototype.setDistance = function (d) {
    if (this.distance === d || d < 0) {
      return this;
    }

    this.distance = d;

    if (this.distance < MIN_DISTANCE) {
      this.distance = MIN_DISTANCE;
    }

    this.dollyingStep = this.distance / 100;
    var pos = create$1();
    d = this.distance;
    var n = this.forward;
    var f = this.focalPoint;
    pos[0] = d * n[0] + f[0];
    pos[1] = d * n[1] + f[1];
    pos[2] = d * n[2] + f[2];

    this._setPosition(pos);

    this.triggerUpdate();
    return this;
  };

  Camera.prototype.setMaxDistance = function (d) {
    this.maxDistance = d;
    return this;
  };

  Camera.prototype.setMinDistance = function (d) {
    this.minDistance = d;
    return this;
  }; // /**
  //  * Changes the initial azimuth of the camera
  //  */
  // changeAzimuth(az: number) {
  //   this.setAzimuth(this.azimuth + az);
  //   this.triggerUpdate();
  //   return this;
  // }
  // /**
  //  * Changes the initial elevation of the camera
  //  */
  // changeElevation(el: number) {
  //   this.setElevation(this.elevation + el);
  //   this.triggerUpdate();
  //   return this;
  // }
  // /**
  //  * Changes the initial roll of the camera
  //  */
  // changeRoll(rl: number) {
  //   this.setRoll(this.roll + rl);
  //   this.triggerUpdate();
  //   return this;
  // }

  /**
   * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置
   * the azimuth in degrees
   */


  Camera.prototype.setAzimuth = function (az) {
    this.azimuth = getAngle(az);
    this.computeMatrix();

    this._getAxes();

    if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
      this._getPosition();
    } else if (this.type === CameraType.TRACKING) {
      this._getFocalPoint();
    }

    this.triggerUpdate();
    return this;
  };

  Camera.prototype.getAzimuth = function () {
    return this.azimuth;
  };
  /**
   * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置
   */


  Camera.prototype.setElevation = function (el) {
    this.elevation = getAngle(el);
    this.computeMatrix();

    this._getAxes();

    if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
      this._getPosition();
    } else if (this.type === CameraType.TRACKING) {
      this._getFocalPoint();
    }

    this.triggerUpdate();
    return this;
  };

  Camera.prototype.getElevation = function () {
    return this.elevation;
  };
  /**
   * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置
   */


  Camera.prototype.setRoll = function (angle) {
    this.roll = getAngle(angle);
    this.computeMatrix();

    this._getAxes();

    if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
      this._getPosition();
    } else if (this.type === CameraType.TRACKING) {
      this._getFocalPoint();
    }

    this.triggerUpdate();
    return this;
  };

  Camera.prototype.getRoll = function () {
    return this.roll;
  };
  /**
   * Changes the azimuth and elevation with respect to the current camera axes
   * @param {Number} azimuth the relative azimuth
   * @param {Number} elevation the relative elevation
   * @param {Number} roll the relative roll
   */


  Camera.prototype.rotate = function (azimuth, elevation, roll) {
    this.relElevation = getAngle(elevation);
    this.relAzimuth = getAngle(azimuth);
    this.relRoll = getAngle(roll);
    this.elevation += this.relElevation;
    this.azimuth += this.relAzimuth;
    this.roll += this.relRoll;

    if (this.type === CameraType.EXPLORING) {
      var rotX = setAxisAngle(create$2(), [1, 0, 0], (this.rotateWorld ? 1 : -1) * this.relElevation * DEG_2_RAD);
      var rotY = setAxisAngle(create$2(), [0, 1, 0], (this.rotateWorld ? 1 : -1) * this.relAzimuth * DEG_2_RAD);
      var rotZ = setAxisAngle(create$2(), [0, 0, 1], this.relRoll * DEG_2_RAD);
      var rotQ = multiply$1(create$2(), rotY, rotX);
      rotQ = multiply$1(create$2(), rotQ, rotZ);
      var rotMatrix = fromQuat(create(), rotQ);
      translate(this.matrix, this.matrix, [0, 0, -this.distance]);
      multiply(this.matrix, this.matrix, rotMatrix);
      translate(this.matrix, this.matrix, [0, 0, this.distance]);
    } else {
      if (Math.abs(this.elevation) > 90) {
        return this;
      }

      this.computeMatrix();
    }

    this._getAxes();

    if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
      this._getPosition();
    } else if (this.type === CameraType.TRACKING) {
      this._getFocalPoint();
    }

    this._update();

    return this;
  };
  /**
   * 沿水平(right) & 垂直(up)平移相机
   */


  Camera.prototype.pan = function (tx, ty) {
    var coords = createVec3(tx, ty, 0);
    var pos = clone(this.position);
    add(pos, pos, scale$1(create$1(), this.right, coords[0]));
    add(pos, pos, scale$1(create$1(), this.up, coords[1]));

    this._setPosition(pos);

    this.triggerUpdate();
    return this;
  };
  /**
   * 沿 n 轴移动，当距离视点远时移动速度较快，离视点越近速度越慢
   */


  Camera.prototype.dolly = function (value) {
    var n = this.forward;
    var pos = clone(this.position);
    var step = value * this.dollyingStep;
    var updatedDistance = this.distance + value * this.dollyingStep; // 限制视点距离范围

    step = Math.max(Math.min(updatedDistance, this.maxDistance), this.minDistance) - this.distance;
    pos[0] += step * n[0];
    pos[1] += step * n[1];
    pos[2] += step * n[2];

    this._setPosition(pos);

    if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
      // 重新计算视点距离
      this._getDistance();
    } else if (this.type === CameraType.TRACKING) {
      // 保持视距，移动视点位置
      add(this.focalPoint, pos, this.distanceVector);
    }

    this.triggerUpdate();
    return this;
  };

  Camera.prototype.createLandmark = function (name, params) {
    if (params === void 0) {
      params = {};
    }

    var _a = params.position,
        position = _a === void 0 ? this.position : _a,
        _b = params.focalPoint,
        focalPoint = _b === void 0 ? this.focalPoint : _b,
        roll = params.roll,
        zoom = params.zoom;
    var camera = new Camera();
    camera.setType(this.type, undefined);
    camera.setPosition(position[0], position[1] || this.position[1], position[2] || this.position[2]);
    camera.setFocalPoint(focalPoint[0], focalPoint[1] || this.focalPoint[1], focalPoint[2] || this.focalPoint[2]);
    camera.setRoll(roll || this.roll);
    camera.setZoom(zoom || this.zoom);
    var landmark = {
      name: name,
      matrix: clone$1(camera.matrix),
      right: clone(camera.right),
      up: clone(camera.up),
      forward: clone(camera.forward),
      position: clone(camera.position),
      focalPoint: clone(camera.focalPoint),
      distanceVector: clone(camera.distanceVector),
      distance: camera.distance,
      dollyingStep: camera.dollyingStep,
      azimuth: camera.azimuth,
      elevation: camera.elevation,
      roll: camera.roll,
      relAzimuth: camera.relAzimuth,
      relElevation: camera.relElevation,
      relRoll: camera.relRoll,
      zoom: camera.zoom
    };
    this.landmarks.push(landmark);
    return landmark;
  };

  Camera.prototype.gotoLandmark = function (name, options) {
    var _this = this;

    if (options === void 0) {
      options = {};
    }

    var landmark = isString(name) ? this.landmarks.find(function (l) {
      return l.name === name;
    }) : name;

    if (landmark) {
      var _a = isNumber(options) ? {
        duration: options
      } : options,
          _b = _a.easing,
          easing = _b === void 0 ? 'linear' : _b,
          _c = _a.duration,
          duration_1 = _c === void 0 ? 100 : _c,
          _d = _a.easingFunction,
          easingFunction = _d === void 0 ? undefined : _d,
          _e = _a.onfinish,
          onfinish_1 = _e === void 0 ? undefined : _e;

      var epsilon_1 = 0.01;

      if (duration_1 === 0) {
        this.syncFromLandmark(landmark);

        if (onfinish_1) {
          onfinish_1();
        }

        return;
      } // cancel ongoing animation


      if (this.landmarkAnimationID !== undefined) {
        this.canvas.cancelAnimationFrame(this.landmarkAnimationID);
      }

      var destPosition_1 = landmark.position;
      var destFocalPoint_1 = landmark.focalPoint;
      var destZoom_1 = landmark.zoom;
      var destRoll_1 = landmark.roll;
      var easingFunc_1 = easingFunction || parseEasingFunction(easing);
      var timeStart_1;

      var endAnimation_1 = function endAnimation_1() {
        _this.setFocalPoint(destFocalPoint_1);

        _this.setPosition(destPosition_1);

        _this.setRoll(destRoll_1);

        _this.setZoom(destZoom_1);

        _this.computeMatrix();

        _this.triggerUpdate();

        if (onfinish_1) {
          onfinish_1();
        }
      };

      var animate_1 = function animate_1(timestamp) {
        if (timeStart_1 === undefined) {
          timeStart_1 = timestamp;
        }

        var elapsed = timestamp - timeStart_1;

        if (elapsed > duration_1) {
          endAnimation_1();
          return;
        } // use the same ease function in animation system


        var t = easingFunc_1(elapsed / duration_1);
        var interFocalPoint = create$1();
        var interPosition = create$1();
        var interZoom = 1;
        var interRoll = 0;
        lerp(interFocalPoint, _this.focalPoint, destFocalPoint_1, t);
        lerp(interPosition, _this.position, destPosition_1, t);
        interRoll = _this.roll * (1 - t) + destRoll_1 * t;
        interZoom = _this.zoom * (1 - t) + destZoom_1 * t;

        _this.setFocalPoint(interFocalPoint);

        _this.setPosition(interPosition);

        _this.setRoll(interRoll);

        _this.setZoom(interZoom);

        var dist$1 = dist(interFocalPoint, destFocalPoint_1) + dist(interPosition, destPosition_1);

        if (dist$1 <= epsilon_1) {
          endAnimation_1();
          return;
        }

        _this.computeMatrix();

        _this.triggerUpdate();

        if (elapsed < duration_1) {
          _this.landmarkAnimationID = _this.canvas.requestAnimationFrame(animate_1);
        }
      };

      this.canvas.requestAnimationFrame(animate_1);
    }
  };
  /**
   * 根据相机矩阵重新计算各种相机参数
   */


  Camera.prototype._update = function () {
    this._getAxes();

    this._getPosition();

    this._getDistance();

    this._getAngles();

    this._getOrthoMatrix();

    this.triggerUpdate();
  };
  /**
   * 计算相机矩阵
   */


  Camera.prototype.computeMatrix = function () {
    // 使用四元数描述 3D 旋转
    // @see https://xiaoiver.github.io/coding/2018/12/28/Camera-%E8%AE%BE%E8%AE%A1-%E4%B8%80.html
    var rotZ = setAxisAngle(create$2(), [0, 0, 1], this.roll * DEG_2_RAD);
    identity(this.matrix); // only consider HCS for EXPLORING and ORBITING cameras

    var rotX = setAxisAngle(create$2(), [1, 0, 0], (this.rotateWorld && this.type !== CameraType.TRACKING || this.type === CameraType.TRACKING ? 1 : -1) * this.elevation * DEG_2_RAD);
    var rotY = setAxisAngle(create$2(), [0, 1, 0], (this.rotateWorld && this.type !== CameraType.TRACKING || this.type === CameraType.TRACKING ? 1 : -1) * this.azimuth * DEG_2_RAD);
    var rotQ = multiply$1(create$2(), rotY, rotX);
    rotQ = multiply$1(create$2(), rotQ, rotZ);
    var rotMatrix = fromQuat(create(), rotQ);

    if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
      translate(this.matrix, this.matrix, this.focalPoint);
      multiply(this.matrix, this.matrix, rotMatrix);
      translate(this.matrix, this.matrix, [0, 0, this.distance]);
    } else if (this.type === CameraType.TRACKING) {
      translate(this.matrix, this.matrix, this.position);
      multiply(this.matrix, this.matrix, rotMatrix);
    }
  };
  /**
   * Sets the camera position in the camera matrix
   */


  Camera.prototype._setPosition = function (x, y, z) {
    this.position = createVec3(x, y, z);
    var m = this.matrix;
    m[12] = this.position[0];
    m[13] = this.position[1];
    m[14] = this.position[2];
    m[15] = 1;

    this._getOrthoMatrix();
  };
  /**
   * Recalculates axes based on the current matrix
   */


  Camera.prototype._getAxes = function () {
    copy(this.right, createVec3(transformMat4$1(create$3(), [1, 0, 0, 0], this.matrix)));
    copy(this.up, createVec3(transformMat4$1(create$3(), [0, 1, 0, 0], this.matrix)));
    copy(this.forward, createVec3(transformMat4$1(create$3(), [0, 0, 1, 0], this.matrix)));
    normalize(this.right, this.right);
    normalize(this.up, this.up);
    normalize(this.forward, this.forward);
  };
  /**
   * Recalculates euler angles based on the current state
   */


  Camera.prototype._getAngles = function () {
    // Recalculates angles
    var x = this.distanceVector[0];
    var y = this.distanceVector[1];
    var z = this.distanceVector[2];
    var r = length(this.distanceVector); // FAST FAIL: If there is no distance we cannot compute angles

    if (r === 0) {
      this.elevation = 0;
      this.azimuth = 0;
      return;
    }

    if (this.type === CameraType.TRACKING) {
      this.elevation = Math.asin(y / r) * RAD_2_DEG;
      this.azimuth = Math.atan2(-x, -z) * RAD_2_DEG;
    } else {
      if (this.rotateWorld) {
        this.elevation = Math.asin(y / r) * RAD_2_DEG;
        this.azimuth = Math.atan2(-x, -z) * RAD_2_DEG;
      } else {
        this.elevation = -Math.asin(y / r) * RAD_2_DEG;
        this.azimuth = -Math.atan2(-x, -z) * RAD_2_DEG;
      }
    }
  };
  /**
   * 重新计算相机位置，只有 ORBITING 模式相机位置才会发生变化
   */


  Camera.prototype._getPosition = function () {
    copy(this.position, createVec3(transformMat4$1(create$3(), [0, 0, 0, 1], this.matrix))); // 相机位置变化，需要重新计算视距

    this._getDistance();
  };
  /**
   * 重新计算视点，只有 TRACKING 模式视点才会发生变化
   */


  Camera.prototype._getFocalPoint = function () {
    transformMat3(this.distanceVector, [0, 0, -this.distance], fromMat4(create$4(), this.matrix));
    add(this.focalPoint, this.position, this.distanceVector); // 视点变化，需要重新计算视距

    this._getDistance();
  };
  /**
   * 重新计算视距
   */


  Camera.prototype._getDistance = function () {
    this.distanceVector = subtract(create$1(), this.focalPoint, this.position);
    this.distance = length(this.distanceVector);
    this.dollyingStep = this.distance / 100;
  };

  Camera.prototype._getOrthoMatrix = function () {
    if (this.projectionMode !== CameraProjectionMode.ORTHOGRAPHIC) {
      return;
    }

    var position = this.position;
    var rotZ = setAxisAngle(create$2(), [0, 0, 1], -this.roll * Math.PI / 180);
    fromRotationTranslationScaleOrigin(this.orthoMatrix, rotZ, fromValues((this.rright - this.left) / 2 - position[0], (this.top - this.bottom) / 2 - position[1], 0), fromValues(this.zoom, this.zoom, 1), position);
  };

  Camera.prototype.triggerUpdate = function () {
    if (this.enableUpdate) {
      // update frustum
      var viewMatrix = this.getViewTransform();
      var vpMatrix = multiply(create(), this.getPerspective(), viewMatrix);
      this.getFrustum().extractFromVPMatrix(vpMatrix);
      this.emit(CameraEvent.UPDATED);
    }
  };

  Camera.prototype.syncFromLandmark = function (landmark) {
    this.matrix = copy$1(this.matrix, landmark.matrix);
    this.right = copy(this.right, landmark.right);
    this.up = copy(this.up, landmark.up);
    this.forward = copy(this.forward, landmark.forward);
    this.position = copy(this.position, landmark.position);
    this.focalPoint = copy(this.focalPoint, landmark.focalPoint);
    this.distanceVector = copy(this.distanceVector, landmark.distanceVector);
    this.azimuth = landmark.azimuth;
    this.elevation = landmark.elevation;
    this.roll = landmark.roll;
    this.relAzimuth = landmark.relAzimuth;
    this.relElevation = landmark.relElevation;
    this.relRoll = landmark.relRoll;
    this.dollyingStep = landmark.dollyingStep;
    this.distance = landmark.distance;
    this.zoom = landmark.zoom;
  };

  return Camera;
}(eventemitter3.exports.EventEmitter);

export { Camera, CameraEvent, CameraProjectionMode, CameraTrackingMode, CameraType, DefaultCamera };
