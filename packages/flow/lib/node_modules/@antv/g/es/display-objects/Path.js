import { __extends, __rest, __assign } from '../../../../tslib/tslib.es6.js';
import CubicUtil from '../../../g-math/es/cubic.js';
import { Shape } from '../types.js';
import { DisplayObject } from './DisplayObject.js';
import '../shapes/AABB.js';
import '../shapes/BoundingSphere.js';
import '../shapes/Frustum.js';
import '../shapes/Plane.js';
import '../shapes/Ray.js';
import { Point } from '../shapes/Point.js';
import '../shapes/Rectangle.js';
import isNil from '../../../../lodash-es/isNil.js';

var Path =
/** @class */
function (_super) {
  __extends(Path, _super);

  function Path(_a) {
    if (_a === void 0) {
      _a = {};
    }

    var style = _a.style,
        rest = __rest(_a, ["style"]);

    return _super.call(this, __assign({
      type: Shape.PATH,
      style: __assign({
        path: '',
        lineWidth: 1,
        miterLimit: 4
      }, style)
    }, rest)) || this;
  }

  Path.prototype.getTotalLength = function () {
    return this.parsedStyle.path.totalLength;
  };
  /**
   * Get point according to ratio
   */


  Path.prototype.getPoint = function (ratio) {
    var subt = 0;
    var index = 0;
    var curve = this.parsedStyle.path.curve;

    if (!this.parsedStyle.path.curveSegments.length) {
      if (curve) {
        return new Point(curve[0][1], curve[0][2]);
      }

      return null;
    }

    this.parsedStyle.path.curveSegments.forEach(function (v, i) {
      if (ratio >= v[0] && ratio <= v[1]) {
        subt = (ratio - v[0]) / (v[1] - v[0]);
        index = i;
      }
    });
    var seg = curve[index];

    if (isNil(seg) || isNil(index)) {
      return null;
    }

    var l = seg.length;
    var nextSeg = curve[index + 1];

    var _a = CubicUtil.pointAt( // @ts-ignore
    seg[l - 2], seg[l - 1], nextSeg[1], nextSeg[2], nextSeg[3], nextSeg[4], nextSeg[5], nextSeg[6], subt),
        x = _a.x,
        y = _a.y;

    return new Point(x, y);
  };
  /**
   * Get start tangent vector
   */


  Path.prototype.getStartTangent = function () {
    var segments = this.parsedStyle.path.segments;
    var result = [];

    if (segments.length > 1) {
      var startPoint = segments[0].currentPoint;
      var endPoint = segments[1].currentPoint;
      var tangent = segments[1].startTangent;
      result = [];

      if (tangent) {
        result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);
        result.push([startPoint[0], startPoint[1]]);
      } else {
        result.push([endPoint[0], endPoint[1]]);
        result.push([startPoint[0], startPoint[1]]);
      }
    }

    return result;
  };
  /**
   * Get end tangent vector
   */


  Path.prototype.getEndTangent = function () {
    var segments = this.parsedStyle.path.segments;
    var length = segments.length;
    var result = [];

    if (length > 1) {
      var startPoint = segments[length - 2].currentPoint;
      var endPoint = segments[length - 1].currentPoint;
      var tangent = segments[length - 1].endTangent;
      result = [];

      if (tangent) {
        result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);
        result.push([endPoint[0], endPoint[1]]);
      } else {
        result.push([startPoint[0], startPoint[1]]);
        result.push([endPoint[0], endPoint[1]]);
      }
    }

    return result;
  };

  return Path;
}(DisplayObject);

export { Path };
