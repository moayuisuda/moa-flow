import { __decorate, __metadata, __read } from '../../../../tslib/tslib.es6.js';
import { inject, singleton } from '../../../../mana-syringe/es/decorator.js';
import '../../../../mana-syringe/es/container.js';
import { Syringe } from '../../../../mana-syringe/es/core.js';
import '../../../../mana-syringe/es/contribution/contribution-protocol.js';
import '../../../../inversify/lib/inversify.js';
import '../../../../mana-syringe/es/register.js';
import '../../../../mana-syringe/es/contribution/index.js';
import { AABB } from '../shapes/AABB.js';
import '../shapes/BoundingSphere.js';
import '../shapes/Frustum.js';
import '../shapes/Plane.js';
import '../shapes/Ray.js';
import '../shapes/Point.js';
import { Rectangle } from '../shapes/Rectangle.js';
import { SceneGraphSelectorFactory } from './SceneGraphSelector.js';
import { ElementEvent } from '../dom/interfaces.js';
import { MutationEvent } from '../dom/MutationEvent.js';
import isNil from '../../../../lodash-es/isNil.js';
import { create, fromEuler, copy, invert, multiply, normalize, mul, fromValues as fromValues$1 } from '../../../../gl-matrix/esm/quat.js';
import { fromValues, equals, create as create$1, transformQuat, add, copy as copy$1, transformMat4, multiply as multiply$1 } from '../../../../gl-matrix/esm/vec3.js';
import { create as create$2, copy as copy$2, invert as invert$1, getTranslation, getRotation, getScaling, fromRotationTranslationScaleOrigin, multiply as multiply$2 } from '../../../../gl-matrix/esm/mat4.js';

function sortByZIndex(o1, o2) {
  var zIndex1 = Number(o1.style.zIndex);
  var zIndex2 = Number(o2.style.zIndex);

  if (zIndex1 === zIndex2) {
    // return o1.entity.getComponent(Sortable).lastSortedIndex - o2.entity.getComponent(Sortable).lastSortedIndex;
    var parent_1 = o1.parentNode;

    if (parent_1) {
      var children = parent_1.childNodes || [];
      return children.indexOf(o1) - children.indexOf(o2);
    }
  }

  return zIndex1 - zIndex2;
}
function dirtifyToRoot(element, affectChildren) {
  if (affectChildren === void 0) {
    affectChildren = false;
  }

  var p = element;

  while (p) {
    var renderable = p.renderable;

    if (renderable) {
      renderable.renderBoundsDirty = true;
      renderable.boundsDirty = true;
      renderable.dirty = true;
    }

    p = p.parentNode;
  }

  element.emit(ElementEvent.BOUNDS_CHANGED, {
    affectChildren: affectChildren
  });
}
var SceneGraphService = Syringe.defineToken('SceneGraphService');
/**
 * update transform in scene graph
 *
 * @see https://community.khronos.org/t/scene-graphs/50542/7
 */

var DefaultSceneGraphService =
/** @class */
function () {
  function DefaultSceneGraphService() {
    var _this = this;
    /**
     * rotate in world space
     */


    this.rotate = function () {
      var parentInvertRotation = create();
      return function (element, degrees, y, z) {
        if (y === void 0) {
          y = 0;
        }

        if (z === void 0) {
          z = 0;
        }

        if (typeof degrees === 'number') {
          degrees = fromValues(degrees, y, z);
        }

        var transform = element.transformable;

        if (element.parentNode === null || !element.parentNode.transformable) {
          _this.rotateLocal(element, degrees);
        } else {
          var rotation = create();
          fromEuler(rotation, degrees[0], degrees[1], degrees[2]);

          var rot = _this.getRotation(element);

          var parentRot = _this.getRotation(element.parentNode);

          copy(parentInvertRotation, parentRot);
          invert(parentInvertRotation, parentInvertRotation);
          multiply(rotation, parentInvertRotation, rotation);
          multiply(transform.localRotation, rotation, rot);
          normalize(transform.localRotation, transform.localRotation);

          _this.dirtifyLocal(element, transform);
        }
      };
    }();
    /**
     * rotate in local space
     * @see @see https://docs.microsoft.com/en-us/windows/win32/api/directxmath/nf-directxmath-xmquaternionrotationrollpitchyaw
     */


    this.rotateLocal = function () {
      var rotation = create();
      return function (element, degrees, y, z) {
        if (y === void 0) {
          y = 0;
        }

        if (z === void 0) {
          z = 0;
        }

        if (typeof degrees === 'number') {
          degrees = fromValues(degrees, y, z);
        }

        var transform = element.transformable;
        fromEuler(rotation, degrees[0], degrees[1], degrees[2]);
        mul(transform.localRotation, transform.localRotation, rotation);

        _this.dirtifyLocal(element, transform);
      };
    }();
    /**
     * set euler angles(degrees) in world space
     */


    this.setEulerAngles = function () {
      var invParentRot = create();
      return function (element, degrees, y, z) {
        if (y === void 0) {
          y = 0;
        }

        if (z === void 0) {
          z = 0;
        }

        if (typeof degrees === 'number') {
          degrees = fromValues(degrees, y, z);
        }

        var transform = element.transformable;

        if (element.parentNode === null || !element.parentNode.transformable) {
          _this.setLocalEulerAngles(element, degrees);
        } else {
          fromEuler(transform.localRotation, degrees[0], degrees[1], degrees[2]);

          var parentRotation = _this.getRotation(element.parentNode);

          copy(invParentRot, invert(create(), parentRotation));
          mul(transform.localRotation, transform.localRotation, invParentRot);

          _this.dirtifyLocal(element, transform);
        }
      };
    }();
    /**
     * translate in local space
     *
     * @example
     * ```
     * translateLocal(x, y, z)
     * translateLocal(vec3(x, y, z))
     * ```
     */


    this.translateLocal = function () {
      return function (element, translation, y, z) {
        if (y === void 0) {
          y = 0;
        }

        if (z === void 0) {
          z = 0;
        }

        if (typeof translation === 'number') {
          translation = fromValues(translation, y, z);
        }

        var transform = element.transformable;

        if (equals(translation, create$1())) {
          return;
        }

        transformQuat(translation, translation, transform.localRotation);
        add(transform.localPosition, transform.localPosition, translation);

        _this.dirtifyLocal(element, transform);
      };
    }();
    /**
     * move to position in world space
     *
     * 对应 g 原版的 move/moveTo
     * @see https://github.com/antvis/g/blob/master/packages/g-base/src/abstract/element.ts#L684-L689
     */


    this.setPosition = function () {
      var parentInvertMatrix = create$2();
      return function (element, position) {
        var transform = element.transformable;
        position = fromValues(position[0], position[1], position[2] || 0);

        if (equals(_this.getPosition(element), position)) {
          return;
        }

        transform.position = position;

        if (element.parentNode === null || !element.parentNode.transformable) {
          copy$1(transform.localPosition, position);
        } else {
          var parentTransform = element.parentNode.transformable;
          copy$2(parentInvertMatrix, parentTransform.worldTransform);
          invert$1(parentInvertMatrix, parentInvertMatrix);
          transformMat4(transform.localPosition, position, parentInvertMatrix);
        }

        _this.dirtifyLocal(element, transform);
      };
    }();
    /**
     * translate in world space
     *
     * @example
     * ```
     * translate(x, y, z)
     * translate(vec3(x, y, z))
     * ```
     *
     * 对应 g 原版的 translate 2D
     * @see https://github.com/antvis/g/blob/master/packages/g-base/src/abstract/element.ts#L665-L676
     */


    this.translate = function () {
      var tr = create$1();
      return function (element, translation, y, z) {
        if (y === void 0) {
          y = 0;
        }

        if (z === void 0) {
          z = 0;
        }

        if (typeof translation === 'number') {
          translation = fromValues(translation, y, z);
        }

        if (equals(translation, create$1())) {
          return;
        }

        add(tr, _this.getPosition(element), translation);

        _this.setPosition(element, tr);
      };
    }();

    this.setRotation = function () {
      var parentInvertRotation = create();
      return function (element, rotation, y, z, w) {
        var transform = element.transformable;

        if (typeof rotation === 'number') {
          rotation = fromValues$1(rotation, y, z, w);
        }

        if (element.parentNode === null || !element.parentNode.transformable) {
          _this.setLocalRotation(element, rotation);
        } else {
          var parentRot = _this.getRotation(element.parentNode);

          copy(parentInvertRotation, parentRot);
          invert(parentInvertRotation, parentInvertRotation);
          multiply(transform.localRotation, parentInvertRotation, rotation);
          normalize(transform.localRotation, transform.localRotation);

          _this.dirtifyLocal(element, transform);
        }
      };
    };
  }

  DefaultSceneGraphService.prototype.matches = function (query, root) {
    return this.sceneGraphSelectorFactory().is(query, root);
  };

  DefaultSceneGraphService.prototype.querySelector = function (query, root) {
    return this.sceneGraphSelectorFactory().selectOne(query, root);
  };

  DefaultSceneGraphService.prototype.querySelectorAll = function (query, root) {
    return this.sceneGraphSelectorFactory().selectAll(query, root); // .filter((node) => !node.shadow);
  };

  DefaultSceneGraphService.prototype.attach = function (child, parent, index) {
    if (child.parentNode) {
      this.detach(child);
    }

    child.parentNode = parent;

    if (!isNil(index)) {
      child.parentNode.childNodes.splice(index, 0, child);
    } else {
      child.parentNode.childNodes.push(child);
    } // parent needs re-sort


    var sortable = parent.sortable;

    if (sortable) {
      sortable.dirty = true;
    } // this.updateGraphDepth(child);


    var transform = child.transformable;

    if (transform) {
      this.dirtifyWorld(child, transform);
    }

    if (transform.frozen) {
      this.unfreezeParentToRoot(child);
    }
  };

  DefaultSceneGraphService.prototype.detach = function (child) {
    if (child.parentNode) {
      var transform = child.transformable; // if (transform) {
      //   const worldTransform = this.getWorldTransform(child, transform);
      //   mat4.getScaling(transform.localScale, worldTransform);
      //   mat4.getTranslation(transform.localPosition, worldTransform);
      //   mat4.getRotation(transform.localRotation, worldTransform);
      //   transform.localDirtyFlag = true;
      // }
      // parent needs re-sort

      var sortable = child.parentNode.sortable;

      if (sortable) {
        sortable.dirty = true;
      }

      var index = child.parentNode.childNodes.indexOf(child);

      if (index > -1) {
        child.parentNode.childNodes.splice(index, 1);
      }

      if (transform) {
        this.dirtifyWorld(child, transform);
      }

      child.parentNode = null;
    }
  };

  DefaultSceneGraphService.prototype.getOrigin = function (element) {
    return element.transformable.origin;
  };
  /**
   * same as pivot in Pixi.js
   *
   * @see https://stackoverflow.com/questions/40748452/how-to-change-css-transform-origin-but-preserve-transformation
   */


  DefaultSceneGraphService.prototype.setOrigin = function (element, origin, y, z) {
    if (y === void 0) {
      y = 0;
    }

    if (z === void 0) {
      z = 0;
    }

    if (typeof origin === 'number') {
      origin = fromValues(origin, y, z);
    }

    var transform = element.transformable;

    if (equals(origin, transform.origin)) {
      return;
    }

    var originVec = transform.origin; // const delta = vec3.subtract(vec3.create(), origin, originVec);
    // vec3.add(transform.localPosition, transform.localPosition, delta);
    // update origin

    originVec[0] = origin[0];
    originVec[1] = origin[1];
    originVec[2] = origin[2] || 0;
    this.dirtifyLocal(element, transform);
  };
  /**
   * set euler angles(degrees) in local space
   */


  DefaultSceneGraphService.prototype.setLocalEulerAngles = function (element, degrees, y, z) {
    if (y === void 0) {
      y = 0;
    }

    if (z === void 0) {
      z = 0;
    }

    if (typeof degrees === 'number') {
      degrees = fromValues(degrees, y, z);
    }

    var transform = element.transformable;
    fromEuler(transform.localRotation, degrees[0], degrees[1], degrees[2]);
    this.dirtifyLocal(element, transform);
  };
  /**
   * move to position in local space
   */


  DefaultSceneGraphService.prototype.setLocalPosition = function (element, position) {
    var transform = element.transformable;
    position = fromValues(position[0], position[1], position[2] || 0);

    if (equals(transform.localPosition, position)) {
      return;
    }

    copy$1(transform.localPosition, position);
    this.dirtifyLocal(element, transform);
  };
  /**
   * scale in local space
   */


  DefaultSceneGraphService.prototype.scaleLocal = function (element, scaling) {
    var transform = element.transformable;
    multiply$1(transform.localScale, transform.localScale, fromValues(scaling[0], scaling[1], scaling[2] || 1));
    this.dirtifyLocal(element, transform);
  };

  DefaultSceneGraphService.prototype.setLocalScale = function (element, scaling) {
    var transform = element.transformable;
    var updatedScaling = fromValues(scaling[0], scaling[1], scaling[2] || transform.localScale[2]);

    if (equals(updatedScaling, transform.localScale)) {
      return;
    }

    copy$1(transform.localScale, updatedScaling);
    this.dirtifyLocal(element, transform);
  };

  DefaultSceneGraphService.prototype.setLocalRotation = function (element, rotation, y, z, w) {
    if (typeof rotation === 'number') {
      rotation = fromValues$1(rotation, y, z, w);
    }

    var transform = element.transformable;
    copy(transform.localRotation, rotation);
    this.dirtifyLocal(element, transform);
  };

  DefaultSceneGraphService.prototype.dirtifyLocal = function (element, transform) {
    if (!transform.localDirtyFlag) {
      transform.localDirtyFlag = true;

      if (!transform.dirtyFlag) {
        this.dirtifyWorld(element, transform);
      }
    }
  };

  DefaultSceneGraphService.prototype.dirtifyWorld = function (element, transform) {
    if (!transform.dirtyFlag) {
      this.unfreezeParentToRoot(element);
    }

    this.dirtifyWorldInternal(element, transform);
    dirtifyToRoot(element, true);
  };

  DefaultSceneGraphService.prototype.getPosition = function (element) {
    var transform = element.transformable;
    return getTranslation(transform.position, this.getWorldTransform(element, transform));
  };

  DefaultSceneGraphService.prototype.getRotation = function (element) {
    var transform = element.transformable;
    return getRotation(transform.rotation, this.getWorldTransform(element, transform));
  };

  DefaultSceneGraphService.prototype.getScale = function (element) {
    var transform = element.transformable;
    return getScaling(transform.scaling, this.getWorldTransform(element, transform));
  };

  DefaultSceneGraphService.prototype.getWorldTransform = function (element, transform) {
    if (transform === void 0) {
      transform = element.transformable;
    }

    if (!transform.localDirtyFlag && !transform.dirtyFlag) {
      return transform.worldTransform;
    }

    if (element.parentNode && element.parentNode.transformable) {
      this.getWorldTransform(element.parentNode);
    }

    this.sync(element, transform);
    return transform.worldTransform;
  };

  DefaultSceneGraphService.prototype.getLocalPosition = function (element) {
    return element.transformable.localPosition;
  };

  DefaultSceneGraphService.prototype.getLocalRotation = function (element) {
    return element.transformable.localRotation;
  };

  DefaultSceneGraphService.prototype.getLocalScale = function (element) {
    return element.transformable.localScale;
  };

  DefaultSceneGraphService.prototype.getLocalTransform = function (element) {
    var transform = element.transformable;

    if (transform.localDirtyFlag) {
      fromRotationTranslationScaleOrigin(transform.localTransform, transform.localRotation, transform.localPosition, transform.localScale, transform.origin);
      transform.localDirtyFlag = false;
    }

    return transform.localTransform;
  };

  DefaultSceneGraphService.prototype.resetLocalTransform = function (element) {
    this.setLocalScale(element, [1, 1, 1]);
    this.setLocalPosition(element, [0, 0, 0]);
    this.setLocalEulerAngles(element, [0, 0, 0]);
  };

  DefaultSceneGraphService.prototype.getTransformedGeometryBounds = function (element, render) {
    if (render === void 0) {
      render = false;
    }

    var bounds = this.getGeometryBounds(element, render);

    if (!AABB.isEmpty(bounds)) {
      var aabb = new AABB();
      aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));
      return aabb;
    } else {
      return null;
    }
  };
  /**
   * won't account for children
   */


  DefaultSceneGraphService.prototype.getGeometryBounds = function (element, render) {
    if (render === void 0) {
      render = false;
    }

    var geometry = element.geometry;
    var bounds = render ? geometry.renderBounds : geometry.contentBounds || null;
    return bounds && new AABB(bounds.center, bounds.halfExtents) || new AABB();
  };
  /**
   * account for children in world space
   */


  DefaultSceneGraphService.prototype.getBounds = function (element, render) {
    var _this = this;

    if (render === void 0) {
      render = false;
    }

    var renderable = element.renderable;

    if (!renderable.boundsDirty && !render && renderable.bounds) {
      return renderable.bounds;
    }

    if (!renderable.renderBoundsDirty && render && renderable.renderBounds) {
      return renderable.renderBounds;
    } // reset with geometry's aabb


    var aabb = this.getTransformedGeometryBounds(element, render); // merge children's aabbs

    var children = element.childNodes;
    children.forEach(function (child) {
      var childBounds = _this.getBounds(child, render);

      if (childBounds) {
        if (!aabb) {
          aabb = new AABB();
          aabb.update(childBounds.center, childBounds.halfExtents);
        } else {
          aabb.add(childBounds);
        }
      }
    }); // account for clip path

    var clipPath = element.style.clipPath;

    if (clipPath) {
      var clipPathBounds = this.getTransformedGeometryBounds(clipPath, true);
      var transformParentBounds = void 0;

      if (clipPathBounds) {
        transformParentBounds = new AABB(); // intersect with original geometry

        transformParentBounds.setFromTransformedAABB(clipPathBounds, this.getWorldTransform(element));
      }

      if (!aabb) {
        aabb = transformParentBounds;
      } else if (transformParentBounds) {
        aabb = transformParentBounds.intersection(aabb);
      }
    }

    if (aabb) {
      if (render) {
        renderable.renderBounds = aabb;
      } else {
        renderable.bounds = aabb;
      }
    }

    if (render) {
      renderable.renderBoundsDirty = false;
    } else {
      renderable.boundsDirty = false;
    }

    return aabb || new AABB();
  };
  /**
   * account for children in local space
   */


  DefaultSceneGraphService.prototype.getLocalBounds = function (element) {
    if (element.parentNode) {
      var parentInvert = create$2();

      if (element.parentNode.transformable) {
        parentInvert = invert$1(create$2(), this.getWorldTransform(element.parentNode));
      }

      var bounds = this.getBounds(element);

      if (!AABB.isEmpty(bounds)) {
        var localBounds = new AABB();
        localBounds.setFromTransformedAABB(bounds, parentInvert);
        return localBounds;
      }
    }

    return this.getBounds(element);
  };

  DefaultSceneGraphService.prototype.getBoundingClientRect = function (element) {
    var _a, _b;

    var aabb;
    var bounds = this.getGeometryBounds(element);

    if (!AABB.isEmpty(bounds)) {
      aabb = new AABB(); // apply transformation to aabb

      aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));
    } // calc context's offset


    var bbox = (_b = (_a = element.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView) === null || _b === void 0 ? void 0 : _b.getContextService().getBoundingClientRect();

    if (aabb) {
      var _c = __read(aabb.getMin(), 2),
          left = _c[0],
          top_1 = _c[1];

      var _d = __read(aabb.getMax(), 2),
          right = _d[0],
          bottom = _d[1];

      return new Rectangle(left + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0), top_1 + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0), right - left, bottom - top_1);
    }

    return new Rectangle((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0, (bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0, 0, 0);
  };

  DefaultSceneGraphService.prototype.dirtifyWorldInternal = function (element, transform) {
    var _this = this;

    if (!transform.dirtyFlag) {
      transform.dirtyFlag = true;
      transform.frozen = false;
      element.childNodes.forEach(function (child) {
        var childTransform = child.transformable;

        if (!childTransform.dirtyFlag) {
          _this.dirtifyWorldInternal(child, childTransform);
        }
      });
      var renderable = element.renderable;

      if (renderable) {
        renderable.renderBoundsDirty = true;
        renderable.boundsDirty = true;
        renderable.dirty = true;
      }

      element.dispatchEvent(new MutationEvent(ElementEvent.ATTR_MODIFIED, element, null, null, 'modelMatrix', MutationEvent.MODIFICATION, null, null));
    }
  };

  DefaultSceneGraphService.prototype.syncHierarchy = function (element) {
    var transform = element.transformable;

    if (transform.frozen) {
      return;
    }

    transform.frozen = true;

    if (transform.localDirtyFlag || transform.dirtyFlag) {
      this.sync(element, transform);
    }

    var children = element.childNodes;

    for (var i = 0; i < children.length; i++) {
      this.syncHierarchy(children[i]);
    }
  };

  DefaultSceneGraphService.prototype.sync = function (element, transform) {
    if (transform.localDirtyFlag) {
      fromRotationTranslationScaleOrigin(transform.localTransform, transform.localRotation, transform.localPosition, transform.localScale, transform.origin);
      transform.localDirtyFlag = false;
    }

    if (transform.dirtyFlag) {
      var parent_2 = element.parentNode;
      var parentTransform = parent_2 && parent_2.transformable;

      if (parent_2 === null || !parentTransform) {
        copy$2(transform.worldTransform, transform.localTransform);
      } else {
        // TODO: should we support scale compensation?
        // @see https://github.com/playcanvas/engine/issues/1077#issuecomment-359765557
        multiply$2(transform.worldTransform, parentTransform.worldTransform, transform.localTransform);
      }

      transform.dirtyFlag = false;
    }
  };

  DefaultSceneGraphService.prototype.unfreezeParentToRoot = function (child) {
    var p = child.parentNode;

    while (p) {
      var transform = p.transformable;

      if (transform) {
        transform.frozen = false;
      }

      p = p.parentNode;
    }
  };

  __decorate([inject(SceneGraphSelectorFactory), __metadata("design:type", Function)], DefaultSceneGraphService.prototype, "sceneGraphSelectorFactory", void 0);

  DefaultSceneGraphService = __decorate([singleton()], DefaultSceneGraphService);
  return DefaultSceneGraphService;
}();

export { DefaultSceneGraphService, SceneGraphService, dirtifyToRoot, sortByZIndex };
