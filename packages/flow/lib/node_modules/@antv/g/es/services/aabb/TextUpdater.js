import { __decorate, __metadata } from '../../../../../tslib/tslib.es6.js';
import { inject, singleton } from '../../../../../mana-syringe/es/decorator.js';
import '../../../../../mana-syringe/es/container.js';
import '../../../../../mana-syringe/es/core.js';
import '../../../../../mana-syringe/es/contribution/contribution-protocol.js';
import '../../../../../inversify/lib/inversify.js';
import '../../../../../mana-syringe/es/register.js';
import '../../../../../mana-syringe/es/contribution/index.js';
import { GeometryAABBUpdater } from './interfaces.js';
import { TextService } from '../TextService.js';
import { Shape } from '../../types.js';
import '../../css/cssom/types.js';
import '../../css/cssom/CSSColorValue.js';
import '../../css/cssom/CSSKeywordValue.js';
import '../../css/cssom/CSSMathOperator.js';
import '../../css/cssom/CSSMathInvert.js';
import '../../css/cssom/CSSMathMax.js';
import '../../css/cssom/CSSMathMin.js';
import '../../css/cssom/CSSMathNegate.js';
import '../../css/cssom/CSSMathProduct.js';
import '../../css/cssom/CSSMathSum.js';
import '../../css/cssom/CSSMathValue.js';
import '../../css/cssom/CSSMathVariadic.js';
import '../../css/cssom/CSSNumericValue.js';
import '../../css/cssom/CSSNumericValueType.js';
import '../../css/cssom/CSSRGB.js';
import '../../css/cssom/CSSGradientValue.js';
import '../../css/cssom/CSSStyleValue.js';
import '../../css/cssom/CSSTransformValue.js';
import '../../css/cssom/CSSTranslate.js';
import { CSSUnitValue } from '../../css/cssom/CSSUnitValue.js';
import '../../css/parser/dimension.js';
import '../../shapes/Rectangle.js';
import '../../css/parser/filter.js';
import '../../css/parser/transform.js';
import '../../css/properties/CSSPropertyLengthOrPercentage.js';
import '../../css/properties/CSSPropertyLocalPosition.js';
import '../../css/properties/CSSPropertyOpacity.js';
import '../../css/properties/CSSPropertyColor.js';
import '../../css/properties/CSSPropertyFilter.js';
import '../../css/properties/CSSPropertyLineDash.js';
import '../../css/properties/CSSPropertyShadowBlur.js';
import '../../css/properties/CSSPropertyOffsetPath.js';
import '../../css/properties/CSSPropertyOffsetDistance.js';
import '../../css/properties/CSSPropertyAnchor.js';
import '../../css/properties/CSSPropertyZIndex.js';
import '../../css/properties/CSSPropertyTransform.js';
import '../../css/properties/CSSPropertyTransformOrigin.js';
import '../../css/properties/CSSPropertyPath.js';
import '../../css/properties/CSSPropertyPoints.js';
import '../../css/properties/CSSPropertyClipPath.js';
import '../../css/properties/CSSPropertyText.js';
import '../../css/properties/CSSPropertyTextTransform.js';
import '../../css/StyleValueRegistry.js';
import '../../css/LayoutRegistry.js';
import { fromValues } from '../../../../../gl-matrix/esm/vec3.js';

var TextUpdater =
/** @class */
function () {
  function TextUpdater() {}

  TextUpdater.prototype.isReadyToMeasure = function (parsedStyle, object) {
    var text = parsedStyle.text,
        textAlign = parsedStyle.textAlign,
        textBaseline = parsedStyle.textBaseline,
        fontSize = parsedStyle.fontSize,
        fontStyle = parsedStyle.fontStyle,
        fontWeight = parsedStyle.fontWeight,
        fontVariant = parsedStyle.fontVariant;
    return text && fontSize && fontStyle && fontWeight && fontVariant && textAlign && textBaseline;
  };

  TextUpdater.prototype.update = function (parsedStyle, object) {
    var _a, _b;

    var text = parsedStyle.text,
        textAlign = parsedStyle.textAlign,
        lineWidth = parsedStyle.lineWidth,
        textBaseline = parsedStyle.textBaseline,
        x = parsedStyle.x,
        y = parsedStyle.y,
        dx = parsedStyle.dx,
        dy = parsedStyle.dy;
    var offscreenCanvas = (((_b = (_a = object === null || object === void 0 ? void 0 : object.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView) === null || _b === void 0 ? void 0 : _b.getConfig()) || {}).offscreenCanvas;

    if (!this.isReadyToMeasure(parsedStyle, object)) {
      // if (!text || !textAlign || !textBaseline ||) {
      parsedStyle.metrics = {
        font: '',
        width: 0,
        height: 0,
        lines: [],
        lineWidths: [],
        lineHeight: 0,
        maxLineWidth: 0,
        fontProperties: {
          ascent: 0,
          descent: 0,
          fontSize: 0
        },
        lineMetrics: []
      };
      return {
        width: 0,
        height: 0,
        x: 0,
        y: 0,
        offsetX: 0,
        offsetY: 0
      };
    }

    var metrics = this.textService.measureText(text, parsedStyle, offscreenCanvas);
    parsedStyle.metrics = metrics;
    var width = metrics.width,
        height = metrics.height,
        lineHeight = metrics.lineHeight,
        fontProperties = metrics.fontProperties; // anchor is left-top by default

    var halfExtents = fromValues(width / 2, height / 2, 0); // default 'left'

    var anchor = [0, 1];
    var lineXOffset = 0;

    if (textAlign.value === 'center') {
      lineXOffset = lineWidth.value / 2;
      anchor = [0.5, 1];
    } else if (textAlign.value === 'right' || textAlign.value === 'end') {
      lineXOffset = lineWidth.value;
      anchor = [1, 1];
    }

    var lineYOffset = 0;

    if (textBaseline.value === 'middle') {
      // eslint-disable-next-line prefer-destructuring
      lineYOffset = halfExtents[1];
    } else if (textBaseline.value === 'top' || textBaseline.value === 'hanging') {
      lineYOffset = halfExtents[1] * 2;
    } else if (textBaseline.value === 'alphabetic') {
      lineYOffset = lineHeight - fontProperties.ascent;
    } else if (textBaseline.value === 'bottom' || textBaseline.value === 'ideographic') {
      lineYOffset = 0;
    } // TODO: ideographic & bottom


    if (dx) {
      lineXOffset += dx.value;
    }

    if (dy) {
      lineYOffset += dy.value;
    } // update anchor


    parsedStyle.anchor = [new CSSUnitValue(anchor[0]), new CSSUnitValue(anchor[1]), new CSSUnitValue(0)]; // console.log(parsedStyle.anchor);
    // if (!parsedStyle.transformOrigin) {
    //   parsedStyle.transformOrigin = [
    //     // new CSSUnitValue(anchor[0] * 100, '%'),
    //     // new CSSUnitValue(anchor[1] * 100, '%'),
    //     new CSSUnitValue(0, '%'),
    //     new CSSUnitValue(0, '%'),
    //     new CSSUnitValue(0, '%'),
    //   ];
    // }

    return {
      width: halfExtents[0] * 2,
      height: halfExtents[1] * 2,
      x: x.value || 0,
      y: y.value || 0,
      offsetX: lineXOffset,
      offsetY: lineYOffset
    };
  };

  __decorate([inject(TextService), __metadata("design:type", TextService)], TextUpdater.prototype, "textService", void 0);

  TextUpdater = __decorate([singleton({
    token: {
      token: GeometryAABBUpdater,
      named: Shape.TEXT
    }
  })], TextUpdater);
  return TextUpdater;
}();

export { TextUpdater };
