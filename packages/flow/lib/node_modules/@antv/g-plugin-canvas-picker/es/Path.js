import QuadUtil from '../../g-math/es/quadratic.js';
import CubicUtil from '../../g-math/es/cubic.js';
import { inPolygons, inBox, inArc, inLine } from './utils/math.js';
import { fromTranslation, create, multiply, fromRotation, fromScaling } from '../../../gl-matrix/esm/mat3.js';
import { fromValues, transformMat3 } from '../../../gl-matrix/esm/vec2.js';

function isPointInStroke(segments, lineWidth, px, py, length, x, y) {
  var isHit = false;
  var halfWidth = lineWidth / 2;

  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    var currentPoint = segment.currentPoint,
        params = segment.params,
        prePoint = segment.prePoint,
        box = segment.box; // 如果在前面已经生成过包围盒，直接按照包围盒计算

    if (box && !inBox(box.x - halfWidth, box.y - halfWidth, box.width + lineWidth, box.height + lineWidth, px, py)) {
      continue;
    }

    switch (segment.command) {
      // L 和 Z 都是直线， M 不进行拾取
      case 'L':
      case 'Z':
        isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, px, py);
        break;

      case 'Q':
        var qDistance = QuadUtil.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], px, py);
        isHit = qDistance <= lineWidth / 2;
        break;

      case 'C':
        var cDistance = CubicUtil.pointDistance(prePoint[0], // 上一段结束位置, 即 C 的起始点
        prePoint[1], params[1], // 'C' 的参数，1、2 为第一个控制点，3、4 为第二个控制点，5、6 为结束点
        params[2], params[3], params[4], params[5], params[6], px, py, length);
        isHit = cDistance <= lineWidth / 2;
        break;

      case 'A':
        // 计算点到椭圆圆弧的距离，暂时使用近似算法，后面可以改成切割法求最近距离
        var arcParams = segment.arcParams;
        var cx = arcParams.cx,
            cy = arcParams.cy,
            rx = arcParams.rx,
            ry = arcParams.ry,
            startAngle = arcParams.startAngle,
            endAngle = arcParams.endAngle,
            xRotation = arcParams.xRotation;
        var r = rx > ry ? rx : ry;
        var scaleX = rx > ry ? 1 : rx / ry;
        var scaleY = rx > ry ? ry / rx : 1; // const m = transform(null, [
        //   ['t', -cx, -cy],
        //   ['r', -xRotation],
        //   ['s', 1 / scaleX, 1 / scaleY],
        // ]);
        // FIXME

        var m = fromTranslation(create(), [-cx, -cy]);
        multiply(m, fromRotation(create(), -xRotation), m);
        multiply(m, fromScaling(create(), [1 / scaleX, 1 / scaleY]), m);
        var p = fromValues(px, py);
        p = transformMat3(p, p, m); // isHit = inArc(cx, cy, r, startAngle, endAngle, lineWidth, px, py);
        // console.log(m, p[0], px - cx);
        // isHit = inArc(cx, cy, r, startAngle, endAngle, lineWidth, px, py);

        isHit = inArc(0, 0, r, startAngle, endAngle, lineWidth, p[0], p[1]);
        break;
    }

    if (isHit) {
      break;
    }
  }

  return isHit;
}

function isPointInPath(displayObject, position, isPointInPath) {
  var _a = displayObject.parsedStyle,
      lineWidth = _a.lineWidth,
      stroke = _a.stroke,
      fill = _a.fill,
      _b = _a.defX,
      x = _b === void 0 ? 0 : _b,
      _c = _a.defY,
      y = _c === void 0 ? 0 : _c,
      clipPathTargets = _a.clipPathTargets,
      path = _a.path;
  var hasFill = fill && !fill.isNone;
  var hasStroke = stroke && !stroke.isNone;
  var segments = path.segments,
      hasArc = path.hasArc,
      polylines = path.polylines,
      polygons = path.polygons,
      totalLength = path.totalLength;
  var isClipPath = !!(clipPathTargets === null || clipPathTargets === void 0 ? void 0 : clipPathTargets.length);
  var isHit = false;

  if (hasStroke || isClipPath) {
    isHit = isPointInStroke(segments, lineWidth.value, position.x + x, position.y + y, totalLength);
  }

  if (!isHit && (hasFill || isClipPath)) {
    if (hasArc) {
      // 存在曲线时，暂时使用 canvas 的 api 计算，后续可以进行多边形切割
      isHit = isPointInPath(displayObject, position);
    } else {
      // 提取出来的多边形包含闭合的和非闭合的，在这里统一按照多边形处理
      isHit = inPolygons(polygons, position.x + x, position.y + y) || inPolygons(polylines, position.x + x, position.y + y);
    }
  }

  return isHit;
}

export { isPointInPath };
