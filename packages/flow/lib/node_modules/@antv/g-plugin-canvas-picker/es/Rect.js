import { UnitType } from '@antv/g';
import { inBox, inRect, inLine, inArc } from './utils/math.js';

function isPointInPath(displayObject, position, isPointInPath) {
  var _a = displayObject.parsedStyle,
      radius = _a.radius,
      fill = _a.fill,
      stroke = _a.stroke,
      lineWidth = _a.lineWidth,
      parsedWidth = _a.width,
      parsedHeight = _a.height,
      clipPathTargets = _a.clipPathTargets;
  var isClipPath = !!(clipPathTargets === null || clipPathTargets === void 0 ? void 0 : clipPathTargets.length);
  var hasFill = fill && !fill.isNone;
  var hasStroke = stroke && !stroke.isNone;
  var widthUnit = parsedWidth.unit,
      widthValue = parsedWidth.value;
  var heightUnit = parsedHeight.unit,
      heightValue = parsedHeight.value;
  var width = 0;
  var height = 0;

  if (widthUnit === UnitType.kNumber || widthUnit === UnitType.kPixels) {
    width = widthValue;
  }

  if (heightUnit === UnitType.kNumber || heightUnit === UnitType.kPixels) {
    height = heightValue;
  } // 无圆角时的策略


  if (!radius) {
    var halfWidth = lineWidth.value / 2; // 同时填充和带有边框

    if (hasFill && hasStroke || isClipPath) {
      return inBox(0 - halfWidth, 0 - halfWidth, width + halfWidth, height + halfWidth, position.x, position.y);
    } // 仅填充


    if (hasFill) {
      return inBox(0, 0, width, height, position.x, position.y);
    }

    if (hasStroke) {
      return inRect(0, 0, width, height, lineWidth.value, position.x, position.y);
    }
  } else {
    var isHit = false;

    if (hasStroke || isClipPath) {
      isHit = inRectWithRadius(0, 0, width, height, radius.value, lineWidth.value, position.x, position.y);
    } // 仅填充时带有圆角的矩形直接通过图形拾取
    // 以后可以改成纯数学的近似拾取，将圆弧切割成多边形


    if (!isHit && (hasFill || isClipPath)) {
      isHit = isPointInPath(displayObject, position);
    }

    return isHit;
  }

  return false;
}

function inRectWithRadius(minX, minY, width, height, radius, lineWidth, x, y) {
  return inLine(minX + radius, minY, minX + width - radius, minY, lineWidth, x, y) || inLine(minX + width, minY + radius, minX + width, minY + height - radius, lineWidth, x, y) || inLine(minX + width - radius, minY + height, minX + radius, minY + height, lineWidth, x, y) || inLine(minX, minY + height - radius, minX, minY + radius, lineWidth, x, y) || inArc(minX + width - radius, minY + radius, radius, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x, y) || inArc(minX + width - radius, minY + height - radius, radius, 0, 0.5 * Math.PI, lineWidth, x, y) || inArc(minX + radius, minY + height - radius, radius, 0.5 * Math.PI, Math.PI, lineWidth, x, y) || inArc(minX + radius, minY + radius, radius, Math.PI, 1.5 * Math.PI, lineWidth, x, y);
}

export { isPointInPath };
