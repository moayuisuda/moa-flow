import { __extends, __values } from '../../../../../_tslib@2.4.0@tslib/tslib.es6.js';
import { typeCheck, CSSMathVariadic } from './CSSMathVariadic.js';
import { Nested, ParenLess } from './types.js';
import './CSSColorValue.js';
import './CSSKeywordValue.js';
import './CSSMathOperator.js';
import './CSSMathInvert.js';
import './CSSMathMin.js';
import './CSSMathNegate.js';
import './CSSMathProduct.js';
import './CSSMathSum.js';
import './CSSMathValue.js';
import './CSSNumericValue.js';
import { CSSNumericValueType } from './CSSNumericValueType.js';
import './CSSRGB.js';
import './CSSGradientValue.js';
import { CSSStyleValueType } from './CSSStyleValue.js';
import './CSSTransformValue.js';
import './CSSTranslate.js';
import './CSSUnitValue.js';

/**
 * The CSSMathMin interface of the CSS_Object_Model represents the CSS min() function.
 * It inherits properties and methods from its parent CSSNumericValue.
 * @see https://chromium.googlesource.com/chromium/src/+/refs/heads/main/third_party/blink/renderer/core/css/cssom/css_math_min.idl
 * @see https://developer.mozilla.org/en-US/docs/Web/API/CSSMathMax
 */
// @see https://drafts.css-houdini.org/css-typed-om/#cssmathsum

var CSSMathMax =
/** @class */
function (_super) {
  __extends(CSSMathMax, _super);

  function CSSMathMax() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.operator = 'max';
    return _this;
  }

  CSSMathMax.create = function (values) {
    var error = false;
    var final_type = typeCheck(values, CSSNumericValueType.add, error);
    return error ? null : new CSSMathMax(values, final_type);
  };

  CSSMathMax.prototype.clone = function () {
    return new CSSMathMax(this.values, this.type_);
  };

  CSSMathMax.prototype.getType = function () {
    return CSSStyleValueType.kMaxType;
  };

  CSSMathMax.prototype.sumValue = function () {
    var e_1, _a;

    var cur_max = this.numericValues()[0].sumValue();

    if (!cur_max.length) {
      return null;
    }

    try {
      for (var _b = __values(this.numericValues()), _c = _b.next(); !_c.done; _c = _b.next()) {
        var value = _c.value;
        var child_sum = value.sumValue();

        if (!child_sum.length || JSON.stringify(child_sum[0].units) !== JSON.stringify(cur_max[0].units)) {
          return null;
        }

        if (child_sum[0].value < cur_max[0].value) {
          cur_max = child_sum;
        }
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_1) throw e_1.error;
      }
    }

    return cur_max;
  }; // toCalcExpressionNode() {
  //   const operands: CSSMathExpressionOperation[] = [];
  //   for (const value of this.numericValues()) {
  //     const operand = value.toCalcExpressionNode();
  //     if (!operand) {
  //       continue;
  //     }
  //     operands.push(operand as CSSMathExpressionOperation);
  //   }
  //   return CSSMathExpressionOperation.createComparisonFunction(operands, CSSMathOperator.kMax);
  // }


  CSSMathMax.prototype.buildCSSText = function (nested, paren_less, result) {
    var e_2, _a;

    result += 'max(';
    var first_iteration = true;

    try {
      for (var _b = __values(this.numericValues()), _c = _b.next(); !_c.done; _c = _b.next()) {
        var value = _c.value;
        if (!first_iteration) result += ', ';
        first_iteration = false;
        result = value.buildCSSText(Nested.kYes, ParenLess.kYes, result);
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_2) throw e_2.error;
      }
    }

    result += ')';
    return result;
  };

  return CSSMathMax;
}(CSSMathVariadic);

export { CSSMathMax };
