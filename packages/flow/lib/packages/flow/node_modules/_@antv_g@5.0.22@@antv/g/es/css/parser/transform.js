import { UnitType } from '../cssom/types.js';
import '../cssom/CSSColorValue.js';
import '../cssom/CSSKeywordValue.js';
import '../cssom/CSSMathOperator.js';
import '../cssom/CSSMathInvert.js';
import '../cssom/CSSMathMax.js';
import '../cssom/CSSMathMin.js';
import '../cssom/CSSMathNegate.js';
import '../cssom/CSSMathProduct.js';
import '../cssom/CSSMathSum.js';
import '../cssom/CSSMathValue.js';
import '../cssom/CSSMathVariadic.js';
import '../cssom/CSSNumericValue.js';
import '../cssom/CSSNumericValueType.js';
import '../cssom/CSSRGB.js';
import '../cssom/CSSGradientValue.js';
import '../cssom/CSSStyleValue.js';
import '../cssom/CSSTransformValue.js';
import '../cssom/CSSTranslate.js';
import { CSSUnitValue } from '../cssom/CSSUnitValue.js';
import { parseAngle, parseLengthOrPercentage, parseLength, mergeDimensions } from './dimension.js';
import { parseNumber, mergeNumbers } from './numeric.js';
import '../../types.js';
import '../../shapes/Rectangle.js';
import './filter.js';

var _ = null;
var Opx = new CSSUnitValue(0, 'px');
var Odeg = new CSSUnitValue(0, 'deg');

function cast(pattern) {
  return function (contents) {
    var i = 0;
    return pattern.map(function (x) {
      return x === _ ? contents[i++] : x;
    });
  };
}

function id(x) {
  return x;
} // type: [argTypes, convertTo3D, convertTo2D]
// In the argument types string, lowercase characters represent optional arguments


var transformFunctions = {
  // matrix: ['NNNNNN', [_, _, 0, 0, _, _, 0, 0, 0, 0, 1, 0, _, _, 0, 1], id],
  // matrix3d: ['NNNNNNNNNNNNNNNN', id],
  rotate: ['A'],
  rotatex: ['A'],
  rotatey: ['A'],
  rotatez: ['A'],
  rotate3d: ['NNNA'],
  // perspective: ['L'],
  scale: ['Nn', cast([_, _, new CSSUnitValue(1)]), id],
  scalex: ['N', cast([_, new CSSUnitValue(1), new CSSUnitValue(1)]), cast([_, new CSSUnitValue(1)])],
  scaley: ['N', cast([new CSSUnitValue(1), _, new CSSUnitValue(1)]), cast([new CSSUnitValue(1), _])],
  scalez: ['N', cast([new CSSUnitValue(1), new CSSUnitValue(1), _])],
  scale3d: ['NNN', id],
  // skew: ['Aa', null, id],
  // skewx: ['A', null, cast([_, Odeg])],
  // skewy: ['A', null, cast([Odeg, _])],
  translate: ['Tt', cast([_, _, Opx]), id],
  translatex: ['T', cast([_, Opx, Opx]), cast([_, Opx])],
  translatey: ['T', cast([Opx, _, Opx]), cast([Opx, _])],
  translatez: ['L', cast([Opx, Opx, _])],
  translate3d: ['TTL', id]
};
/**
 * none
 * scale(1) scale(1, 2)
 * scaleX(1)
 */

function parseTransform(string) {
  string = string.toLowerCase().trim();

  if (string === 'none') {
    return [];
  }

  var transformRegExp = /\s*(\w+)\(([^)]*)\)/g;
  var result = [];
  var match;
  var prevLastIndex = 0;

  while (match = transformRegExp.exec(string)) {
    if (match.index !== prevLastIndex) {
      return [];
    }

    prevLastIndex = match.index + match[0].length;
    var functionName = match[1]; // scale

    var functionData = transformFunctions[functionName]; // scale(1, 2)

    if (!functionData) {
      // invalid, eg. scale()
      return [];
    }

    var args = match[2].split(','); // 1,2

    var argTypes = functionData[0]; // Nn

    if (argTypes.length < args.length) {
      // scale(N, n)
      return [];
    }

    var parsedArgs = [];

    for (var i = 0; i < argTypes.length; i++) {
      var arg = args[i];
      var type = argTypes[i];
      var parsedArg = void 0;

      if (!arg) {
        // @ts-ignore
        parsedArg = {
          a: Odeg,
          n: parsedArgs[0],
          t: Opx
        }[type];
      } else {
        // @ts-ignore
        parsedArg = {
          A: function A(s) {
            return s.trim() === '0' ? Odeg : parseAngle(s);
          },
          N: parseNumber,
          T: parseLengthOrPercentage,
          L: parseLength
        }[type.toUpperCase()](arg);
      }

      if (parsedArg === undefined) {
        return [];
      }

      parsedArgs.push(parsedArg);
    }

    result.push({
      t: functionName,
      d: parsedArgs
    }); // { t: scale, d: [1, 2] }

    if (transformRegExp.lastIndex === string.length) {
      return result;
    }
  }

  return [];
} // function mergeMatrices(left: number[][], right: number[][]): [
//   number[][], number[][], () => string,
// ] {
//   if (left.decompositionPair !== right) {
//     left.decompositionPair = right;
//     var leftArgs = makeMatrixDecomposition(left);
//   }
//   if (right.decompositionPair !== left) {
//     right.decompositionPair = left;
//     var rightArgs = makeMatrixDecomposition(right);
//   }
//   if (leftArgs[0] === null || rightArgs[0] === null)
//     return [[false], [true], (x) => { return x ? right[0].d : left[0].d; }];
//   leftArgs[0].push(0);
//   rightArgs[0].push(1);
//   return [
//     leftArgs,
//     rightArgs,
//     (list) => {
//       const q = quat(leftArgs[0][3], rightArgs[0][3], list[5]);
//       const mat = composeMatrix(list[0], list[1], list[2], q, list[4]);
//       const stringifiedArgs = mat.map(numberToLongString).join(',');
//       return stringifiedArgs;
//     }
//   ];
// }
// scalex/y/z -> scale

function typeTo2D(type) {
  return type.replace(/[xy]/, '');
} // scalex/y/z -> scale3d


function typeTo3D(type) {
  return type.replace(/(x|y|z|3d)?$/, '3d');
}

var isMatrixOrPerspective = function isMatrixOrPerspective(lt, rt) {
  return lt === 'perspective' && rt === 'perspective' || (lt === 'matrix' || lt === 'matrix3d') && (rt === 'matrix' || rt === 'matrix3d');
};

function mergeTransforms(left, right, target) {
  var flipResults = false; // padding empty transform, eg. merge 'scale(10)' with 'none' -> scale(1)

  if (!left.length || !right.length) {
    if (!left.length) {
      flipResults = true;
      left = right;
      right = [];
    }

    var _loop_1 = function _loop_1(i) {
      var _a = left[i],
          type = _a.t,
          args = _a.d; // none -> scale(1)/translateX(0)

      var defaultValue = type.substr(0, 5) === 'scale' ? 1 : 0;
      right.push({
        t: type,
        d: args.map(function (arg) {
          if (typeof arg === 'number') {
            return new CSSUnitValue(defaultValue);
          }

          return new CSSUnitValue(defaultValue, arg.unit); //   {
          //     unit: arg.unit,
          //     value: defaultValue,
          //   };
        })
      });
    };

    for (var i = 0; i < left.length; i++) {
      _loop_1(i);
    }
  }

  var leftResult = [];
  var rightResult = [];
  var types = []; // merge matrix() with matrix3d()

  if (left.length !== right.length) ; else {
    for (var i = 0; i < left.length; i++) {
      var leftType = left[i].t;
      var rightType = right[i].t;
      var leftArgs = left[i].d;
      var rightArgs = right[i].d;
      var leftFunctionData = transformFunctions[leftType];
      var rightFunctionData = transformFunctions[rightType];
      var type = void 0;

      if (isMatrixOrPerspective(leftType, rightType)) {
        // const merged = mergeMatrices([left[i]], [right[i]]);
        // leftResult.push(merged[0]);
        // rightResult.push(merged[1]);
        // types.push(['matrix', [merged[2]]]);
        continue;
      } else if (leftType === rightType) {
        type = leftType;
      } else if (leftFunctionData[2] && rightFunctionData[2] && typeTo2D(leftType) === typeTo2D(rightType)) {
        type = typeTo2D(leftType); // @ts-ignore

        leftArgs = leftFunctionData[2](leftArgs); // @ts-ignore

        rightArgs = rightFunctionData[2](rightArgs);
      } else if (leftFunctionData[1] && rightFunctionData[1] && typeTo3D(leftType) === typeTo3D(rightType)) {
        type = typeTo3D(leftType); // @ts-ignore

        leftArgs = leftFunctionData[1](leftArgs); // @ts-ignore

        rightArgs = rightFunctionData[1](rightArgs);
      } else {
        // const merged = mergeMatrices(left, right);
        // leftResult = [merged[0]];
        // rightResult = [merged[1]];
        // types = [['matrix', [merged[2]]]];
        break;
      }

      var leftArgsCopy = [];
      var rightArgsCopy = [];
      var stringConversions = [];

      for (var j = 0; j < leftArgs.length; j++) {
        var merge = leftArgs[j].unit === UnitType.kNumber ? mergeNumbers : mergeDimensions; // @ts-ignore

        var merged = merge(leftArgs[j], rightArgs[j], target, false, j);
        leftArgsCopy[j] = merged[0];
        rightArgsCopy[j] = merged[1];
        stringConversions.push(merged[2]);
      }

      leftResult.push(leftArgsCopy);
      rightResult.push(rightArgsCopy);
      types.push([type, stringConversions]);
    }
  }

  if (flipResults) {
    var tmp = leftResult;
    leftResult = rightResult;
    rightResult = tmp;
  }

  return [leftResult, rightResult, function (list) {
    return list.map(function (args, i) {
      var stringifiedArgs = args.map(function (arg, j) {
        return types[i][1][j](arg);
      }).join(',');
      if (types[i][0] === 'matrix' && stringifiedArgs.split(',').length === 16) types[i][0] = 'matrix3d';
      return types[i][0] + '(' + stringifiedArgs + ')';
    }).join(' ');
  }];
}

export { Odeg, Opx, mergeTransforms, parseTransform };
