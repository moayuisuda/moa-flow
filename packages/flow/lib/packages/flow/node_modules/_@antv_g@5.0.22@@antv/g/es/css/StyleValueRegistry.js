import { __decorate, __metadata, __spreadArray, __read } from '../../../../_tslib@2.4.0@tslib/tslib.es6.js';
import { singleton } from '../../../../_mana-syringe@0.3.1@mana-syringe/es/decorator.js';
import { GlobalContainer } from '../../../../_mana-syringe@0.3.1@mana-syringe/es/container.js';
import '../../../../_mana-syringe@0.3.1@mana-syringe/es/core.js';
import '../../../../_mana-syringe@0.3.1@mana-syringe/es/contribution/contribution-protocol.js';
import '../../../../_inversify@5.1.1@inversify/lib/inversify.js';
import '../../../../_mana-syringe@0.3.1@mana-syringe/es/register.js';
import '../../../../_mana-syringe@0.3.1@mana-syringe/es/contribution/index.js';
import { dirtifyToRoot } from '../services/SceneGraphService.js';
import '../services/ContextService.js';
import '../services/RenderingContext.js';
import '../services/RenderingService.js';
import '../services/EventService.js';
import '../services/SceneGraphSelector.js';
import '../services/TextService.js';
import '../services/OffscreenCanvasCreator.js';
import { GeometryUpdaterFactory } from '../services/aabb/interfaces.js';
import '../services/aabb/CircleUpdater.js';
import '../services/aabb/EllipseUpdater.js';
import '../services/aabb/RectUpdater.js';
import '../services/aabb/TextUpdater.js';
import '../services/aabb/LineUpdater.js';
import '../services/aabb/PolylineUpdater.js';
import '../services/aabb/PathUpdater.js';
import { ElementEvent } from '../dom/interfaces.js';
import '../dom/EventTarget.js';
import '../dom/Node.js';
import '../dom/Element.js';
import '../dom/Document.js';
import '../dom/FederatedEvent.js';
import '../dom/FederatedMouseEvent.js';
import '../dom/FederatedPointerEvent.js';
import '../dom/FederatedWheelEvent.js';
import '../dom/Animation.js';
import '../dom/AnimationEvent.js';
import '../dom/AnimationEffectTiming.js';
import '../dom/CustomEvent.js';
import '../dom/MutationEvent.js';
import '../dom/KeyframeEffect.js';
import '../dom/AnimationTimeline.js';
import '../dom/CustomElementRegistry.js';
import { Shape } from '../types.js';
import './cssom/types.js';
import './cssom/CSSColorValue.js';
import { CSSKeywordValue } from './cssom/CSSKeywordValue.js';
import './cssom/CSSMathOperator.js';
import './cssom/CSSMathInvert.js';
import './cssom/CSSMathMax.js';
import './cssom/CSSMathMin.js';
import './cssom/CSSMathNegate.js';
import './cssom/CSSMathProduct.js';
import './cssom/CSSMathSum.js';
import './cssom/CSSMathValue.js';
import './cssom/CSSMathVariadic.js';
import './cssom/CSSNumericValue.js';
import './cssom/CSSNumericValueType.js';
import './cssom/CSSRGB.js';
import './cssom/CSSGradientValue.js';
import { CSSStyleValue } from './cssom/CSSStyleValue.js';
import './cssom/CSSTransformValue.js';
import './cssom/CSSTranslate.js';
import { CSSUnitValue } from './cssom/CSSUnitValue.js';
import { convertPercentUnit } from './parser/dimension.js';
import '../shapes/Rectangle.js';
import './parser/filter.js';
import './parser/transform.js';
import { CSSPropertyLengthOrPercentage } from './properties/CSSPropertyLengthOrPercentage.js';
import { CSSPropertyLocalPosition } from './properties/CSSPropertyLocalPosition.js';
import { CSSPropertyOpacity } from './properties/CSSPropertyOpacity.js';
import { CSSPropertyColor } from './properties/CSSPropertyColor.js';
import { CSSPropertyFilter } from './properties/CSSPropertyFilter.js';
import { CSSPropertyLineDash } from './properties/CSSPropertyLineDash.js';
import { CSSPropertyShadowBlur } from './properties/CSSPropertyShadowBlur.js';
import { CSSPropertyOffsetPath } from './properties/CSSPropertyOffsetPath.js';
import { CSSPropertyOffsetDistance } from './properties/CSSPropertyOffsetDistance.js';
import { CSSPropertyAnchor } from './properties/CSSPropertyAnchor.js';
import { CSSPropertyZIndex } from './properties/CSSPropertyZIndex.js';
import { CSSPropertyTransform } from './properties/CSSPropertyTransform.js';
import { CSSPropertyTransformOrigin } from './properties/CSSPropertyTransformOrigin.js';
import { CSSPropertyPath } from './properties/CSSPropertyPath.js';
import { CSSPropertyPoints } from './properties/CSSPropertyPoints.js';
import { CSSPropertyClipPath } from './properties/CSSPropertyClipPath.js';
import { CSSPropertyText } from './properties/CSSPropertyText.js';
import { CSSPropertyTextTransform } from './properties/CSSPropertyTextTransform.js';
import { formatAttribute } from '../utils/interpolation.js';
import { AABB } from '../shapes/AABB.js';
import '../shapes/BoundingSphere.js';
import '../shapes/Frustum.js';
import '../shapes/Plane.js';
import '../shapes/Ray.js';
import '../shapes/Point.js';
import { __exports as inversify } from '../../../../../../../_virtual/inversify.js';
import { fromValues, add } from '../../../../_gl-matrix@3.4.3@gl-matrix/esm/vec3.js';

var PropertySyntax = {
  COLOR: '<color>',
  PAINT: '<paint>',
  NUMBER: '<number>',
  LENGTH: '<length>',
  PERCENTAGE: '<percentage>',
  LENGTH_PERCENTAGE: '<length> | <percentage>'
};
/**
 * Blink used them in code generation(css_properties.json5)
 */

var BUILT_IN_PROPERTIES = [{
  /**
   * used in CSS Layout API
   * eg. `display: 'flex'`
   */
  name: 'display',
  keywords: ['none']
}, {
  // x in local space
  name: 'x',
  interpolable: true,
  alias: ['cx'],
  defaultValue: '0',
  syntax: PropertySyntax.LENGTH_PERCENTAGE,
  handler: CSSPropertyLocalPosition
}, {
  // y in local space
  name: 'y',
  interpolable: true,
  alias: ['cy'],
  defaultValue: '0',
  syntax: PropertySyntax.LENGTH_PERCENTAGE,
  handler: CSSPropertyLocalPosition
}, {
  // z in local space
  name: 'z',
  interpolable: true,
  defaultValue: '0',
  syntax: PropertySyntax.LENGTH_PERCENTAGE,
  handler: CSSPropertyLocalPosition
}, {
  /**
   * range [0.0, 1.0]
   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/opacity
   */
  name: 'opacity',
  interpolable: true,
  defaultValue: '1',
  syntax: PropertySyntax.NUMBER,
  handler: CSSPropertyOpacity
}, {
  /**
   * range [0.0, 1.0]
   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-opacity
   */
  name: 'fillOpacity',
  interpolable: true,
  inherited: true,
  defaultValue: '1',
  syntax: PropertySyntax.NUMBER,
  handler: CSSPropertyOpacity
}, {
  /**
   * range [0.0, 1.0]
   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-opacity
   */
  name: 'strokeOpacity',
  interpolable: true,
  inherited: true,
  defaultValue: '1',
  syntax: PropertySyntax.NUMBER,
  handler: CSSPropertyOpacity
}, {
  /**
   * background-color is not inheritable
   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Fills_and_Strokes
   */
  name: 'fill',
  interpolable: true,
  keywords: ['none'],
  defaultValue: 'none',
  syntax: PropertySyntax.PAINT,
  handler: CSSPropertyColor
}, {
  name: 'stroke',
  interpolable: true,
  keywords: ['none'],
  defaultValue: 'none',
  syntax: PropertySyntax.PAINT,
  handler: CSSPropertyColor
}, {
  name: 'shadowColor',
  interpolable: true,
  syntax: PropertySyntax.COLOR,
  handler: CSSPropertyColor
}, {
  name: 'shadowOffsetX',
  interpolable: true,
  layoutDependent: true,
  syntax: PropertySyntax.LENGTH_PERCENTAGE,
  handler: CSSPropertyLengthOrPercentage
}, {
  name: 'shadowOffsetY',
  interpolable: true,
  layoutDependent: true,
  syntax: PropertySyntax.LENGTH_PERCENTAGE,
  handler: CSSPropertyLengthOrPercentage
}, {
  name: 'shadowBlur',
  interpolable: true,
  layoutDependent: true,
  handler: CSSPropertyShadowBlur
}, {
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-width
   */
  name: 'lineWidth',
  interpolable: true,
  inherited: true,
  defaultValue: '1',
  layoutDependent: true,
  alias: ['strokeWidth'],
  syntax: PropertySyntax.LENGTH_PERCENTAGE,
  handler: CSSPropertyLengthOrPercentage
}, {
  name: 'lineJoin',
  inherited: true,
  layoutDependent: true,
  alias: ['strokeLinejoin'],
  keywords: ['miter', 'bevel', 'round'],
  defaultValue: 'miter'
}, {
  name: 'lineCap',
  inherited: true,
  layoutDependent: true,
  alias: ['strokeLinecap'],
  keywords: ['butt', 'round', 'square'],
  defaultValue: 'butt'
}, {
  name: 'lineDash',
  interpolable: true,
  inherited: true,
  keywords: ['none'],
  alias: ['strokeDasharray'],
  handler: CSSPropertyLineDash
}, {
  name: 'lineDashOffset',
  interpolable: true,
  inherited: true,
  defaultValue: '0',
  alias: ['strokeDashoffset'],
  handler: CSSPropertyLengthOrPercentage
}, {
  name: 'offsetPath',
  handler: CSSPropertyOffsetPath
}, {
  name: 'offsetDistance',
  interpolable: true,
  handler: CSSPropertyOffsetDistance
}, {
  name: 'dx',
  interpolable: true,
  layoutDependent: true,
  defaultValue: '0',
  handler: CSSPropertyLengthOrPercentage
}, {
  name: 'dy',
  interpolable: true,
  layoutDependent: true,
  defaultValue: '0',
  handler: CSSPropertyLengthOrPercentage
}, {
  name: 'zIndex',
  independent: true,
  interpolable: true,
  defaultValue: '0',
  keywords: ['auto'],
  handler: CSSPropertyZIndex
}, {
  name: 'visibility',
  keywords: ['visible', 'hidden'],
  independent: true,
  inherited: true,

  /**
   * TODO: support interpolation
   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/visibility#interpolation
   */
  // interpolable: true,
  defaultValue: 'visible'
}, {
  name: 'pointerEvents',
  inherited: true,
  keywords: ['none', 'auto', 'stroke', 'fill', 'painted', 'visible', 'visiblestroke', 'visiblefill', 'visiblepainted', 'bounding-box', 'all'],
  defaultValue: 'auto'
}, {
  name: 'filter',
  independent: true,
  layoutDependent: true,
  handler: CSSPropertyFilter
}, {
  name: 'clipPath',
  handler: CSSPropertyClipPath
}, {
  name: 'transform',
  interpolable: true,
  keywords: ['none'],
  defaultValue: 'none',
  handler: CSSPropertyTransform
}, {
  name: 'transformOrigin',
  parsePriority: 100,
  // interpolable: true,
  defaultValue: 'left top',
  layoutDependent: true,
  handler: CSSPropertyTransformOrigin
}, {
  name: 'anchor',
  parsePriority: 99,
  layoutDependent: true,
  handler: CSSPropertyAnchor
}, // Circle
{
  name: 'r',
  interpolable: true,
  layoutDependent: true,
  defaultValue: '0',
  handler: CSSPropertyLengthOrPercentage
}, {
  name: 'rx',
  interpolable: true,
  layoutDependent: true,
  defaultValue: 'auto',
  handler: CSSPropertyLengthOrPercentage
}, {
  name: 'ry',
  interpolable: true,
  layoutDependent: true,
  defaultValue: 'auto',
  handler: CSSPropertyLengthOrPercentage
}, // Rect Image
{
  name: 'width',
  interpolable: true,
  layoutDependent: true,

  /**
   * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/width
   */
  keywords: ['auto', 'fit-content', 'min-content', 'max-content'],
  defaultValue: '0',
  handler: CSSPropertyLengthOrPercentage
}, {
  name: 'height',
  interpolable: true,
  layoutDependent: true,

  /**
   * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/height
   */
  keywords: ['auto', 'fit-content', 'min-content', 'max-content'],
  defaultValue: '0',
  handler: CSSPropertyLengthOrPercentage
}, {
  name: 'radius',
  interpolable: true,
  layoutDependent: true,
  defaultValue: '0',
  handler: CSSPropertyLengthOrPercentage
}, // Line
{
  name: 'x1',
  interpolable: true,
  layoutDependent: true,
  handler: CSSPropertyLocalPosition
}, {
  name: 'y1',
  interpolable: true,
  layoutDependent: true,
  handler: CSSPropertyLocalPosition
}, {
  name: 'z1',
  interpolable: true,
  layoutDependent: true,
  handler: CSSPropertyLocalPosition
}, {
  name: 'x2',
  interpolable: true,
  layoutDependent: true,
  handler: CSSPropertyLocalPosition
}, {
  name: 'y2',
  interpolable: true,
  layoutDependent: true,
  handler: CSSPropertyLocalPosition
}, {
  name: 'z2',
  interpolable: true,
  layoutDependent: true,
  handler: CSSPropertyLocalPosition
}, // Path
{
  name: 'path',
  interpolable: true,
  layoutDependent: true,
  defaultValue: '',
  handler: CSSPropertyPath
}, // Polyline
{
  name: 'points',
  layoutDependent: true,
  handler: CSSPropertyPoints
}, // Text
{
  name: 'text',
  layoutDependent: true,
  handler: CSSPropertyText,
  defaultValue: ''
}, {
  name: 'textTransform',
  layoutDependent: true,
  inherited: true,
  keywords: ['capitalize', 'uppercase', 'lowercase', 'none'],
  defaultValue: 'none',
  handler: CSSPropertyTextTransform
}, {
  name: 'font',
  layoutDependent: true
}, {
  name: 'fontSize',
  interpolable: true,
  inherited: true,

  /**
   * @see https://www.w3schools.com/css/css_font_size.asp
   */
  defaultValue: '16px',
  layoutDependent: true,
  handler: CSSPropertyLengthOrPercentage
}, {
  name: 'fontFamily',
  layoutDependent: true,
  inherited: true,
  defaultValue: 'sans-serif'
}, {
  name: 'fontStyle',
  layoutDependent: true,
  inherited: true,
  keywords: ['normal', 'italic', 'oblique'],
  defaultValue: 'normal'
}, {
  name: 'fontWeight',
  layoutDependent: true,
  inherited: true,
  keywords: ['normal', 'bold', 'bolder', 'lighter'],
  defaultValue: 'normal'
}, {
  name: 'fontVariant',
  layoutDependent: true,
  inherited: true,
  keywords: ['normal', 'small-caps'],
  defaultValue: 'normal'
}, {
  name: 'lineHeight',
  layoutDependent: true // interpolable: true,
  // inherited: true,
  // defaultValue: '-100%'

}, {
  name: 'letterSpacing',
  layoutDependent: true // interpolable: true,
  // inherited: true,
  // defaultValue: '0',

}, {
  name: 'wordWrap',
  layoutDependent: true
}, {
  name: 'wordWrapWidth',
  layoutDependent: true
}, {
  name: 'leading',
  layoutDependent: true
}, {
  name: 'textBaseline',
  layoutDependent: true,
  inherited: true,
  keywords: ['top', 'hanging', 'middle', 'alphabetic', 'ideographic', 'bottom'],
  defaultValue: 'alphabetic'
}, {
  name: 'textAlign',
  layoutDependent: true,
  inherited: true,
  keywords: ['start', 'center', 'end', 'left', 'right'],
  defaultValue: 'start'
}, {
  name: 'whiteSpace',
  layoutDependent: true
}];

var StyleValueRegistry =
/** @class */
function () {
  function StyleValueRegistry() {
    /**
     * need recalc later
     */
    this.dirty = false;
    this.cache = {};
    this.unresolvedProperties = {};
    /**
     * eg.
     *
     * document: {
     *   fontSize: [
     *
     *   ]
     * }
     */

    this.cascadeProperties = {};
  } // private boundsChangeListeners: Record<
  //   /**
  //    * parent's entity
  //    */
  //   number,
  //   Record<
  //     /**
  //      * child's entity
  //      */
  //     number,
  //     /**
  //      * child properties
  //      */
  //     string[]
  //   >
  // > = {};


  StyleValueRegistry.prototype.init = function () {
    var _this = this;

    BUILT_IN_PROPERTIES.forEach(function (property) {
      _this.registerMetadata(property);
    });
  };

  StyleValueRegistry.prototype.registerMetadata = function (metadata) {
    var _this = this;

    __spreadArray([metadata.name], __read(metadata.alias || []), false).forEach(function (name) {
      _this.cache[name] = metadata;
    });
  };

  StyleValueRegistry.prototype.getMetadata = function (name) {
    return this.cache[name];
  };
  /**
   * * parse value, eg.
   * fill: 'red' => CSSRGB
   * translateX: '10px' => CSSUnitValue { unit: 'px', value: 10 }
   * fontSize: '2em' => { unit: 'px', value: 32 }
   *
   * * calculate used value
   * * post process
   */


  StyleValueRegistry.prototype.processProperties = function (object, attributes, options) {
    var _this = this;

    if (options === void 0) {
      options = {
        skipUpdateAttribute: false,
        skipParse: false
      };
    }

    var skipUpdateAttribute = options.skipUpdateAttribute,
        skipParse = options.skipParse;
    var needUpdateGeometry = false;
    Object.keys(attributes).forEach(function (attributeName) {
      var _a;

      var _b = __read(formatAttribute(attributeName, attributes[attributeName]), 2),
          name = _b[0],
          value = _b[1];

      if (!skipUpdateAttribute) {
        object.attributes[name] = value;
      }

      if (!needUpdateGeometry && ((_a = _this.getMetadata(name)) === null || _a === void 0 ? void 0 : _a.layoutDependent)) {
        needUpdateGeometry = true;
      }
    }); // parse according to priority

    var sortedNames = Object.keys(attributes).sort(function (a, b) {
      var _a, _b;

      return (((_a = _this.getMetadata(a)) === null || _a === void 0 ? void 0 : _a.parsePriority) || 0) - (((_b = _this.getMetadata(b)) === null || _b === void 0 ? void 0 : _b.parsePriority) || 0);
    });

    if (!skipParse) {
      sortedNames.forEach(function (name) {
        object.computedStyle[name] = _this.parseProperty(name, object.attributes[name]);
      });
    }

    var hasUnresolvedProperties = false;
    sortedNames.forEach(function (name) {
      // some style props maybe deleted after parsing such as `anchor` in Text
      if (name in object.computedStyle) {
        hasUnresolvedProperties = _this.computeProperty(name, object.computedStyle[name], object);
      }
    });

    if (hasUnresolvedProperties) {
      this.dirty = true;
      return;
    } // update geometry


    if (needUpdateGeometry) {
      this.updateGeometry(object);
    }

    sortedNames.forEach(function (name) {
      if (name in object.parsedStyle) {
        _this.postProcessProperty(name, object);
      }
    });
    sortedNames.forEach(function (name) {
      if (name in object.parsedStyle && _this.isPropertyInheritable(name)) {
        // update children's inheritable
        object.children.forEach(function (child) {
          child.internalSetAttribute(name, null, {
            skipUpdateAttribute: true,
            skipParse: true
          });
        });
      }
    });
  };
  /**
   * string -> parsed value
   */


  StyleValueRegistry.prototype.parseProperty = function (name, value) {
    var metadata = this.getMetadata(name);
    var computed = value;

    if (value === '') {
      value = 'unset';
    }

    if (value === 'unset' || value === 'initial' || value === 'inherit') {
      computed = new CSSKeywordValue(value);
    } else {
      if (metadata) {
        var keywords = metadata.keywords,
            handler = metadata.handler; // use keywords

        if (keywords && keywords.indexOf(value) > -1) {
          computed = new CSSKeywordValue(value);
        } else if (handler) {
          // try to parse value with handler
          var propertyHandler = GlobalContainer.get(handler);

          if (propertyHandler && propertyHandler.parser) {
            // try to parse it to CSSStyleValue, eg. '10px' -> CSS.px(10)
            computed = propertyHandler.parser(value);
          }
        }
      }
    }

    return computed;
  };
  /**
   * computed value -> used value
   */


  StyleValueRegistry.prototype.computeProperty = function (name, computed, object) {
    var metadata = this.getMetadata(name);
    var isDocumentElement = object.id === 'g-root';
    var used = computed instanceof CSSStyleValue ? computed.clone() : computed;

    if (metadata) {
      var handler = metadata.handler,
          inherited = metadata.inherited,
          defaultValue = metadata.defaultValue;

      if (computed instanceof CSSKeywordValue) {
        var value = computed.value;
        /**
         * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/unset
         */

        if (value === 'unset') {
          if (inherited && !isDocumentElement) {
            value = 'inherit';
          } else {
            value = 'initial';
          }
        }

        if (value === 'initial') {
          // @see https://developer.mozilla.org/en-US/docs/Web/CSS/initial
          if (defaultValue) {
            computed = this.parseProperty(name, defaultValue);
          }
        } else if (value === 'inherit') {
          // @see https://developer.mozilla.org/en-US/docs/Web/CSS/inherit
          // behave like `inherit`
          var resolved = this.tryToResolveProperty(object, name, {
            inherited: true
          });

          if (resolved) {
            object.parsedStyle[name] = resolved;
            return false;
          } else {
            this.addUnresolveProperty(object, name);
            return true;
          }
        }
      }

      if (handler) {
        var propertyHandler = GlobalContainer.get(handler); // convert computed value to used value

        if (propertyHandler && propertyHandler.calculator) {
          var oldParsedValue = object.parsedStyle[name];
          used = propertyHandler.calculator(name, oldParsedValue, computed, object, this);
        } else {
          used = computed;
        }
      } else {
        used = computed;
      }
    }

    object.parsedStyle[name] = used;
    return false;
  };

  StyleValueRegistry.prototype.postProcessProperty = function (name, object) {
    var metadata = this.getMetadata(name);

    if (metadata && metadata.handler) {
      var propertyHandler = GlobalContainer.get(metadata.handler);

      if (propertyHandler && propertyHandler.postProcessor) {
        propertyHandler.postProcessor(object);
      }
    }
  };

  StyleValueRegistry.prototype.isPropertyResolved = function (object, name) {
    if (!this.unresolvedProperties[object.entity] || this.unresolvedProperties[object.entity].length === 0) {
      return true;
    }

    return this.unresolvedProperties[object.entity].includes(name);
  };
  /**
   * resolve later
   */


  StyleValueRegistry.prototype.addUnresolveProperty = function (object, name) {
    if (!this.unresolvedProperties[object.entity]) {
      this.unresolvedProperties[object.entity] = [];
    }

    if (this.unresolvedProperties[object.entity].indexOf(name) === -1) {
      this.unresolvedProperties[object.entity].push(name);
    }
  };

  StyleValueRegistry.prototype.tryToResolveProperty = function (object, name, options) {
    if (options === void 0) {
      options = {};
    }

    var inherited = options.inherited;

    if (inherited) {
      if (object.parentElement && this.isPropertyResolved(object.parentElement, name)) {
        var usedValue = object.parentElement.parsedStyle[name];

        if (usedValue instanceof CSSKeywordValue && (usedValue.value === 'unset' || usedValue.value === 'initial' || usedValue.value === 'inherit')) {
          return false;
        } else if (usedValue instanceof CSSUnitValue && CSSUnitValue.isRelativeUnit(usedValue.unit)) {
          return false;
        }

        return usedValue;
      }
    }

    return false;
  };

  StyleValueRegistry.prototype.recalc = function (object) {
    var properties = this.unresolvedProperties[object.entity];

    if (properties && properties.length) {
      var attributes_1 = {};
      properties.forEach(function (property) {
        attributes_1[property] = object.attributes[property];
      });
      this.processProperties(object, attributes_1);
      delete this.unresolvedProperties[object.entity];
    }
  };
  /**
   * update geometry when relative props changed,
   * eg. r of Circle, width/height of Rect
   */


  StyleValueRegistry.prototype.updateGeometry = function (object) {
    var _a;

    var geometryUpdaterFactory = GlobalContainer.get(GeometryUpdaterFactory);
    var geometryUpdater = geometryUpdaterFactory(object.nodeName);

    if (geometryUpdater) {
      var geometry_1 = object.geometry;

      if (!geometry_1.contentBounds) {
        geometry_1.contentBounds = new AABB();
      }

      if (!geometry_1.renderBounds) {
        geometry_1.renderBounds = new AABB();
      }

      var parsedStyle = object.parsedStyle;

      var _b = geometryUpdater.update(parsedStyle, object),
          width = _b.width,
          height = _b.height,
          _c = _b.depth,
          depth = _c === void 0 ? 0 : _c,
          _d = _b.x,
          x = _d === void 0 ? 0 : _d,
          _e = _b.y,
          y = _e === void 0 ? 0 : _e,
          // z = 0,
      _f = _b.offsetX,
          // z = 0,
      offsetX = _f === void 0 ? 0 : _f,
          _g = _b.offsetY,
          offsetY = _g === void 0 ? 0 : _g,
          _h = _b.offsetZ,
          offsetZ = _h === void 0 ? 0 : _h;

      if (object.nodeName === Shape.LINE || object.nodeName === Shape.POLYLINE || object.nodeName === Shape.POLYGON || object.nodeName === Shape.PATH) {
        parsedStyle.offsetX = x - (parsedStyle.defX || 0);
        parsedStyle.offsetY = y - (parsedStyle.defY || 0);
        parsedStyle.defX = x;
        parsedStyle.defY = y; // modify x/y/z

        object.attributes.x += parsedStyle.offsetX;
        object.attributes.y += parsedStyle.offsetY;
        parsedStyle.x = parsedStyle.x.add(new CSSUnitValue(parsedStyle.offsetX, 'px'));
        parsedStyle.y = parsedStyle.y.add(new CSSUnitValue(parsedStyle.offsetY, 'px'));
      } // init with content box


      var halfExtents = fromValues(width / 2, height / 2, depth / 2); // anchor is center by default, don't account for lineWidth here

      var _j = parsedStyle,
          lineWidth = _j.lineWidth,
          shadowColor = _j.shadowColor,
          _k = _j.filter,
          filter = _k === void 0 ? [] : _k,
          transformOrigin = _j.transformOrigin;
      var anchor = parsedStyle.anchor; // <Text> use textAlign & textBaseline instead of anchor

      if (object.nodeName === Shape.TEXT) {
        delete parsedStyle.anchor;
      }

      var center = fromValues((1 - (anchor && anchor[0].value || 0) * 2) * halfExtents[0] + offsetX, (1 - (anchor && anchor[1].value || 0) * 2) * halfExtents[1] + offsetY, (1 - (anchor && ((_a = anchor[2]) === null || _a === void 0 ? void 0 : _a.value) || 0) * 2) * halfExtents[2] + offsetZ); // update geometry's AABB

      geometry_1.contentBounds.update(center, halfExtents);

      if (lineWidth) {
        // append border
        add(halfExtents, halfExtents, fromValues(lineWidth.value / 2, lineWidth.value / 2, 0));
      }

      geometry_1.renderBounds.update(center, halfExtents); // account for shadow, only support constant value now

      if (shadowColor) {
        var _l = geometry_1.renderBounds,
            min = _l.min,
            max = _l.max;
        var _m = parsedStyle,
            shadowBlur = _m.shadowBlur,
            shadowOffsetX = _m.shadowOffsetX,
            shadowOffsetY = _m.shadowOffsetY;
        var shadowBlurInPixels = shadowBlur && shadowBlur.value || 0;
        var shadowOffsetXInPixels = shadowOffsetX && shadowOffsetX.value || 0;
        var shadowOffsetYInPixels = shadowOffsetY && shadowOffsetY.value || 0;
        var shadowLeft = min[0] - shadowBlurInPixels + shadowOffsetXInPixels;
        var shadowRight = max[0] + shadowBlurInPixels + shadowOffsetXInPixels;
        var shadowTop = min[1] - shadowBlurInPixels + shadowOffsetYInPixels;
        var shadowBottom = max[1] + shadowBlurInPixels + shadowOffsetYInPixels;
        min[0] = Math.min(min[0], shadowLeft);
        max[0] = Math.max(max[0], shadowRight);
        min[1] = Math.min(min[1], shadowTop);
        max[1] = Math.max(max[1], shadowBottom);
        geometry_1.renderBounds.setMinMax(min, max);
      } // account for filter, eg. blur(5px), drop-shadow()


      filter.forEach(function (_a) {
        var name = _a.name,
            params = _a.params;

        if (name === 'blur') {
          var blurRadius = params[0].value;
          geometry_1.renderBounds.update(geometry_1.renderBounds.center, add(geometry_1.renderBounds.halfExtents, geometry_1.renderBounds.halfExtents, fromValues(blurRadius, blurRadius, 0)));
        } else if (name === 'drop-shadow') {
          var shadowOffsetX = params[0].value;
          var shadowOffsetY = params[1].value;
          var shadowBlur = params[2].value;
          var _b = geometry_1.renderBounds,
              min = _b.min,
              max = _b.max;
          var shadowLeft = min[0] - shadowBlur + shadowOffsetX;
          var shadowRight = max[0] + shadowBlur + shadowOffsetX;
          var shadowTop = min[1] - shadowBlur + shadowOffsetY;
          var shadowBottom = max[1] + shadowBlur + shadowOffsetY;
          min[0] = Math.min(min[0], shadowLeft);
          max[0] = Math.max(max[0], shadowRight);
          min[1] = Math.min(min[1], shadowTop);
          max[1] = Math.max(max[1], shadowBottom);
          geometry_1.renderBounds.setMinMax(min, max);
        }
      });
      anchor = parsedStyle.anchor; // set transform origin

      var usedOriginXValue = convertPercentUnit(transformOrigin[0], 0, object);
      var usedOriginYValue = convertPercentUnit(transformOrigin[1], 1, object);
      usedOriginXValue -= (anchor && anchor[0].value || 0) * geometry_1.contentBounds.halfExtents[0] * 2;
      usedOriginYValue -= (anchor && anchor[1].value || 0) * geometry_1.contentBounds.halfExtents[1] * 2;
      object.setOrigin(usedOriginXValue, usedOriginYValue);
      object.emit(ElementEvent.GEOMETRY_BOUNDS_CHANGED, {});
      dirtifyToRoot(object);
    }
  };

  StyleValueRegistry.prototype.isPropertyInheritable = function (name) {
    var metadata = this.getMetadata(name);

    if (!metadata) {
      return false;
    }

    return metadata.inherited;
  };

  __decorate([inversify.postConstruct(), __metadata("design:type", Function), __metadata("design:paramtypes", []), __metadata("design:returntype", void 0)], StyleValueRegistry.prototype, "init", null);

  StyleValueRegistry = __decorate([singleton()], StyleValueRegistry);
  return StyleValueRegistry;
}();

export { BUILT_IN_PROPERTIES, PropertySyntax, StyleValueRegistry };
