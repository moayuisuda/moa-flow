import { __extends, __values, __spreadArray, __read } from '../../../../../_tslib@2.4.0@tslib/tslib.es6.js';
import { DCHECK } from '../../utils/assert.js';
import '../../../../../_inversify@5.1.1@inversify/lib/inversify.js';
import '../../../../../_mana-syringe@0.3.1@mana-syringe/es/core.js';
import '../../../../../_mana-syringe@0.3.1@mana-syringe/es/inversify/index.js';
import '../../../../../_mana-syringe@0.3.1@mana-syringe/es/container.js';
import '../../../../../_mana-syringe@0.3.1@mana-syringe/es/contribution/contribution-protocol.js';
import '../../../../../_mana-syringe@0.3.1@mana-syringe/es/register.js';
import '../../../../../_mana-syringe@0.3.1@mana-syringe/es/contribution/index.js';
import { UnitType } from './types.js';
import './CSSColorValue.js';
import './CSSKeywordValue.js';
import { CSSMathOperator } from './CSSMathOperator.js';
import { CSSMathInvert } from './CSSMathInvert.js';
import { CSSMathMax } from './CSSMathMax.js';
import { CSSMathMin } from './CSSMathMin.js';
import { CSSMathNegate } from './CSSMathNegate.js';
import { CSSMathProduct } from './CSSMathProduct.js';
import { CSSMathSum } from './CSSMathSum.js';
import './CSSMathValue.js';
import './CSSMathVariadic.js';
import { BaseType, baseTypeToString } from './CSSNumericValueType.js';
import './CSSRGB.js';
import './CSSGradientValue.js';
import { CSSStyleValueType, CSSStyleValue } from './CSSStyleValue.js';
import './CSSTransformValue.js';
import './CSSTranslate.js';
import { CSSUnitValue } from './CSSUnitValue.js';
import '../parser/dimension.js';
import '../../types.js';
import '../../shapes/Rectangle.js';
import '../parser/filter.js';
import '../parser/transform.js';
import '../properties/CSSPropertyLengthOrPercentage.js';
import '../properties/CSSPropertyLocalPosition.js';
import '../properties/CSSPropertyOpacity.js';
import '../properties/CSSPropertyColor.js';
import '../properties/CSSPropertyFilter.js';
import '../properties/CSSPropertyLineDash.js';
import '../properties/CSSPropertyShadowBlur.js';
import '../properties/CSSPropertyOffsetPath.js';
import '../properties/CSSPropertyOffsetDistance.js';
import '../properties/CSSPropertyAnchor.js';
import '../properties/CSSPropertyZIndex.js';
import '../properties/CSSPropertyTransform.js';
import '../properties/CSSPropertyTransformOrigin.js';
import '../properties/CSSPropertyPath.js';
import '../properties/CSSPropertyPoints.js';
import '../properties/CSSPropertyClipPath.js';
import '../properties/CSSPropertyText.js';
import '../properties/CSSPropertyTextTransform.js';
import '../StyleValueRegistry.js';
import '../LayoutRegistry.js';
import '../../utils/custom-easing.js';

/**
 * CSSNumericValue is the base class for numeric and length typed CSS Values.
 * @see https://drafts.css-houdini.org/css-typed-om/#numeric-objects
 * @see https://developer.mozilla.org/en-US/docs/Web/API/CSSNumericValue
 * @see https://chromium.googlesource.com/chromium/src/+/refs/heads/main/third_party/blink/renderer/core/css/cssom/css_numeric_value.idl
 */

var CSSNumericValue =
/** @class */
function (_super) {
  __extends(CSSNumericValue, _super);

  function CSSNumericValue(type_) {
    var _this = _super.call(this) || this;

    _this.type_ = type_;
    return _this;
  }
  /**
   * @see https://chromium.googlesource.com/chromium/src/+/refs/heads/main/third_party/blink/renderer/core/css/cssom/css_numeric_value.cc#296
   */


  CSSNumericValue.fromNumberish = function (value) {
    if (typeof value === 'number') {
      return new CSSUnitValue(value, UnitType.kNumber);
    }

    return value;
  };

  CSSNumericValue.fromPercentish = function (value) {
    if (typeof value === 'number') {
      return new CSSUnitValue(value * 100, UnitType.kPercentage);
    }

    return value;
  };

  CSSNumericValue.prototype.getType = function () {
    return CSSStyleValueType.kUnknownType;
  }; // toCSSValue() {
  //   return null;
  // }

  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSSNumericValue/equals
   */


  CSSNumericValue.prototype.equals = function () {
    var _this = this;

    var numberishes = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      numberishes[_i] = arguments[_i];
    }

    var values = cssNumberishesToNumericValues(numberishes);
    return values.every(function (value) {
      return _this.equals(value);
    });
  };
  /**
   * @see https://chromium.googlesource.com/chromium/src/+/refs/heads/main/third_party/blink/renderer/core/css/cssom/css_numeric_value.cc#439
   */


  CSSNumericValue.prototype.add = function () {
    var numberishes = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      numberishes[_i] = arguments[_i];
    }

    var values = cssNumberishesToNumericValues(numberishes);
    prependValueForArithmetic(CSSStyleValueType.kSumType, values, this); // eg. 1px + 2px = 3px

    var unitValue = maybeSimplifyAsUnitValue(values, CSSMathOperator.kAdd);

    if (unitValue) {
      return unitValue;
    }

    return CSSMathSum.create(values);
  };
  /**
   * @see https://chromium.googlesource.com/chromium/src/+/refs/heads/main/third_party/blink/renderer/core/css/cssom/css_numeric_value.cc#452
   */


  CSSNumericValue.prototype.sub = function () {
    var numberishes = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      numberishes[_i] = arguments[_i];
    }

    var values = cssNumberishesToNumericValues(numberishes);
    values = values.map(function (value) {
      return value.negate();
    });
    prependValueForArithmetic(CSSStyleValueType.kSumType, values, this); // eg. 3px - 2px = 1px

    var unitValue = maybeSimplifyAsUnitValue(values, CSSMathOperator.kAdd);

    if (unitValue) {
      return unitValue;
    }

    return CSSMathSum.create(values);
  };
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSSNumericValue/mul
   */


  CSSNumericValue.prototype.mul = function () {
    var numberishes = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      numberishes[_i] = arguments[_i];
    }

    var values = cssNumberishesToNumericValues(numberishes);
    prependValueForArithmetic(CSSStyleValueType.kProductType, values, this);
    var unitValue = maybeMultiplyAsUnitValue(values);

    if (unitValue) {
      return unitValue;
    }

    return CSSMathProduct.create(values);
  };
  /**
   * eg. calc(24px / 4%)
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSSNumericValue/div
   */


  CSSNumericValue.prototype.div = function () {
    var numberishes = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      numberishes[_i] = arguments[_i];
    }

    var values = cssNumberishesToNumericValues(numberishes);
    values = values.map(function (value) {
      return value.invert();
    });
    prependValueForArithmetic(CSSStyleValueType.kProductType, values, this);
    var unitValue = maybeMultiplyAsUnitValue(values);

    if (unitValue) {
      return unitValue;
    }

    return CSSMathProduct.create(values);
  };

  CSSNumericValue.prototype.min = function () {
    var numberishes = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      numberishes[_i] = arguments[_i];
    }

    var values = cssNumberishesToNumericValues(numberishes);
    prependValueForArithmetic(CSSStyleValueType.kMinType, values, this);
    var unitValue = maybeSimplifyAsUnitValue(values, CSSMathOperator.kMin);

    if (unitValue) {
      return unitValue;
    }

    return CSSMathMin.create(values);
  };

  CSSNumericValue.prototype.max = function () {
    var numberishes = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      numberishes[_i] = arguments[_i];
    }

    var values = cssNumberishesToNumericValues(numberishes);
    prependValueForArithmetic(CSSStyleValueType.kMaxType, values, this);
    var unitValue = maybeSimplifyAsUnitValue(values, CSSMathOperator.kMax);

    if (unitValue) {
      return unitValue;
    }

    return CSSMathMax.create(values);
  };
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSSNumericValue/to
   * @see https://chromium.googlesource.com/chromium/src/+/refs/heads/main/third_party/blink/renderer/core/css/cssom/css_numeric_value.cc#331
   */


  CSSNumericValue.prototype.to = function (unitOrName) {
    var sum = this.sumValue();
    if (sum.length === 0 || sum.length !== 1) return null;
    var value = cssNumericSumValueEntryToUnitValue(sum[0]);
    if (!value) return null;
    var unit;

    if (typeof unitOrName === 'string') {
      unit = CSSUnitValue.unitFromName(unitOrName);
    } else {
      unit = unitOrName;
    }

    return value.convertTo(unit);
  };
  /**
   * converts the object's value to a CSSMathSum object to values of the specified unit.
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSSNumericValue/toSum
   */


  CSSNumericValue.prototype.toSum = function () {
    var e_1, _a, e_2, _b, e_3, _c;

    var unit_strings = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      unit_strings[_i] = arguments[_i];
    }

    try {
      for (var unit_strings_1 = __values(unit_strings), unit_strings_1_1 = unit_strings_1.next(); !unit_strings_1_1.done; unit_strings_1_1 = unit_strings_1.next()) {
        var unit_string = unit_strings_1_1.value;

        if (!CSSNumericValue.isValidUnit(CSSNumericValue.unitFromName(unit_string))) {
          return null;
        }
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (unit_strings_1_1 && !unit_strings_1_1.done && (_a = unit_strings_1.return)) _a.call(unit_strings_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }

    var sum = this.sumValue();

    if (!sum.length) {
      return null;
    }

    var values = [];

    try {
      for (var sum_1 = __values(sum), sum_1_1 = sum_1.next(); !sum_1_1.done; sum_1_1 = sum_1.next()) {
        var term = sum_1_1.value;
        var value = cssNumericSumValueEntryToUnitValue(term);

        if (!value) {
          return null;
        }

        values.push(value);
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (sum_1_1 && !sum_1_1.done && (_b = sum_1.return)) _b.call(sum_1);
      } finally {
        if (e_2) throw e_2.error;
      }
    }

    if (unit_strings.length === 0) {
      values.sort(function (a, b) {
        return a.unit - b.unit;
      }); // We got 'values' from a sum value, so it must be a valid CSSMathSum.

      var result_1 = CSSMathSum.create(values);
      DCHECK(!!result_1);
      return result_1;
    }

    var result = [];

    var _loop_1 = function _loop_1(unit_string) {
      var target_unit = CSSNumericValue.unitFromName(unit_string);
      DCHECK(CSSNumericValue.isValidUnit(target_unit)); // Collect all the terms that are compatible with this unit.
      // We mark used terms as null so we don't use them again.

      var total_value = values.reduce(function (cur_sum, value, i) {
        if (value) {
          var unit_value = value;
          var converted_value = unit_value.convertTo(target_unit);

          if (converted_value) {
            cur_sum += converted_value.value;
            values[i] = null;
          }
        }

        return cur_sum;
      }, 0);
      result.push(new CSSUnitValue(total_value, target_unit));
    };

    try {
      for (var unit_strings_2 = __values(unit_strings), unit_strings_2_1 = unit_strings_2.next(); !unit_strings_2_1.done; unit_strings_2_1 = unit_strings_2.next()) {
        var unit_string = unit_strings_2_1.value;

        _loop_1(unit_string);
      }
    } catch (e_3_1) {
      e_3 = {
        error: e_3_1
      };
    } finally {
      try {
        if (unit_strings_2_1 && !unit_strings_2_1.done && (_c = unit_strings_2.return)) _c.call(unit_strings_2);
      } finally {
        if (e_3) throw e_3.error;
      }
    }

    if (values.some(function (v) {
      return !!v;
    })) {
      throw new Error('There were leftover terms that were not converted');
    }

    return CSSMathSum.create(result);
  };
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSSNumericValue/type
   * @see https://chromium.googlesource.com/chromium/src/+/refs/heads/main/third_party/blink/renderer/core/css/cssom/css_numeric_value.cc#414
   */


  CSSNumericValue.prototype.type = function () {
    var type = {
      length: 0,
      angle: 0,
      time: 0,
      frequency: 0,
      resolution: 0,
      flex: 0,
      percent: 0,
      percentHint: 'length'
    };
    var exponent = this.type_.exponent(BaseType.kLength);

    if (exponent) {
      type.length = exponent;
    }

    exponent = this.type_.exponent(BaseType.kAngle);

    if (exponent) {
      type.angle = exponent;
    }

    exponent = this.type_.exponent(BaseType.kTime);

    if (exponent) {
      type.time = exponent;
    }

    exponent = this.type_.exponent(BaseType.kFrequency);

    if (exponent) {
      type.frequency = exponent;
    }

    exponent = this.type_.exponent(BaseType.kResolution);

    if (exponent) {
      type.resolution = exponent;
    }

    exponent = this.type_.exponent(BaseType.kFlex);

    if (exponent) {
      type.flex = exponent;
    }

    exponent = this.type_.exponent(BaseType.kPercent);

    if (exponent) {
      type.percent = exponent;
    }

    if (this.type_.hasPercentHint) {
      type.percentHint = baseTypeToString(this.type_.percentHint);
    }

    return type;
  };

  CSSNumericValue.isValidUnit = function (unit) {
    if (unit === UnitType.kUserUnits) return false;
    if (unit === UnitType.kNumber || unit == UnitType.kPercentage || this.isLength(unit) || this.isAngle(unit) || this.isTime(unit) || this.isFrequency(unit) || this.isResolution(unit) || this.isFlex(unit)) return true;
    return false;
  };

  CSSNumericValue.prototype.negate = function () {
    return CSSMathNegate.create(this);
  };

  CSSNumericValue.prototype.invert = function () {
    return CSSMathInvert.create(this);
  };

  return CSSNumericValue;
}(CSSStyleValue);

function cssNumberishesToNumericValues(values) {
  return values.map(CSSNumericValue.fromNumberish);
}

function prependValueForArithmetic(type, values, value) {
  DCHECK(!!value);

  if (value.getType() === type) {
    values.unshift.apply(values, __spreadArray([], __read(value.numericValues()), false));
  } else {
    values.unshift(value);
  }
}

function cssNumericSumValueEntryToUnitValue(term) {
  if (Object.keys(term.units).length === 0) {
    return new CSSUnitValue(term.value);
  }

  if (Object.keys(term.units).length === 1 && term.units[Object.keys(term.units)[0]] === 1) {
    return new CSSUnitValue(term.value, Number(Object.keys(term.units)[0]));
  }

  return null;
}

function maybeSimplifyAsUnitValue(values, operator) {
  DCHECK(!!values.length);
  var first_unit_value = values[0] instanceof CSSUnitValue ? values[0] : null;
  if (!first_unit_value) return null;
  var final_value = first_unit_value.value;

  for (var i = 1; i < values.length; i++) {
    var unit_value = values[i] instanceof CSSUnitValue ? values[i] : null;
    if (!unit_value || unit_value.unit !== first_unit_value.unit) return null;

    if (operator === CSSMathOperator.kAdd) {
      final_value += unit_value.value;
    } else if (operator === CSSMathOperator.kMax) {
      final_value = Math.max(final_value, unit_value.value);
    } else if (operator === CSSMathOperator.kMin) {
      final_value = Math.min(final_value, unit_value.value);
    }
  }

  return new CSSUnitValue(final_value, first_unit_value.unit);
}

function maybeMultiplyAsUnitValue(values) {
  DCHECK(!!values.length); // We are allowed one unit value with type other than kNumber.

  var unit_other_than_number = UnitType.kNumber;
  var final_value = 1.0;

  for (var i = 0; i < values.length; i++) {
    var unit_value = values[i] instanceof CSSUnitValue ? values[i] : null;
    if (!unit_value) return null;

    if (unit_value.unit !== UnitType.kNumber) {
      if (unit_other_than_number !== UnitType.kNumber) return null;
      unit_other_than_number = unit_value.unit;
    }

    final_value *= unit_value.value;
  }

  return new CSSUnitValue(final_value, unit_other_than_number);
}

export { CSSNumericValue };
