import { __decorate, __metadata } from '../../../../_tslib@2.4.0@tslib/tslib.es6.js';
import { inject, singleton } from '../../../../_mana-syringe@0.3.1@mana-syringe/es/decorator.js';
import '../../../../_mana-syringe@0.3.1@mana-syringe/es/container.js';
import '../../../../_mana-syringe@0.3.1@mana-syringe/es/core.js';
import '../../../../_mana-syringe@0.3.1@mana-syringe/es/contribution/contribution-protocol.js';
import '../../../../_inversify@5.1.1@inversify/lib/inversify.js';
import '../../../../_mana-syringe@0.3.1@mana-syringe/es/register.js';
import '../../../../_mana-syringe@0.3.1@mana-syringe/es/contribution/index.js';
import { CullingStrategyContribution } from './CullingPlugin.js';
import { AABB } from '../shapes/AABB.js';
import '../shapes/BoundingSphere.js';
import { Mask } from '../shapes/Frustum.js';
import '../shapes/Plane.js';
import '../shapes/Ray.js';
import '../shapes/Point.js';
import '../shapes/Rectangle.js';
import { DefaultCamera, Camera } from '../camera/Camera.js';
import { Shape } from '../types.js';
import { dot } from '../../../../_gl-matrix@3.4.3@gl-matrix/esm/vec3.js';

var shape2D = [Shape.CIRCLE, Shape.ELLIPSE, Shape.IMAGE, Shape.RECT, Shape.LINE, Shape.POLYLINE, Shape.POLYGON, Shape.TEXT, Shape.PATH, Shape.HTML];

var FrustumCullingStrategy =
/** @class */
function () {
  function FrustumCullingStrategy() {}

  FrustumCullingStrategy.prototype.isVisible = function (object) {
    // return true;
    var _a, _b;

    var cullable = object.cullable;

    if (!cullable.enable) {
      return true;
    }

    var renderBounds = object.getRenderBounds();

    if (AABB.isEmpty(renderBounds)) {
      return false;
    } // get VP matrix from camera


    var frustum = this.camera.getFrustum();
    var parentVisibilityPlaneMask = (_b = (_a = object.parentNode) === null || _a === void 0 ? void 0 : _a.cullable) === null || _b === void 0 ? void 0 : _b.visibilityPlaneMask;
    cullable.visibilityPlaneMask = this.computeVisibilityWithPlaneMask(object, renderBounds, parentVisibilityPlaneMask || Mask.INDETERMINATE, frustum.planes);
    cullable.visible = cullable.visibilityPlaneMask !== Mask.OUTSIDE;
    return cullable.visible;
  };
  /**
   *
   * @see「Optimized View Frustum Culling Algorithms for Bounding Boxes」
   * @see https://github.com/antvis/GWebGPUEngine/issues/3
   *
   * * 基础相交测试 the basic intersection test
   * * 标记 masking @see https://cesium.com/blog/2015/08/04/fast-hierarchical-culling/
   * * TODO: 平面一致性测试 the plane-coherency test
   * * TODO: 支持 mesh 指定自身的剔除策略，参考 Babylon.js @see https://doc.babylonjs.com/how_to/optimizing_your_scene#changing-mesh-culling-strategy
   *
   * @param aabb aabb
   * @param parentPlaneMask mask of parent
   * @param planes planes of frustum
   */


  FrustumCullingStrategy.prototype.computeVisibilityWithPlaneMask = function (object, aabb, parentPlaneMask, planes) {
    if (parentPlaneMask === Mask.OUTSIDE || parentPlaneMask === Mask.INSIDE) {
      // 父节点完全位于视锥内或者外部，直接返回
      return parentPlaneMask;
    } // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.
    // (Because if there are fewer than 31 planes, the upper bits wont be changed.)


    var mask = Mask.INSIDE;
    var isShape2D = shape2D.indexOf(object.nodeName) > -1; // Use viewport culling for 2D shapes
    // @see https://github.com/antvis/g/issues/914

    for (var k = 0, len = planes.length; k < len; ++k) {
      // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.
      var flag = 1 << k;

      if ((parentPlaneMask & flag) === 0) {
        // 父节点处于当前面内部，可以跳过
        continue;
      } // skip near & far planes when testing 2D shapes


      if (isShape2D && (k === 4 || k === 5)) {
        continue;
      } // p-vertex n-vertex <-|plane p-vertex n-vertex
      // 使用 p-vertex 和 n-vertex 加速，避免进行平面和 aabb 全部顶点的相交检测


      var _a = planes[k],
          normal = _a.normal,
          distance = _a.distance;

      if (dot(normal, aabb.getPositiveFarPoint(planes[k])) + distance < 0) {
        return Mask.OUTSIDE;
      }

      if (dot(normal, aabb.getNegativeFarPoint(planes[k])) + distance < 0) {
        // 和当前面相交，对应位置为1，继续检测下一个面
        mask |= flag;
      }
    }

    return mask;
  };

  __decorate([inject(DefaultCamera), __metadata("design:type", Camera)], FrustumCullingStrategy.prototype, "camera", void 0);

  FrustumCullingStrategy = __decorate([singleton({
    contrib: CullingStrategyContribution
  })], FrustumCullingStrategy);
  return FrustumCullingStrategy;
}();

export { FrustumCullingStrategy };
