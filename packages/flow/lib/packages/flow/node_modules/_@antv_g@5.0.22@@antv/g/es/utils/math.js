import { __read } from '../../../../_tslib@2.4.0@tslib/tslib.es6.js';
import isNumber from '../../../../_lodash-es@4.17.21@lodash-es/isNumber.js';
import isArray from '../../../../_lodash-es@4.17.21@lodash-es/isArray.js';
import { fromValues } from '../../../../_gl-matrix@3.4.3@gl-matrix/esm/mat3.js';
import { fromValues as fromValues$1, clone, create } from '../../../../_gl-matrix@3.4.3@gl-matrix/esm/vec3.js';
import { getScaling } from '../../../../_gl-matrix@3.4.3@gl-matrix/esm/mat4.js';

function getAngle(angle) {
  if (angle === undefined) {
    return 0;
  } else if (angle > 360 || angle < -360) {
    return angle % 360;
  }

  return angle;
}
function createVec3(x, y, z) {
  if (y === void 0) {
    y = 0;
  }

  if (z === void 0) {
    z = 0;
  }

  if (isNumber(x)) {
    return fromValues$1(x, y, z);
  }

  if (isArray(x) && x.length === 3) {
    return clone(x);
  }

  return fromValues$1(x[0], x[1] || y, x[2] || z);
}
function rad2deg(rad) {
  return rad * (180 / Math.PI);
}
function turn2deg(turn) {
  return 360 * turn;
}

function getEulerFromQuat(out, quat) {
  var x = quat[0];
  var y = quat[1];
  var z = quat[2];
  var w = quat[3];
  var x2 = x * x;
  var y2 = y * y;
  var z2 = z * z;
  var w2 = w * w;
  var unit = x2 + y2 + z2 + w2;
  var test = x * w - y * z;

  if (test > 0.499995 * unit) {
    // TODO: Use glmatrix.EPSILON
    // singularity at the north pole
    out[0] = Math.PI / 2;
    out[1] = 2 * Math.atan2(y, x);
    out[2] = 0;
  } else if (test < -0.499995 * unit) {
    //TODO: Use glmatrix.EPSILON
    // singularity at the south pole
    out[0] = -Math.PI / 2;
    out[1] = 2 * Math.atan2(y, x);
    out[2] = 0;
  } else {
    out[0] = Math.asin(2 * (x * z - w * y));
    out[1] = Math.atan2(2 * (x * w + y * z), 1 - 2 * (z2 + w2));
    out[2] = Math.atan2(2 * (x * y + z * w), 1 - 2 * (y2 + z2));
  } // TODO: Return them as degrees and not as radians


  return out;
}

function getEulerFromMat4(out, m) {
  var x;
  var z;
  var halfPi = Math.PI * 0.5;

  var _a = __read(getScaling(create(), m), 3),
      sx = _a[0],
      sy = _a[1],
      sz = _a[2];

  var y = Math.asin(-m[2] / sx);

  if (y < halfPi) {
    if (y > -halfPi) {
      x = Math.atan2(m[6] / sy, m[10] / sz);
      z = Math.atan2(m[1] / sx, m[0] / sx);
    } else {
      // Not a unique solution
      z = 0;
      x = -Math.atan2(m[4] / sy, m[5] / sy);
    }
  } else {
    // Not a unique solution
    z = 0;
    x = Math.atan2(m[4] / sy, m[5] / sy);
  }

  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * @see https://github.com/toji/gl-matrix/issues/329
 * @see https://doc.babylonjs.com/divingDeeper/mesh/transforms/center_origin/rotation_conventions
 */


function getEuler(out, quat) {
  if (quat.length === 16) {
    return getEulerFromMat4(out, quat);
  } else {
    return getEulerFromQuat(out, quat);
  }
}
function fromRotationTranslationScale(rotation, x, y, scaleX, scaleY) {
  var cos = Math.cos(rotation);
  var sin = Math.sin(rotation);
  return fromValues(scaleX * cos, scaleY * sin, 0, -scaleX * sin, scaleY * cos, 0, x, y, 1);
}
function makePerspective(out, left, right, top, bottom, near, far) {
  var x = 2 * near / (right - left);
  var y = 2 * near / (top - bottom);
  var a = (right + left) / (right - left);
  var b = (top + bottom) / (top - bottom);
  var c = -(far + near) / (far - near);
  var d = -2 * far * near / (far - near);
  out[0] = x;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = y;
  out[6] = 0;
  out[7] = 0;
  out[8] = a;
  out[9] = b;
  out[10] = c;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = d;
  out[15] = 0;
  return out;
}
function decompose(mat) {
  var row0x = mat[0];
  var row0y = mat[3];
  var row1x = mat[1];
  var row1y = mat[4]; // decompose 3x3 matrix
  // @see https://www.w3.org/TR/css-transforms-1/#decomposing-a-2d-matrix

  var scalingX = Math.sqrt(row0x * row0x + row0y * row0y);
  var scalingY = Math.sqrt(row1x * row1x + row1y * row1y); // If determinant is negative, one axis was flipped.

  var determinant = row0x * row1y - row0y * row1x;

  if (determinant < 0) {
    // Flip axis with minimum unit vector dot product.
    if (row0x < row1y) {
      scalingX = -scalingX;
    } else {
      scalingY = -scalingY;
    }
  } // Renormalize matrix to remove scale.


  if (scalingX) {
    row0x *= 1 / scalingX;
    row0y *= 1 / scalingX;
  }

  if (scalingY) {
    row1x *= 1 / scalingY;
    row1y *= 1 / scalingY;
  } // Compute rotation and renormalize matrix.


  var angle = Math.atan2(row0y, row0x);
  return [mat[6], mat[7], scalingX, scalingY, angle];
}

export { createVec3, decompose, fromRotationTranslationScale, getAngle, getEuler, makePerspective, rad2deg, turn2deg };
