import { AnimationEvent } from './AnimationEvent.js';

var sequenceNumber = 0;
/**
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/Animation
 */

var Animation =
/** @class */
function () {
  function Animation(effect, timeline) {
    this.currentTimePending = false;
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/playState
     */
    // playState: AnimationPlayState;

    this._idle = true;
    this._paused = false;
    this._finishedFlag = true;
    this._currentTime = 0;
    this._playbackRate = 1;
    this._inTimeline = true;
    this.effect = effect;
    effect.animation = this;
    this.timeline = timeline;
    this.id = "".concat(sequenceNumber++);
    this._inEffect = !!this.effect.update(0);
    this._holdTime = 0;
    this._paused = false;
    this.oldPlayState = 'idle';
    this.updatePromises();
  }

  Object.defineProperty(Animation.prototype, "pending", {
    // animation: InternalAnimation | null;

    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/pending
     */
    get: function get() {
      return this._startTime === null && !this._paused && this.playbackRate !== 0 || this.currentTimePending;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Animation.prototype, "playState", {
    get: function get() {
      if (this._idle) return 'idle';
      if (this._isFinished) return 'finished';
      if (this._paused) return 'paused';
      return 'running';
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Animation.prototype, "ready", {
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/ready
     * @example
      animation.pause();
      animation.ready.then(function() {
        // Displays 'running'
        alert(animation.playState);
      });
      animation.play();
     */
    get: function get() {
      var _this = this;

      if (!this.readyPromise) {
        if (this.timeline.animationsWithPromises.indexOf(this) === -1) {
          this.timeline.animationsWithPromises.push(this);
        }

        this.readyPromise = new Promise(function (resolve, reject) {
          _this.resolveReadyPromise = function () {
            resolve(_this);
          };

          _this.rejectReadyPromise = function () {
            reject(new Error());
          };
        });

        if (!this.pending) {
          this.resolveReadyPromise();
        }
      }

      return this.readyPromise;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Animation.prototype, "finished", {
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/finished
     * @example
      Promise.all(
        elem.getAnimations().map(
          function(animation) {
            return animation.finished
          }
        )
      ).then(
        function() {
          return elem.remove();
        }
      );
     */
    get: function get() {
      var _this = this;

      if (!this.finishedPromise) {
        if (this.timeline.animationsWithPromises.indexOf(this) === -1) {
          this.timeline.animationsWithPromises.push(this);
        }

        this.finishedPromise = new Promise(function (resolve, reject) {
          _this.resolveFinishedPromise = function () {
            resolve(_this);
          };

          _this.rejectFinishedPromise = function () {
            reject(new Error());
          };
        });

        if (this.playState === 'finished') {
          this.resolveFinishedPromise();
        }
      }

      return this.finishedPromise;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Animation.prototype, "currentTime", {
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/currentTime
     */
    get: function get() {
      this.updatePromises();
      return this._idle || this.currentTimePending ? null : this._currentTime;
    },
    set: function set(newTime) {
      var _a;

      newTime = Number(newTime);
      if (isNaN(newTime)) return;
      this.timeline.restart();

      if (!this._paused && this._startTime !== null) {
        this._startTime = Number((_a = this.timeline) === null || _a === void 0 ? void 0 : _a.currentTime) - newTime / this.playbackRate;
      }

      this.currentTimePending = false;

      if (this._currentTime === newTime) {
        return;
      }

      if (this._idle) {
        this._idle = false;
        this._paused = true;
      }

      this.tickCurrentTime(newTime, true);
      this.timeline.applyDirtiedAnimation(this);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Animation.prototype, "startTime", {
    get: function get() {
      return this._startTime;
    },
    set: function set(newTime) {
      if (newTime !== null) {
        this.updatePromises();
        newTime = Number(newTime);
        if (isNaN(newTime)) return;
        if (this._paused || this._idle) return;
        this._startTime = newTime;
        this.tickCurrentTime((Number(this.timeline.currentTime) - this._startTime) * this.playbackRate);
        this.timeline.applyDirtiedAnimation(this);
        this.updatePromises();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Animation.prototype, "playbackRate", {
    get: function get() {
      return this._playbackRate;
    },
    set: function set(value) {
      if (value === this._playbackRate) {
        return;
      }

      this.updatePromises();
      var oldCurrentTime = this.currentTime;
      this._playbackRate = value;
      this.startTime = null;

      if (this.playState !== 'paused' && this.playState !== 'idle') {
        this._finishedFlag = false;
        this._idle = false;
        this.ensureAlive();
        this.timeline.applyDirtiedAnimation(this);
      }

      if (oldCurrentTime !== null) {
        this.currentTime = oldCurrentTime;
      }

      this.updatePromises();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Animation.prototype, "_isFinished", {
    get: function get() {
      return !this._idle && (this._playbackRate > 0 && Number(this._currentTime) >= this.totalDuration || this._playbackRate < 0 && Number(this._currentTime) <= 0);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Animation.prototype, "totalDuration", {
    get: function get() {
      var _a;

      return Number((_a = this.effect) === null || _a === void 0 ? void 0 : _a.getComputedTiming().endTime);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Animation.prototype, "_needsTick", {
    get: function get() {
      return this.pending || this.playState === 'running' || !this._finishedFlag;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * state machine,
   * resolve/reject ready/finished Promise according to current state
   */

  Animation.prototype.updatePromises = function () {
    var oldPlayState = this.oldPlayState;
    var newPlayState = this.pending ? 'pending' : this.playState;

    if (this.readyPromise && newPlayState !== oldPlayState) {
      if (newPlayState === 'idle') {
        this.rejectReadyPromise();
        this.readyPromise = undefined;
      } else if (oldPlayState === 'pending') {
        this.resolveReadyPromise();
      } else if (newPlayState === 'pending') {
        this.readyPromise = undefined;
      }
    }

    if (this.finishedPromise && newPlayState !== oldPlayState) {
      if (newPlayState === 'idle') {
        this.rejectFinishedPromise();
        this.finishedPromise = undefined;
      } else if (newPlayState === 'finished') {
        this.resolveFinishedPromise();
      } else if (oldPlayState === 'finished') {
        this.finishedPromise = undefined;
      }
    }

    this.oldPlayState = newPlayState;
    return this.readyPromise || this.finishedPromise;
  };

  Animation.prototype.play = function () {
    this.updatePromises();
    this._paused = false;

    if (this._isFinished || this._idle) {
      this.rewind();
      this._startTime = null;
    }

    this._finishedFlag = false;
    this._idle = false;
    this.ensureAlive();
    this.timeline.applyDirtiedAnimation(this);

    if (this.timeline.animations.indexOf(this) === -1) {
      this.timeline.animations.push(this);
    }

    this.updatePromises();
  };

  Animation.prototype.pause = function () {
    this.updatePromises();

    if (this.currentTime) {
      this._holdTime = this.currentTime;
    }

    if (!this._isFinished && !this._paused && !this._idle) {
      this.currentTimePending = true;
    } else if (this._idle) {
      this.rewind();
      this._idle = false;
    }

    this._startTime = null;
    this._paused = true;
    this.updatePromises();
  };

  Animation.prototype.finish = function () {
    this.updatePromises();
    if (this._idle) return;
    this.currentTime = this._playbackRate > 0 ? this.totalDuration : 0;
    this._startTime = this.totalDuration - this.currentTime;
    this.currentTimePending = false;
    this.timeline.applyDirtiedAnimation(this);
    this.updatePromises();
  };

  Animation.prototype.cancel = function () {
    this.updatePromises();
    if (!this._inEffect) return;
    this._inEffect = false;
    this._idle = true;
    this._paused = false;
    this._finishedFlag = true;
    this._currentTime = 0;
    this._startTime = null;
    this.effect.update(null); // effects are invalid after cancellation as the animation state
    // needs to un-apply.

    this.timeline.applyDirtiedAnimation(this);
    this.updatePromises();
  };

  Animation.prototype.reverse = function () {
    this.updatePromises();
    var oldCurrentTime = this.currentTime;
    this.playbackRate *= -1;
    this.play();

    if (oldCurrentTime !== null) {
      this.currentTime = oldCurrentTime;
    }

    this.updatePromises();
  };
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/updatePlaybackRate
   */


  Animation.prototype.updatePlaybackRate = function (playbackRate) {
    this.playbackRate = playbackRate;
  };

  Animation.prototype.targetAnimations = function () {
    var _a;

    var target = (_a = this.effect) === null || _a === void 0 ? void 0 : _a.target;
    return target.getAnimations();
  };

  Animation.prototype.markTarget = function () {
    var animations = this.targetAnimations();

    if (animations.indexOf(this) === -1) {
      animations.push(this);
    }
  };

  Animation.prototype.unmarkTarget = function () {
    var animations = this.targetAnimations();
    var index = animations.indexOf(this);

    if (index !== -1) {
      animations.splice(index, 1);
    }
  };

  Animation.prototype.tick = function (timelineTime, isAnimationFrame) {
    if (!this._idle && !this._paused) {
      if (this._startTime === null) {
        if (isAnimationFrame) {
          this.startTime = timelineTime - this._currentTime / this.playbackRate;
        }
      } else if (!this._isFinished) {
        this.tickCurrentTime((timelineTime - this._startTime) * this.playbackRate);
      }
    }

    if (isAnimationFrame) {
      this.currentTimePending = false;
      this.fireEvents(timelineTime);
    }
  };

  Animation.prototype.rewind = function () {
    if (this.playbackRate >= 0) {
      this.currentTime = 0;
    } else if (this.totalDuration < Infinity) {
      this.currentTime = this.totalDuration;
    } else {
      throw new Error('Unable to rewind negative playback rate animation with infinite duration');
    }
  };

  Animation.prototype.persist = function () {
    throw new Error('Method not implemented.');
  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars


  Animation.prototype.addEventListener = function (type, listener, options) {
    throw new Error('Method not implemented.');
  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars


  Animation.prototype.removeEventListener = function (type, listener, options) {
    throw new Error('Method not implemented.');
  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars


  Animation.prototype.dispatchEvent = function (event) {
    throw new Error('Method not implemented.');
  }; // replaceState: AnimationReplaceState;


  Animation.prototype.commitStyles = function () {
    throw new Error('Method not implemented.');
  };

  Animation.prototype.ensureAlive = function () {
    var _a, _b; // If an animation is playing backwards and is not fill backwards/both
    // then it should go out of effect when it reaches the start of its
    // active interval (currentTime === 0).


    if (this.playbackRate < 0 && this.currentTime === 0) {
      this._inEffect = !!((_a = this.effect) === null || _a === void 0 ? void 0 : _a.update(-1));
    } else {
      this._inEffect = !!((_b = this.effect) === null || _b === void 0 ? void 0 : _b.update(this.currentTime));
    }

    if (!this._inTimeline && (this._inEffect || !this._finishedFlag)) {
      this._inTimeline = true;
      this.timeline.animations.push(this);
    }
  };

  Animation.prototype.tickCurrentTime = function (newTime, ignoreLimit) {
    if (newTime !== this._currentTime) {
      this._currentTime = newTime;

      if (this._isFinished && !ignoreLimit) {
        this._currentTime = this._playbackRate > 0 ? this.totalDuration : 0;
      }

      this.ensureAlive();
    }
  };

  Animation.prototype.fireEvents = function (baseTime) {
    var _this = this;

    if (this._isFinished) {
      if (!this._finishedFlag) {
        if (this.onfinish) {
          var event_1 = new AnimationEvent(null, this, this.currentTime, baseTime);
          setTimeout(function () {
            if (_this.onfinish) {
              _this.onfinish(event_1);
            }
          });
        }

        this._finishedFlag = true;
      }
    } else {
      if (this.onframe && this.playState === 'running') {
        var event_2 = new AnimationEvent(null, this, this.currentTime, baseTime);
        this.onframe(event_2);
      }

      this._finishedFlag = false;
    }
  };

  return Animation;
}();

export { Animation };
