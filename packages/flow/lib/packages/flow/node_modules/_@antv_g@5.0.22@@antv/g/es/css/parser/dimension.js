import { AABB } from '../../shapes/AABB.js';
import '../../shapes/BoundingSphere.js';
import '../../shapes/Frustum.js';
import '../../shapes/Plane.js';
import '../../shapes/Ray.js';
import '../../shapes/Point.js';
import '../../shapes/Rectangle.js';
import { rad2deg, turn2deg } from '../../utils/math.js';
import '../../../../../_inversify@5.1.1@inversify/lib/inversify.js';
import '../../../../../_mana-syringe@0.3.1@mana-syringe/es/core.js';
import '../../../../../_mana-syringe@0.3.1@mana-syringe/es/inversify/index.js';
import '../../../../../_mana-syringe@0.3.1@mana-syringe/es/container.js';
import '../../../../../_mana-syringe@0.3.1@mana-syringe/es/contribution/contribution-protocol.js';
import '../../../../../_mana-syringe@0.3.1@mana-syringe/es/register.js';
import '../../../../../_mana-syringe@0.3.1@mana-syringe/es/contribution/index.js';
import { UnitType } from '../cssom/types.js';
import '../cssom/CSSColorValue.js';
import '../cssom/CSSKeywordValue.js';
import '../cssom/CSSMathOperator.js';
import '../cssom/CSSMathInvert.js';
import '../cssom/CSSMathMax.js';
import '../cssom/CSSMathMin.js';
import '../cssom/CSSMathNegate.js';
import '../cssom/CSSMathProduct.js';
import '../cssom/CSSMathSum.js';
import '../cssom/CSSMathValue.js';
import '../cssom/CSSMathVariadic.js';
import '../cssom/CSSNumericValue.js';
import '../cssom/CSSNumericValueType.js';
import '../cssom/CSSRGB.js';
import '../cssom/CSSGradientValue.js';
import '../cssom/CSSStyleValue.js';
import '../cssom/CSSTransformValue.js';
import '../cssom/CSSTranslate.js';
import { CSSUnitValue } from '../cssom/CSSUnitValue.js';
import '../../types.js';
import './filter.js';
import './transform.js';
import '../properties/CSSPropertyLengthOrPercentage.js';
import '../properties/CSSPropertyLocalPosition.js';
import '../properties/CSSPropertyOpacity.js';
import '../properties/CSSPropertyColor.js';
import '../properties/CSSPropertyFilter.js';
import '../properties/CSSPropertyLineDash.js';
import '../properties/CSSPropertyShadowBlur.js';
import '../properties/CSSPropertyOffsetPath.js';
import '../properties/CSSPropertyOffsetDistance.js';
import '../properties/CSSPropertyAnchor.js';
import '../properties/CSSPropertyZIndex.js';
import '../properties/CSSPropertyTransform.js';
import '../properties/CSSPropertyTransformOrigin.js';
import '../properties/CSSPropertyPath.js';
import '../properties/CSSPropertyPoints.js';
import '../properties/CSSPropertyClipPath.js';
import '../properties/CSSPropertyText.js';
import '../properties/CSSPropertyTextTransform.js';
import '../StyleValueRegistry.js';
import '../LayoutRegistry.js';
import '../../utils/custom-easing.js';
import isString from '../../../../../_lodash-es@4.17.21@lodash-es/isString.js';

function parseDimension(unitRegExp, string) {
  string = "".concat(string).trim().toLowerCase();

  if (isFinite(Number(string))) {
    if ('px'.search(unitRegExp) >= 0) {
      return new CSSUnitValue(Number(string), 'px');
    }
  }

  var matchedUnits = [];
  string = string.replace(unitRegExp, function (match) {
    matchedUnits.push(match);
    return 'U' + match;
  });
  var taggedUnitRegExp = 'U(' + unitRegExp.source + ')';
  return matchedUnits.map(function (unit) {
    return new CSSUnitValue(Number(string.replace(new RegExp('U' + unit, 'g'), '').replace(new RegExp(taggedUnitRegExp, 'g'), '*0')), unit);
  })[0];
}
/**
 * <length>
 * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/length
 * length with only absolute unit, eg. 1px
 */

var parseLength = parseDimension.bind(null, new RegExp('px', 'g'));
/**
 * <percentage>
 * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/percentage
 */

parseDimension.bind(null, new RegExp('%', 'g'));
/**
 * length with absolute or relative unit,
 * eg. 1px, 0.7em, 50%, calc(100% - 200px);
 *
 * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/length-percentage
 */

var parseLengthOrPercentage = parseDimension.bind(null, new RegExp('px|%|em', 'g'));
var parseAngle = parseDimension.bind(null, new RegExp('deg|rad|grad|turn', 'g'));
/**
 * merge CSSUnitValue
 *
 * @example
 * 10px + 20px = 30px
 * 10deg + 10rad
 */

function mergeDimensions(left, right, target, nonNegative, index) {
  if (index === void 0) {
    index = 0;
  }

  var unit = '';
  var leftValue = left.value || 0;
  var rightValue = right.value || 0; // const canonicalUnit = CSSUnitValue.toCanonicalUnit(left.unit);
  // const leftCanonicalUnitValue = left.convertTo(canonicalUnit);
  // const rightCanonicalUnitValue = right.convertTo(canonicalUnit);
  // format '%' to 'px'

  if (CSSUnitValue.isLength(left.unit) || CSSUnitValue.isLength(right.unit)) {
    leftValue = convertPercentUnit(left, index, target);
    rightValue = convertPercentUnit(right, index, target);
    unit = 'px';
  } // format 'rad' 'turn' to 'deg'


  if (CSSUnitValue.isAngle(left.unit) || CSSUnitValue.isAngle(right.unit)) {
    leftValue = convertAngleUnit(left);
    rightValue = convertAngleUnit(right);
    unit = 'deg';
  }

  return [leftValue, rightValue, function (value) {
    if (nonNegative) {
      value = Math.max(value, 0);
    }

    return value + unit;
  }];
}
function convertAngleUnit(value) {
  var deg = 0;

  if (value.unit === UnitType.kDegrees) {
    deg = value.value;
  } else if (value.unit === UnitType.kRadians) {
    deg = rad2deg(Number(value.value));
  } else if (value.unit === UnitType.kTurns) {
    deg = turn2deg(Number(value.value));
  }

  return deg;
}
function parseDimensionArray(string) {
  if (isString(string)) {
    // "1px 2px 3px"
    return string.split(' ').map(function (segment) {
      return parseLengthOrPercentage(segment);
    });
  } else {
    // [1, '2px', 3]
    return string.map(function (segment) {
      return parseLengthOrPercentage(segment.toString());
    });
  }
}
function mergeDimensionList(left, right, target) {
  if (left.length !== right.length) {
    return;
  }

  var unit = left[0].unit;
  return [left.map(function (l) {
    return l.value;
  }), right.map(function (l) {
    return l.value;
  }), function (values) {
    return values.map(function (n) {
      return new CSSUnitValue(n, unit);
    }).join(' ');
  }];
}
function convertPercentUnit(valueWithUnit, vec3Index, target) {
  if (valueWithUnit.unit === UnitType.kPixels) {
    return Number(valueWithUnit.value);
  } else if (valueWithUnit.unit === UnitType.kPercentage && target) {
    // use bounds
    var bounds = target.getGeometryBounds();
    var size = 0;

    if (!AABB.isEmpty(bounds)) {
      size = bounds.halfExtents[vec3Index] * 2;
    }

    return Number(valueWithUnit.value) / 100 * size;
  }

  return 0;
}

export { convertAngleUnit, convertPercentUnit, mergeDimensionList, mergeDimensions, parseAngle, parseDimension, parseDimensionArray, parseLength, parseLengthOrPercentage };
