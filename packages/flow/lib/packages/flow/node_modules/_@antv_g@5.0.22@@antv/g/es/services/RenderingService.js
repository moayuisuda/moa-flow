import { __decorate, __metadata, __awaiter, __generator } from '../../../../_tslib@2.4.0@tslib/tslib.es6.js';
import { inject, singleton } from '../../../../_mana-syringe@0.3.1@mana-syringe/es/decorator.js';
import '../../../../_mana-syringe@0.3.1@mana-syringe/es/container.js';
import { Syringe } from '../../../../_mana-syringe@0.3.1@mana-syringe/es/core.js';
import '../../../../_mana-syringe@0.3.1@mana-syringe/es/contribution/contribution-protocol.js';
import '../../../../_inversify@5.1.1@inversify/lib/inversify.js';
import '../../../../_mana-syringe@0.3.1@mana-syringe/es/register.js';
import '../../../../_mana-syringe@0.3.1@mana-syringe/es/contribution/index.js';
import { AsyncParallelHook, SyncWaterfallHook, SyncHook, AsyncSeriesWaterfallHook } from '../../../../_tapable@2.2.1@tapable/lib/index.js';
import '../css/cssom/types.js';
import '../css/cssom/CSSColorValue.js';
import '../css/cssom/CSSKeywordValue.js';
import '../css/cssom/CSSMathOperator.js';
import '../css/cssom/CSSMathInvert.js';
import '../css/cssom/CSSMathMax.js';
import '../css/cssom/CSSMathMin.js';
import '../css/cssom/CSSMathNegate.js';
import '../css/cssom/CSSMathProduct.js';
import '../css/cssom/CSSMathSum.js';
import '../css/cssom/CSSMathValue.js';
import '../css/cssom/CSSMathVariadic.js';
import '../css/cssom/CSSNumericValue.js';
import '../css/cssom/CSSNumericValueType.js';
import '../css/cssom/CSSRGB.js';
import '../css/cssom/CSSGradientValue.js';
import '../css/cssom/CSSStyleValue.js';
import '../css/cssom/CSSTransformValue.js';
import '../css/cssom/CSSTranslate.js';
import '../css/cssom/CSSUnitValue.js';
import '../css/parser/dimension.js';
import '../types.js';
import '../shapes/Rectangle.js';
import '../css/parser/filter.js';
import '../css/parser/transform.js';
import '../css/properties/CSSPropertyLengthOrPercentage.js';
import '../css/properties/CSSPropertyLocalPosition.js';
import '../css/properties/CSSPropertyOpacity.js';
import '../css/properties/CSSPropertyColor.js';
import '../css/properties/CSSPropertyFilter.js';
import '../css/properties/CSSPropertyLineDash.js';
import '../css/properties/CSSPropertyShadowBlur.js';
import '../css/properties/CSSPropertyOffsetPath.js';
import '../css/properties/CSSPropertyOffsetDistance.js';
import '../css/properties/CSSPropertyAnchor.js';
import '../css/properties/CSSPropertyZIndex.js';
import '../css/properties/CSSPropertyTransform.js';
import '../css/properties/CSSPropertyTransformOrigin.js';
import '../css/properties/CSSPropertyPath.js';
import '../css/properties/CSSPropertyPoints.js';
import '../css/properties/CSSPropertyClipPath.js';
import '../css/properties/CSSPropertyText.js';
import '../css/properties/CSSPropertyTextTransform.js';
import { StyleValueRegistry } from '../css/StyleValueRegistry.js';
import '../css/LayoutRegistry.js';
import { ElementEvent } from '../dom/interfaces.js';
import '../dom/EventTarget.js';
import '../dom/Node.js';
import '../dom/Element.js';
import '../dom/Document.js';
import '../dom/FederatedEvent.js';
import '../dom/FederatedMouseEvent.js';
import '../dom/FederatedPointerEvent.js';
import '../dom/FederatedWheelEvent.js';
import '../dom/Animation.js';
import '../dom/AnimationEvent.js';
import '../dom/AnimationEffectTiming.js';
import '../dom/CustomEvent.js';
import '../dom/MutationEvent.js';
import '../dom/KeyframeEffect.js';
import '../dom/AnimationTimeline.js';
import '../dom/CustomElementRegistry.js';
import { RenderReason, RenderingContext } from './RenderingContext.js';
import { sortByZIndex, SceneGraphService } from './SceneGraphService.js';
import { contrib } from '../../../../_mana-syringe@0.3.1@mana-syringe/es/contribution/decorator.js';

var RenderingPluginContribution = Syringe.defineToken('RenderingPluginContribution');
/**
 * Use frame renderer implemented by `g-canvas/svg/webgl`, in every frame we do followings:
 * * update & merge dirty rectangles
 * * begin frame
 * * filter by visible
 * * sort by z-index in scene graph
 * * culling with strategies registered in `g-canvas/webgl`
 * * end frame
 */

var RenderingService =
/** @class */
function () {
  function RenderingService() {
    this.inited = false;
    this.stats = {
      /**
       * total display objects in scenegraph
       */
      total: 0,

      /**
       * number of display objects need to render in current frame
       */
      rendered: 0,

      /**
       * number of display objects displayed on screen
       */
      renderedOnscreen: 0
    };
    this.zIndexCounter = 0;
    this.hooks = {
      /**
       * called before any frame rendered
       */
      init: new AsyncParallelHook(),

      /**
       * only dirty object which has sth changed will be rendered
       */
      dirtycheck: new SyncWaterfallHook(['object']),

      /**
       * do culling
       */
      cull: new SyncWaterfallHook(['object']),

      /**
       * called at beginning of each frame, won't get called if nothing to re-render
       */
      beginFrame: new SyncHook([]),

      /**
       * called before every dirty object get rendered
       */
      beforeRender: new SyncHook(['objectToRender']),

      /**
       * called when every dirty object rendering even it's culled
       */
      render: new SyncHook(['objectToRender']),

      /**
       * called after every dirty object get rendered
       */
      afterRender: new SyncHook(['objectToRender']),
      endFrame: new SyncHook([]),
      destroy: new SyncHook([]),

      /**
       * use async but faster method such as GPU-based picking in `g-plugin-webgl-renderer`
       */
      pick: new AsyncSeriesWaterfallHook(['result']),

      /**
       * used in event system
       */
      pointerDown: new SyncHook(['event']),
      pointerUp: new SyncHook(['event']),
      pointerMove: new SyncHook(['event']),
      pointerOut: new SyncHook(['event']),
      pointerOver: new SyncHook(['event']),
      pointerWheel: new SyncHook(['event'])
    };
  }

  RenderingService.prototype.init = function () {
    return __awaiter(this, void 0, void 0, function () {
      var _this = this;

      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            // register rendering plugins
            this.renderingPluginProvider.getContributions({
              cache: false
            }).forEach(function (plugin) {
              plugin.apply(_this);
            });
            return [4
            /*yield*/
            , this.hooks.init.promise()];

          case 1:
            _a.sent();

            this.inited = true;
            return [2
            /*return*/
            ];
        }
      });
    });
  };

  RenderingService.prototype.getStats = function () {
    return this.stats;
  };

  RenderingService.prototype.render = function (canvasConfig) {
    this.stats.total = 0;
    this.stats.rendered = 0;
    this.zIndexCounter = 0;
    this.sceneGraphService.syncHierarchy(this.renderingContext.root);

    if (this.renderingContext.renderReasons.size && this.inited) {
      this.renderDisplayObject(this.renderingContext.root);

      if (this.renderingContext.dirty || canvasConfig.renderer.getConfig().enableDirtyRectangleRendering && this.stats.total === 1) {
        if (!this.renderingContext.dirty) {
          this.hooks.beginFrame.call();
        }

        this.stats.renderedOnscreen = this.stats.rendered;
        this.hooks.endFrame.call();
        this.renderingContext.dirty = false;
      }

      this.renderingContext.renderReasons.clear();
    } // console.log('stats', this.stats);

  };

  RenderingService.prototype.renderDisplayObject = function (displayObject) {
    var _this = this; // recalc style values


    this.styleValueRegistry.recalc(displayObject); // TODO: relayout
    // dirtycheck first

    var objectChanged = this.hooks.dirtycheck.call(displayObject);

    if (objectChanged) {
      // const objectToRender = this.hooks.cull.call(objectChanged);
      this.hooks.cull.call(objectChanged); // if (objectToRender) {

      this.stats.rendered++;

      if (!this.renderingContext.dirty) {
        this.renderingContext.dirty = true;
        this.hooks.beginFrame.call();
      }

      this.hooks.beforeRender.call(objectChanged);
      this.hooks.render.call(objectChanged);
      this.hooks.afterRender.call(objectChanged);
      displayObject.renderable.dirty = false; // }
    }

    displayObject.sortable.renderOrder = this.zIndexCounter++;
    this.stats.total++; // sort is very expensive, use cached result if posible

    var sortable = displayObject.sortable;
    var renderOrderChanged = false;

    if (sortable.dirty) {
      sortable.sorted = displayObject.childNodes.slice().sort(sortByZIndex);
      renderOrderChanged = true;
      sortable.dirty = false;
    } // recursive rendering its children


    (sortable.sorted || displayObject.childNodes).forEach(function (child) {
      _this.renderDisplayObject(child);
    });

    if (renderOrderChanged) {
      displayObject.forEach(function (child) {
        child.emit(ElementEvent.RENDER_ORDER_CHANGED, {
          renderOrder: child.sortable.renderOrder
        });
      });
    }
  };

  RenderingService.prototype.destroy = function () {
    this.inited = false;
    this.hooks.destroy.call();
  };

  RenderingService.prototype.dirtify = function () {
    // need re-render
    this.renderingContext.renderReasons.add(RenderReason.DISPLAY_OBJECT_CHANGED);
  };

  __decorate([contrib(RenderingPluginContribution), __metadata("design:type", Object)], RenderingService.prototype, "renderingPluginProvider", void 0);

  __decorate([inject(RenderingContext), __metadata("design:type", Object)], RenderingService.prototype, "renderingContext", void 0);

  __decorate([inject(SceneGraphService), __metadata("design:type", Object)], RenderingService.prototype, "sceneGraphService", void 0);

  __decorate([inject(StyleValueRegistry), __metadata("design:type", StyleValueRegistry)], RenderingService.prototype, "styleValueRegistry", void 0);

  RenderingService = __decorate([singleton()], RenderingService);
  return RenderingService;
}();

export { RenderingPluginContribution, RenderingService };
