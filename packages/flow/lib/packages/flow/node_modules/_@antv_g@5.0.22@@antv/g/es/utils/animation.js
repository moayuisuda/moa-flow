import { __spreadArray, __read } from '../../../../_tslib@2.4.0@tslib/tslib.es6.js';
import { getEasingFunction } from './custom-easing.js';
import { bezier } from './bezier-easing.js';

var linear = function linear(x) {
  return x;
};
var Start = 1;
var Middle = 0.5;
var End = 0;

function step(count, pos) {
  return function (x) {
    if (x >= 1) {
      return 1;
    }

    var stepSize = 1 / count;
    x += pos * stepSize;
    return x - x % stepSize;
  };
}

var numberString = '\\s*(-?\\d+\\.?\\d*|-?\\.\\d+)\\s*';
var cubicBezierRe = new RegExp('cubic-bezier\\(' + numberString + ',' + numberString + ',' + numberString + ',' + numberString + '\\)');
var step1Re = /steps\(\s*(\d+)\s*\)/;
var step2Re = /steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/;
function parseEasingFunction(normalizedEasing) {
  var cubicData = cubicBezierRe.exec(normalizedEasing);

  if (cubicData) {
    // @ts-ignore
    return bezier.apply(void 0, __spreadArray([], __read(cubicData.slice(1).map(Number)), false));
  }

  var step1Data = step1Re.exec(normalizedEasing);

  if (step1Data) {
    return step(Number(step1Data[1]), End);
  }

  var step2Data = step2Re.exec(normalizedEasing);

  if (step2Data) {
    // @ts-ignore
    return step(Number(step2Data[1]), {
      start: Start,
      middle: Middle,
      end: End
    }[step2Data[2]]);
  }

  return getEasingFunction(normalizedEasing);
}
function calculateActiveDuration(timing) {
  // @ts-ignore
  return Math.abs(repeatedDuration(timing) / (timing.playbackRate || 1));
}

function repeatedDuration(timing) {
  var _a; // https://drafts.csswg.org/web-animations/#calculating-the-active-duration


  if (timing.duration === 0 || timing.iterations === 0) {
    return 0;
  } // @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/duration#value
  // if (timing.duration === 'auto') {
  //   timing.duration = 0;
  // }


  return (timing.duration === 'auto' ? 0 : Number(timing.duration)) * ((_a = timing.iterations) !== null && _a !== void 0 ? _a : 1);
}

var PhaseNone = 0;
var PhaseBefore = 1;
var PhaseAfter = 2;
var PhaseActive = 3;

function calculatePhase(activeDuration, localTime, timing) {
  // https://drafts.csswg.org/web-animations/#animation-effect-phases-and-states
  if (localTime === null) {
    return PhaseNone;
  }

  var endTime = timing.endTime;

  if (localTime < Math.min(timing.delay, endTime)) {
    return PhaseBefore;
  }

  if (localTime >= Math.min(timing.delay + activeDuration + timing.endDelay, endTime)) {
    return PhaseAfter;
  }

  return PhaseActive;
}

function calculateActiveTime(activeDuration, fillMode, localTime, phase, delay) {
  // https://drafts.csswg.org/web-animations/#calculating-the-active-time
  switch (phase) {
    case PhaseBefore:
      if (fillMode === 'backwards' || fillMode === 'both') return 0;
      return null;

    case PhaseActive:
      return localTime - delay;

    case PhaseAfter:
      if (fillMode === 'forwards' || fillMode === 'both') return activeDuration;
      return null;

    case PhaseNone:
      return null;
  }
}

function calculateOverallProgress(iterationDuration, phase, iterations, activeTime, iterationStart) {
  // https://drafts.csswg.org/web-animations/#calculating-the-overall-progress
  var overallProgress = iterationStart;

  if (iterationDuration === 0) {
    if (phase !== PhaseBefore) {
      overallProgress += iterations;
    }
  } else {
    overallProgress += activeTime / iterationDuration;
  }

  return overallProgress;
}

function calculateSimpleIterationProgress(overallProgress, iterationStart, phase, iterations, activeTime, iterationDuration) {
  // https://drafts.csswg.org/web-animations/#calculating-the-simple-iteration-progress
  var simpleIterationProgress = overallProgress === Infinity ? iterationStart % 1 : overallProgress % 1;

  if (simpleIterationProgress === 0 && phase === PhaseAfter && iterations !== 0 && (activeTime !== 0 || iterationDuration === 0)) {
    simpleIterationProgress = 1;
  }

  return simpleIterationProgress;
}

function calculateCurrentIteration(phase, iterations, simpleIterationProgress, overallProgress) {
  // https://drafts.csswg.org/web-animations/#calculating-the-current-iteration
  if (phase === PhaseAfter && iterations === Infinity) {
    return Infinity;
  }

  if (simpleIterationProgress === 1) {
    return Math.floor(overallProgress) - 1;
  }

  return Math.floor(overallProgress);
}

function calculateDirectedProgress(playbackDirection, currentIteration, simpleIterationProgress) {
  // https://drafts.csswg.org/web-animations/#calculating-the-directed-progress
  var currentDirection = playbackDirection;

  if (playbackDirection !== 'normal' && playbackDirection !== 'reverse') {
    var d = currentIteration;

    if (playbackDirection === 'alternate-reverse') {
      d += 1;
    }

    currentDirection = 'normal';

    if (d !== Infinity && d % 2 !== 0) {
      currentDirection = 'reverse';
    }
  }

  if (currentDirection === 'normal') {
    return simpleIterationProgress;
  }

  return 1 - simpleIterationProgress;
}

function calculateIterationProgress(activeDuration, localTime, timing) {
  var phase = calculatePhase(activeDuration, localTime, timing);
  var activeTime = calculateActiveTime(activeDuration, timing.fill, localTime, phase, timing.delay);
  if (activeTime === null) return null;
  var duration = timing.duration === 'auto' ? 0 : timing.duration;
  var overallProgress = calculateOverallProgress(duration, phase, timing.iterations, activeTime, timing.iterationStart);
  var simpleIterationProgress = calculateSimpleIterationProgress(overallProgress, timing.iterationStart, phase, timing.iterations, activeTime, duration);
  var currentIteration = calculateCurrentIteration(phase, timing.iterations, simpleIterationProgress, overallProgress);
  var directedProgress = calculateDirectedProgress(timing.direction, currentIteration, simpleIterationProgress);
  timing.currentIteration = currentIteration;
  timing.progress = directedProgress; // https://drafts.csswg.org/web-animations/#calculating-the-transformed-progress
  // https://drafts.csswg.org/web-animations/#calculating-the-iteration-progress

  return timing.easingFunction(directedProgress);
}

export { calculateActiveDuration, calculateIterationProgress, linear, parseEasingFunction };
