import { __extends, __awaiter, __generator, __decorate, __metadata } from '../../../../_tslib@2.4.0@tslib/tslib.es6.js';
import { inject, singleton } from '../../../../_mana-syringe@0.3.1@mana-syringe/es/decorator.js';
import '../../../../_mana-syringe@0.3.1@mana-syringe/es/container.js';
import '../../../../_mana-syringe@0.3.1@mana-syringe/es/core.js';
import '../../../../_mana-syringe@0.3.1@mana-syringe/es/contribution/contribution-protocol.js';
import '../../../../_inversify@5.1.1@inversify/lib/inversify.js';
import '../../../../_mana-syringe@0.3.1@mana-syringe/es/register.js';
import '../../../../_mana-syringe@0.3.1@mana-syringe/es/contribution/index.js';
import '../../../../_eventemitter3@4.0.7@eventemitter3/index.js';
import { CanvasConfig } from '../types.js';
import { Element } from '../dom/Element.js';
import { Node } from '../dom/Node.js';
import { FederatedMouseEvent } from '../dom/FederatedMouseEvent.js';
import { FederatedPointerEvent } from '../dom/FederatedPointerEvent.js';
import { FederatedWheelEvent } from '../dom/FederatedWheelEvent.js';
import { RenderingContext } from './RenderingContext.js';
import '../shapes/AABB.js';
import '../shapes/BoundingSphere.js';
import '../shapes/Frustum.js';
import '../shapes/Plane.js';
import '../shapes/Ray.js';
import { Point } from '../shapes/Point.js';
import '../shapes/Rectangle.js';
import { ContextService } from './ContextService.js';
import { _ as _eventemitter3_4_0_7_eventemitter3 } from '../../../../../../../_virtual/index4.js';
import { multiply, create } from '../../../../_gl-matrix@3.4.3@gl-matrix/esm/mat4.js';
import { fromValues, transformMat4 } from '../../../../_gl-matrix@3.4.3@gl-matrix/esm/vec3.js';
import { __exports as inversify } from '../../../../../../../_virtual/inversify.js';

var PROPAGATION_LIMIT = 2048;

var EventService =
/** @class */
function (_super) {
  __extends(EventService, _super);

  function EventService() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.cursor = 'default';
    _this.mappingTable = {};
    _this.mappingState = {
      trackingData: {}
    };
    _this.eventPool = new Map();

    _this.onPointerDown = function (from) {
      return __awaiter(_this, void 0, void 0, function () {
        var e, isRightButton, trackingData;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              if (!(from instanceof FederatedPointerEvent)) {
                return [2
                /*return*/
                ];
              }

              return [4
              /*yield*/
              , this.createPointerEvent(from)];

            case 1:
              e = _a.sent();
              this.dispatchEvent(e, 'pointerdown');

              if (e.pointerType === 'touch') {
                // only the
                // if (e.isLast) {
                this.dispatchEvent(e, 'touchstart'); // }
              } else if (e.pointerType === 'mouse' || e.pointerType === 'pen') {
                isRightButton = e.button === 2;
                this.dispatchEvent(e, isRightButton ? 'rightdown' : 'mousedown');
              }

              trackingData = this.trackingData(from.pointerId);
              trackingData.pressTargetsByButton[from.button] = e.composedPath();
              this.freeEvent(e);
              return [2
              /*return*/
              ];
          }
        });
      });
    };

    _this.onPointerUp = function (from) {
      return __awaiter(_this, void 0, void 0, function () {
        var now, e, isRightButton, trackingData, pressTarget, clickTarget, currentTarget, isRightButton, clickEvent, clickHistory;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              if (!(from instanceof FederatedPointerEvent)) {
                return [2
                /*return*/
                ];
              }

              now = performance.now();
              return [4
              /*yield*/
              , this.createPointerEvent(from)];

            case 1:
              e = _a.sent();
              this.dispatchEvent(e, 'pointerup');

              if (e.pointerType === 'touch') {
                this.dispatchEvent(e, 'touchend');
              } else if (e.pointerType === 'mouse' || e.pointerType === 'pen') {
                isRightButton = e.button === 2;
                this.dispatchEvent(e, isRightButton ? 'rightup' : 'mouseup');
              }

              trackingData = this.trackingData(from.pointerId);
              pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
              clickTarget = pressTarget; // pointerupoutside only bubbles. It only bubbles upto the parent that doesn't contain
              // the pointerup location.

              if (pressTarget && !e.composedPath().includes(pressTarget)) {
                currentTarget = pressTarget;

                while (currentTarget && !e.composedPath().includes(currentTarget)) {
                  e.currentTarget = currentTarget;
                  this.notifyTarget(e, 'pointerupoutside');

                  if (e.pointerType === 'touch') {
                    this.notifyTarget(e, 'touchendoutside');
                  } else if (e.pointerType === 'mouse' || e.pointerType === 'pen') {
                    isRightButton = e.button === 2;
                    this.notifyTarget(e, isRightButton ? 'rightupoutside' : 'mouseupoutside');
                  }

                  if (Node.isNode(currentTarget)) {
                    currentTarget = currentTarget.parentNode;
                  }
                }

                delete trackingData.pressTargetsByButton[from.button]; // currentTarget is the most specific ancestor holding both the pointerdown and pointerup
                // targets. That is - it's our click target!

                clickTarget = currentTarget;
              }

              if (clickTarget) {
                clickEvent = this.clonePointerEvent(e, 'click');
                clickEvent.target = clickTarget;
                clickEvent.path = [];

                if (!trackingData.clicksByButton[from.button]) {
                  trackingData.clicksByButton[from.button] = {
                    clickCount: 0,
                    target: clickEvent.target,
                    timeStamp: now
                  };
                }

                clickHistory = trackingData.clicksByButton[from.button];

                if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {
                  ++clickHistory.clickCount;
                } else {
                  clickHistory.clickCount = 1;
                }

                clickHistory.target = clickEvent.target;
                clickHistory.timeStamp = now;
                clickEvent.detail = clickHistory.clickCount;

                if (clickEvent.pointerType === 'mouse' || clickEvent.pointerType === 'touch') {
                  this.dispatchEvent(clickEvent, 'click');
                } else {
                  this.dispatchEvent(clickEvent, 'pointertap');
                }

                this.freeEvent(clickEvent);
              }

              this.freeEvent(e);
              return [2
              /*return*/
              ];
          }
        });
      });
    };

    _this.onPointerMove = function (from) {
      return __awaiter(_this, void 0, void 0, function () {
        var e, isMouse, trackingData, outTarget, outType, outEvent, leaveEvent, overType, overEvent, overTargetAncestor, didPointerEnter, enterEvent;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              if (!(from instanceof FederatedPointerEvent)) {
                return [2
                /*return*/
                ];
              }

              return [4
              /*yield*/
              , this.createPointerEvent(from)];

            case 1:
              e = _a.sent();
              isMouse = e.pointerType === 'mouse' || e.pointerType === 'pen';
              trackingData = this.trackingData(from.pointerId);
              outTarget = this.findMountedTarget(trackingData.overTargets);
              if (!(trackingData.overTargets && outTarget !== e.target)) return [3
              /*break*/
              , 5];
              outType = from.type === 'mousemove' ? 'mouseout' : 'pointerout';
              return [4
              /*yield*/
              , this.createPointerEvent(from, outType, outTarget || undefined)];

            case 2:
              outEvent = _a.sent();
              this.dispatchEvent(outEvent, 'pointerout');
              if (isMouse) this.dispatchEvent(outEvent, 'mouseout');
              if (!!e.composedPath().includes(outTarget)) return [3
              /*break*/
              , 4];
              return [4
              /*yield*/
              , this.createPointerEvent(from, 'pointerleave', outTarget || undefined)];

            case 3:
              leaveEvent = _a.sent();
              leaveEvent.eventPhase = leaveEvent.AT_TARGET;

              while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target)) {
                leaveEvent.currentTarget = leaveEvent.target;
                this.notifyTarget(leaveEvent);
                if (isMouse) this.notifyTarget(leaveEvent, 'mouseleave');

                if (Node.isNode(leaveEvent.target)) {
                  leaveEvent.target = leaveEvent.target.parentNode;
                }
              }

              this.freeEvent(leaveEvent);
              _a.label = 4;

            case 4:
              this.freeEvent(outEvent);
              _a.label = 5;

            case 5:
              // Then pointerover
              if (outTarget !== e.target) {
                overType = from.type === 'mousemove' ? 'mouseover' : 'pointerover';
                overEvent = this.clonePointerEvent(e, overType);
                this.dispatchEvent(overEvent, 'pointerover');
                if (isMouse) this.dispatchEvent(overEvent, 'mouseover');
                overTargetAncestor = outTarget && Node.isNode(outTarget) && outTarget.parentNode;

                while (overTargetAncestor && overTargetAncestor !== (Node.isNode(this.rootTarget) && this.rootTarget.parentNode)) {
                  if (overTargetAncestor === e.target) break;
                  overTargetAncestor = overTargetAncestor.parentNode;
                }

                didPointerEnter = !overTargetAncestor || overTargetAncestor === (Node.isNode(this.rootTarget) && this.rootTarget.parentNode);

                if (didPointerEnter) {
                  enterEvent = this.clonePointerEvent(e, 'pointerenter');
                  enterEvent.eventPhase = enterEvent.AT_TARGET;

                  while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== (Node.isNode(this.rootTarget) && this.rootTarget.parentNode)) {
                    enterEvent.currentTarget = enterEvent.target;
                    this.notifyTarget(enterEvent);
                    if (isMouse) this.notifyTarget(enterEvent, 'mouseenter');

                    if (Node.isNode(enterEvent.target)) {
                      enterEvent.target = enterEvent.target.parentNode;
                    }
                  }

                  this.freeEvent(enterEvent);
                }

                this.freeEvent(overEvent);
              } // Then pointermove


              this.dispatchEvent(e, 'pointermove');
              if (e.pointerType === 'touch') this.dispatchEvent(e, 'touchmove');

              if (isMouse) {
                this.dispatchEvent(e, 'mousemove');
                this.cursor = this.getCursor(e.target);
              }

              trackingData.overTargets = e.composedPath();
              this.freeEvent(e);
              return [2
              /*return*/
              ];
          }
        });
      });
    };

    _this.onPointerOut = function (from) {
      return __awaiter(_this, void 0, void 0, function () {
        var trackingData, isMouse, outTarget, outEvent, leaveEvent;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              if (!(from instanceof FederatedPointerEvent)) {
                return [2
                /*return*/
                ];
              }

              trackingData = this.trackingData(from.pointerId);
              if (!trackingData.overTargets) return [3
              /*break*/
              , 3];
              isMouse = from.pointerType === 'mouse' || from.pointerType === 'pen';
              outTarget = this.findMountedTarget(trackingData.overTargets);
              return [4
              /*yield*/
              , this.createPointerEvent(from, 'pointerout', outTarget || undefined)];

            case 1:
              outEvent = _a.sent();
              this.dispatchEvent(outEvent);
              if (isMouse) this.dispatchEvent(outEvent, 'mouseout');
              return [4
              /*yield*/
              , this.createPointerEvent(from, 'pointerleave', outTarget || undefined)];

            case 2:
              leaveEvent = _a.sent();
              leaveEvent.eventPhase = leaveEvent.AT_TARGET;

              while (leaveEvent.target && leaveEvent.target !== (Node.isNode(this.rootTarget) && this.rootTarget.parentNode)) {
                leaveEvent.currentTarget = leaveEvent.target;
                this.notifyTarget(leaveEvent);
                if (isMouse) this.notifyTarget(leaveEvent, 'mouseleave');

                if (Node.isNode(leaveEvent.target)) {
                  leaveEvent.target = leaveEvent.target.parentNode;
                }
              }

              trackingData.overTargets = null;
              this.freeEvent(outEvent);
              this.freeEvent(leaveEvent);
              _a.label = 3;

            case 3:
              this.cursor = null;
              return [2
              /*return*/
              ];
          }
        });
      });
    };

    _this.onPointerOver = function (from) {
      return __awaiter(_this, void 0, void 0, function () {
        var trackingData, e, isMouse, enterEvent;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              if (!(from instanceof FederatedPointerEvent)) {
                return [2
                /*return*/
                ];
              }

              trackingData = this.trackingData(from.pointerId);
              return [4
              /*yield*/
              , this.createPointerEvent(from)];

            case 1:
              e = _a.sent();
              isMouse = e.pointerType === 'mouse' || e.pointerType === 'pen';
              this.dispatchEvent(e, 'pointerover');
              if (isMouse) this.dispatchEvent(e, 'mouseover');
              if (e.pointerType === 'mouse') this.cursor = this.getCursor(e.target);
              enterEvent = this.clonePointerEvent(e, 'pointerenter');
              enterEvent.eventPhase = enterEvent.AT_TARGET;

              while (enterEvent.target && enterEvent.target !== (Node.isNode(this.rootTarget) && this.rootTarget.parentNode)) {
                enterEvent.currentTarget = enterEvent.target;
                this.notifyTarget(enterEvent);

                if (isMouse) {
                  // mouseenter should not bubble
                  // @see https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseenter_event#usage_notes
                  this.notifyTarget(enterEvent, 'mouseenter');
                }

                if (Node.isNode(enterEvent.target)) {
                  enterEvent.target = enterEvent.target.parentNode;
                }
              }

              trackingData.overTargets = e.composedPath();
              this.freeEvent(e);
              this.freeEvent(enterEvent);
              return [2
              /*return*/
              ];
          }
        });
      });
    };

    _this.onPointerUpOutside = function (from) {
      return __awaiter(_this, void 0, void 0, function () {
        var trackingData, pressTarget, e, currentTarget;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              if (!(from instanceof FederatedPointerEvent)) {
                return [2
                /*return*/
                ];
              }

              trackingData = this.trackingData(from.pointerId);
              pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
              return [4
              /*yield*/
              , this.createPointerEvent(from)];

            case 1:
              e = _a.sent();

              if (pressTarget) {
                currentTarget = pressTarget;

                while (currentTarget) {
                  e.currentTarget = currentTarget;
                  this.notifyTarget(e, 'pointerupoutside');

                  if (e.pointerType === 'touch') {
                    this.notifyTarget(e, 'touchendoutside');
                  } else if (e.pointerType === 'mouse' || e.pointerType === 'pen') {
                    this.notifyTarget(e, e.button === 2 ? 'rightupoutside' : 'mouseupoutside');
                  }

                  if (Node.isNode(currentTarget)) {
                    currentTarget = currentTarget.parentNode;
                  }
                }

                delete trackingData.pressTargetsByButton[from.button];
              }

              this.freeEvent(e);
              return [2
              /*return*/
              ];
          }
        });
      });
    };

    _this.onWheel = function (from) {
      return __awaiter(_this, void 0, void 0, function () {
        var wheelEvent;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              if (!(from instanceof FederatedWheelEvent)) {
                return [2
                /*return*/
                ];
              }

              return [4
              /*yield*/
              , this.createWheelEvent(from)];

            case 1:
              wheelEvent = _a.sent();
              this.dispatchEvent(wheelEvent);
              this.freeEvent(wheelEvent);
              return [2
              /*return*/
              ];
          }
        });
      });
    };

    return _this;
  }

  EventService.prototype.init = function () {
    this.rootTarget = this.renderingContext.root.parentNode; // document

    this.addEventMapping('pointerdown', this.onPointerDown);
    this.addEventMapping('pointerup', this.onPointerUp);
    this.addEventMapping('pointermove', this.onPointerMove);
    this.addEventMapping('pointerout', this.onPointerOut);
    this.addEventMapping('pointerleave', this.onPointerOut);
    this.addEventMapping('pointerover', this.onPointerOver);
    this.addEventMapping('pointerupoutside', this.onPointerUpOutside);
    this.addEventMapping('wheel', this.onWheel);
  };

  EventService.prototype.client2Viewport = function (client) {
    var bbox = this.contextService.getBoundingClientRect();
    return new Point(client.x - ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0), client.y - ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0));
  };

  EventService.prototype.viewport2Client = function (canvas) {
    var bbox = this.contextService.getBoundingClientRect();
    return new Point(canvas.x + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0), canvas.y + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0));
  };

  EventService.prototype.viewport2Canvas = function (_a) {
    var x = _a.x,
        y = _a.y;
    var canvas = this.rootTarget.defaultView;
    var camera = canvas.getCamera();
    var _b = this.canvasConfig,
        width = _b.width,
        height = _b.height;
    var projectionMatrixInverse = camera.getPerspectiveInverse();
    var worldMatrix = camera.getWorldTransform();
    var vpMatrix = multiply(create(), worldMatrix, projectionMatrixInverse);
    var viewport = fromValues(x / width * 2 - 1, (1 - y / height) * 2 - 1, 0);
    transformMat4(viewport, viewport, vpMatrix);
    return new Point(viewport[0], viewport[1]);
  };

  EventService.prototype.canvas2Viewport = function (canvasP) {
    var canvas = this.rootTarget.defaultView;
    var camera = canvas.getCamera(); // World -> Clip

    var projectionMatrix = camera.getPerspective();
    var viewMatrix = camera.getViewTransform();
    var vpMatrix = multiply(create(), projectionMatrix, viewMatrix);
    var clip = fromValues(canvasP.x, canvasP.y, 0);
    transformMat4(clip, clip, vpMatrix); // Clip -> NDC -> Viewport, flip Y

    var _a = this.canvasConfig,
        width = _a.width,
        height = _a.height;
    return new Point((clip[0] + 1) / 2 * width, (1 - (clip[1] + 1) / 2) * height);
  };

  EventService.prototype.setPickHandler = function (pickHandler) {
    this.pickHandler = pickHandler;
  };

  EventService.prototype.addEventMapping = function (type, fn) {
    if (!this.mappingTable[type]) {
      this.mappingTable[type] = [];
    }

    this.mappingTable[type].push({
      fn: fn,
      priority: 0
    });
    this.mappingTable[type].sort(function (a, b) {
      return a.priority - b.priority;
    });
  };

  EventService.prototype.mapEvent = function (e) {
    if (!this.rootTarget) {
      return;
    }

    var mappers = this.mappingTable[e.type];

    if (mappers) {
      for (var i = 0, j = mappers.length; i < j; i++) {
        mappers[i].fn(e);
      }
    } else {
      console.warn("[EventService]: Event mapping not defined for ".concat(e.type));
    }
  };

  EventService.prototype.dispatchEvent = function (e, type) {
    e.propagationStopped = false;
    e.propagationImmediatelyStopped = false;
    this.propagate(e, type);
    this.emit(type || e.type, e);
  };

  EventService.prototype.propagate = function (e, type) {
    if (!e.target) {
      return;
    } // [target, parent, root, Canvas]


    var composedPath = e.composedPath(); // event flow: capture -> target -> bubbling
    // capture phase

    e.eventPhase = e.CAPTURING_PHASE;

    for (var i = composedPath.length - 1; i >= 1; i--) {
      e.currentTarget = composedPath[i];
      this.notifyTarget(e, type);
      if (e.propagationStopped || e.propagationImmediatelyStopped) return;
    } // target phase


    e.eventPhase = e.AT_TARGET;
    e.currentTarget = e.target;
    this.notifyTarget(e, type);
    if (e.propagationStopped || e.propagationImmediatelyStopped) return; // find current target in composed path

    var index = composedPath.indexOf(e.currentTarget); // bubbling phase

    e.eventPhase = e.BUBBLING_PHASE;

    for (var i = index + 1; i < composedPath.length; i++) {
      e.currentTarget = composedPath[i];
      this.notifyTarget(e, type);
      if (e.propagationStopped || e.propagationImmediatelyStopped) return;
    }
  };

  EventService.prototype.propagationPath = function (target) {
    var propagationPath = [target];
    var canvas = this.rootTarget.defaultView || null;

    if (canvas && canvas === target) {
      propagationPath.unshift(canvas.document);
      return propagationPath;
    }

    for (var i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget; i++) {
      // if (Node.isNode(target) && !target.parentNode) {
      //   throw new Error('Cannot find propagation path to disconnected target');
      // }
      if (Node.isNode(target) && target.parentNode) {
        // [target, parent, parent, root]
        propagationPath.push(target.parentNode);
        target = target.parentNode;
      }
    }

    if (canvas) {
      // @ts-ignore
      propagationPath.push(canvas);
    }

    return propagationPath;
  };

  EventService.prototype.hitTest = function (position) {
    return __awaiter(this, void 0, void 0, function () {
      var viewportX, viewportY, _a, width, height;

      return __generator(this, function (_b) {
        switch (_b.label) {
          case 0:
            viewportX = position.viewportX, viewportY = position.viewportY;
            _a = this.canvasConfig, width = _a.width, height = _a.height; // outside canvas

            if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
              return [2
              /*return*/
              , null];
            }

            return [4
            /*yield*/
            , this.pickHandler(position)];

          case 1:
            return [2
            /*return*/
            , _b.sent() || this.rootTarget || // return Document
            null];
        }
      });
    });
  };

  EventService.prototype.isNativeEventFromCanvas = function (event) {
    var _a;

    var $el = this.contextService.getDomElement();
    var target = (_a = event.nativeEvent) === null || _a === void 0 ? void 0 : _a.target;

    if (target) {
      if (target === $el) {
        return true;
      }

      if ($el && $el.contains) {
        return $el.contains(target);
      }
    }

    if (event.nativeEvent.composedPath) {
      return event.nativeEvent.composedPath().indexOf($el) > -1;
    } // account for Touch


    return false;
  };

  EventService.prototype.createPointerEvent = function (from, type, target) {
    return __awaiter(this, void 0, void 0, function () {
      var event, isFromCanvas, _a, _b, _c;

      return __generator(this, function (_d) {
        switch (_d.label) {
          case 0:
            event = this.allocateEvent(FederatedPointerEvent);
            this.copyPointerData(from, event);
            this.copyMouseData(from, event);
            this.copyData(from, event);
            event.nativeEvent = from.nativeEvent;
            isFromCanvas = this.isNativeEventFromCanvas(event);
            event.originalEvent = from;
            _a = event;
            if (!(target !== null && target !== void 0)) return [3
            /*break*/
            , 1];
            _b = target;
            return [3
            /*break*/
            , 4];

          case 1:
            _c = isFromCanvas;
            if (!_c) return [3
            /*break*/
            , 3];
            return [4
            /*yield*/
            , this.hitTest({
              clientX: event.clientX,
              clientY: event.clientY,
              viewportX: event.viewportX,
              viewportY: event.viewportY,
              x: event.global.x,
              y: event.global.y
            })];

          case 2:
            _c = _d.sent();
            _d.label = 3;

          case 3:
            _b = _c;
            _d.label = 4;

          case 4:
            _a.target = _b;

            if (typeof type === 'string') {
              event.type = type;
            }

            return [2
            /*return*/
            , event];
        }
      });
    });
  };

  EventService.prototype.createWheelEvent = function (from) {
    return __awaiter(this, void 0, void 0, function () {
      var event, isFromCanvas, _a, _b;

      return __generator(this, function (_c) {
        switch (_c.label) {
          case 0:
            event = this.allocateEvent(FederatedWheelEvent);
            this.copyWheelData(from, event);
            this.copyMouseData(from, event);
            this.copyData(from, event);
            event.nativeEvent = from.nativeEvent;
            event.originalEvent = from;
            isFromCanvas = this.isNativeEventFromCanvas(event);
            _a = event;
            _b = isFromCanvas;
            if (!_b) return [3
            /*break*/
            , 2];
            return [4
            /*yield*/
            , this.hitTest({
              clientX: event.clientX,
              clientY: event.clientY,
              viewportX: event.viewportX,
              viewportY: event.viewportY,
              x: event.global.x,
              y: event.global.y
            })];

          case 1:
            _b = _c.sent();
            _c.label = 2;

          case 2:
            _a.target = _b;
            return [2
            /*return*/
            , event];
        }
      });
    });
  };

  EventService.prototype.trackingData = function (id) {
    if (!this.mappingState.trackingData[id]) {
      this.mappingState.trackingData[id] = {
        pressTargetsByButton: {},
        clicksByButton: {},
        overTarget: null
      };
    }

    return this.mappingState.trackingData[id];
  };

  EventService.prototype.clonePointerEvent = function (from, type) {
    var event = this.allocateEvent(FederatedPointerEvent);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from.originalEvent;
    this.copyPointerData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.target = from.target;
    event.path = from.composedPath().slice();
    event.type = type !== null && type !== void 0 ? type : event.type;
    return event;
  };

  EventService.prototype.copyPointerData = function (from, to) {
    if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent)) return;
    to.pointerId = from.pointerId;
    to.width = from.width;
    to.height = from.height;
    to.isPrimary = from.isPrimary;
    to.pointerType = from.pointerType;
    to.pressure = from.pressure;
    to.tangentialPressure = from.tangentialPressure;
    to.tiltX = from.tiltX;
    to.tiltY = from.tiltY;
    to.twist = from.twist;
  };

  EventService.prototype.copyMouseData = function (from, to) {
    if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent)) return;
    to.altKey = from.altKey;
    to.button = from.button;
    to.buttons = from.buttons;
    to.ctrlKey = from.ctrlKey;
    to.metaKey = from.metaKey;
    to.client.copyFrom(from.client);
    to.movement.copyFrom(from.movement);
    to.canvas.copyFrom(from.canvas);
    to.screen.copyFrom(from.screen);
    to.global.copyFrom(from.global);
    to.offset.copyFrom(from.offset);
  };

  EventService.prototype.copyWheelData = function (from, to) {
    to.deltaMode = from.deltaMode;
    to.deltaX = from.deltaX;
    to.deltaY = from.deltaY;
    to.deltaZ = from.deltaZ;
  };

  EventService.prototype.copyData = function (from, to) {
    to.isTrusted = from.isTrusted;
    to.timeStamp = performance.now();
    to.type = from.type;
    to.detail = from.detail;
    to.view = from.view;
    to.page.copyFrom(from.page);
    to.viewport.copyFrom(from.viewport);
  };

  EventService.prototype.allocateEvent = function (constructor) {
    if (!this.eventPool.has(constructor)) {
      this.eventPool.set(constructor, []);
    } // @ts-ignore


    var event = this.eventPool.get(constructor).pop() || new constructor(this);
    event.eventPhase = event.NONE;
    event.currentTarget = null;
    event.path = [];
    event.target = null;
    return event;
  };

  EventService.prototype.freeEvent = function (event) {
    if (event.manager !== this) throw new Error('It is illegal to free an event not managed by this EventBoundary!');
    var constructor = event.constructor;

    if (!this.eventPool.has(constructor)) {
      this.eventPool.set(constructor, []);
    } // @ts-ignore


    this.eventPool.get(constructor).push(event);
  };

  EventService.prototype.notifyTarget = function (e, type) {
    type = type !== null && type !== void 0 ? type : e.type;
    var key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? "".concat(type, "capture") : type;
    this.notifyListeners(e, key);

    if (e.eventPhase === e.AT_TARGET) {
      this.notifyListeners(e, type);
    }
  };

  EventService.prototype.notifyListeners = function (e, type) {
    // hack EventEmitter, stops if the `propagationImmediatelyStopped` flag is set
    var emitter = e.currentTarget.emitter; // @ts-ignore

    var listeners = emitter._events[type];
    if (!listeners) return;

    if ('fn' in listeners) {
      if (listeners.once) {
        emitter.removeListener(type, listeners.fn, undefined, true);
      }

      listeners.fn.call(e.currentTarget || listeners.context, e); // listeners.fn.call(listeners.context, e);
    } else {
      for (var i = 0; i < listeners.length && !e.propagationImmediatelyStopped; i++) {
        if (listeners[i].once) {
          emitter.removeListener(type, listeners[i].fn, undefined, true);
        }

        listeners[i].fn.call(e.currentTarget || listeners[i].context, e); // listeners[i].fn.call(listeners[i].context, e);
      }
    }
  };
  /**
   * some detached nodes may exist in propagation path, need to skip them
   */


  EventService.prototype.findMountedTarget = function (propagationPath) {
    if (!propagationPath) {
      return null;
    }

    var currentTarget = propagationPath[propagationPath.length - 1];

    for (var i = propagationPath.length - 2; i >= 0; i--) {
      var target = propagationPath[i];

      if (target === this.rootTarget || Node.isNode(target) && target.parentNode === currentTarget) {
        currentTarget = propagationPath[i];
      } else {
        break;
      }
    }

    return currentTarget;
  };

  EventService.prototype.getCursor = function (target) {
    var tmp = target;

    while (tmp) {
      var cursor = Element.isElement(tmp) && tmp.getAttribute('cursor');

      if (cursor) {
        return cursor;
      }

      tmp = Node.isNode(tmp) && tmp.parentNode;
    }
  };

  __decorate([inject(RenderingContext), __metadata("design:type", Object)], EventService.prototype, "renderingContext", void 0);

  __decorate([inject(ContextService), __metadata("design:type", Object)], EventService.prototype, "contextService", void 0);

  __decorate([inject(CanvasConfig), __metadata("design:type", Object)], EventService.prototype, "canvasConfig", void 0);

  __decorate([inversify.postConstruct(), __metadata("design:type", Function), __metadata("design:paramtypes", []), __metadata("design:returntype", void 0)], EventService.prototype, "init", null);

  EventService = __decorate([singleton()], EventService);
  return EventService;
}(_eventemitter3_4_0_7_eventemitter3.exports.EventEmitter);

export { EventService };
