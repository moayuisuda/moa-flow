/**
 * @example
  {
    translateY: [200, 300],
    scale: [1, 10],
  }

 * groups' length can be different, the following config should generate 3 frames:
  @example
  {
    translateY: [200, 300, 400],
    scale: [1, 10],
  }
 */
function convertToArrayForm(effectInput) {
  var normalizedEffectInput = [];

  for (var property in effectInput) {
    // skip reserved props
    if (property in ['easing', 'offset', 'composite']) {
      continue;
    } // @ts-ignore


    var values = effectInput[property];

    if (!Array.isArray(values)) {
      values = [values];
    }

    var numKeyframes = values.length;

    for (var i = 0; i < numKeyframes; i++) {
      if (!normalizedEffectInput[i]) {
        var keyframe = {};

        if ('offset' in effectInput) {
          keyframe.offset = Number(effectInput.offset);
        }

        if ('easing' in effectInput) {
          // @ts-ignore
          keyframe.easing = effectInput.easing;
        }

        if ('composite' in effectInput) {
          // @ts-ignore
          keyframe.composite = effectInput.composite;
        }

        normalizedEffectInput[i] = keyframe;
      }

      if (values[i] !== undefined && values[i] !== null) {
        normalizedEffectInput[i][property] = values[i];
      }
    }
  }

  normalizedEffectInput.sort(function (a, b) {
    return (a.computedOffset || 0) - (b.computedOffset || 0);
  });
  return normalizedEffectInput;
}

function normalizeKeyframes(effectInput, timing) {
  if (effectInput === null) {
    return [];
  }

  if (!Array.isArray(effectInput)) {
    effectInput = convertToArrayForm(effectInput);
  }

  var keyframes = effectInput.map(function (originalKeyframe) {
    var keyframe = {};

    if (timing === null || timing === void 0 ? void 0 : timing.composite) {
      // This will be auto if the composite operation specified on the effect is being used.
      // @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API/Keyframe_Formats
      keyframe.composite = 'auto';
    }

    for (var member in originalKeyframe) {
      var memberValue = originalKeyframe[member];

      if (member === 'offset') {
        if (memberValue !== null) {
          memberValue = Number(memberValue);
          if (!isFinite(memberValue)) throw new Error('Keyframe offsets must be numbers.');
          if (memberValue < 0 || memberValue > 1) throw new Error('Keyframe offsets must be between 0 and 1.');
          keyframe.computedOffset = memberValue;
        }
      } else if (member === 'composite') {
        // TODO: Support add & accumulate in KeyframeEffect.composite
        // @see https://developer.mozilla.org/en-US/docs/Web/API/KeyframeEffect/composite
        if (['replace', 'add', 'accumulate', 'auto'].indexOf(memberValue) === -1) {
          throw new Error("".concat(memberValue, " compositing is not supported"));
        }
      } else ; // assign to keyframe, no need to parse shorthand value


      keyframe[member] = memberValue;
    }

    if (keyframe.offset === undefined) {
      keyframe.offset = null;
    }

    if (keyframe.easing === undefined) {
      // override with timing.easing
      keyframe.easing = (timing === null || timing === void 0 ? void 0 : timing.easing) || 'linear';
    }

    if (keyframe.composite === undefined) {
      keyframe.composite = 'auto';
    }

    return keyframe;
  });
  var everyFrameHasOffset = true;
  var previousOffset = -Infinity;

  for (var i = 0; i < keyframes.length; i++) {
    var offset = keyframes[i].offset;

    if (offset !== null && offset !== undefined) {
      if (offset < previousOffset) {
        throw new TypeError('Keyframes are not loosely sorted by offset. Sort or specify offsets.');
      }

      previousOffset = offset;
    } else {
      everyFrameHasOffset = false;
    }
  }

  keyframes = keyframes.filter(function (keyframe) {
    return Number(keyframe.offset) >= 0 && Number(keyframe.offset) <= 1;
  });

  function spaceKeyframes() {
    var _a, _b;

    var length = keyframes.length;
    keyframes[length - 1].computedOffset = Number((_a = keyframes[length - 1].offset) !== null && _a !== void 0 ? _a : 1);

    if (length > 1) {
      keyframes[0].computedOffset = Number((_b = keyframes[0].offset) !== null && _b !== void 0 ? _b : 0);
    }

    var previousIndex = 0;
    var previousOffset = Number(keyframes[0].computedOffset);

    for (var i = 1; i < length; i++) {
      var offset = Number(keyframes[i].computedOffset);

      if (offset !== null && offset !== undefined && previousOffset !== null && previousOffset !== undefined) {
        for (var j = 1; j < i - previousIndex; j++) {
          keyframes[previousIndex + j].computedOffset = previousOffset + (offset - previousOffset) * j / (i - previousIndex);
        }

        previousIndex = i;
        previousOffset = offset;
      }
    }
  }

  if (!everyFrameHasOffset) spaceKeyframes();
  return keyframes;
}

export { normalizeKeyframes };
