import { __decorate } from '../../../../../_tslib@2.4.0@tslib/tslib.es6.js';
import { singleton } from '../../../../../_mana-syringe@0.3.1@mana-syringe/es/decorator.js';
import '../../../../../_mana-syringe@0.3.1@mana-syringe/es/container.js';
import '../../../../../_mana-syringe@0.3.1@mana-syringe/es/core.js';
import '../../../../../_mana-syringe@0.3.1@mana-syringe/es/contribution/contribution-protocol.js';
import '../../../../../_inversify@5.1.1@inversify/lib/inversify.js';
import '../../../../../_mana-syringe@0.3.1@mana-syringe/es/register.js';
import '../../../../../_mana-syringe@0.3.1@mana-syringe/es/contribution/index.js';
import '../cssom/types.js';
import '../cssom/CSSColorValue.js';
import { CSSKeywordValue } from '../cssom/CSSKeywordValue.js';
import '../cssom/CSSMathOperator.js';
import '../cssom/CSSMathInvert.js';
import '../cssom/CSSMathMax.js';
import '../cssom/CSSMathMin.js';
import '../cssom/CSSMathNegate.js';
import '../cssom/CSSMathProduct.js';
import '../cssom/CSSMathSum.js';
import '../cssom/CSSMathValue.js';
import '../cssom/CSSMathVariadic.js';
import '../cssom/CSSNumericValue.js';
import '../cssom/CSSNumericValueType.js';
import '../cssom/CSSRGB.js';
import '../cssom/CSSGradientValue.js';
import '../cssom/CSSStyleValue.js';
import '../cssom/CSSTransformValue.js';
import '../cssom/CSSTranslate.js';
import '../cssom/CSSUnitValue.js';
import '../parser/dimension.js';
import '../../types.js';
import '../../shapes/Rectangle.js';
import '../parser/filter.js';
import { Opx, Odeg, parseTransform, mergeTransforms } from '../parser/transform.js';

/**
 * @see /zh/docs/api/animation#支持变换的属性
 *
 * support the following formats like CSS Transform:
 *
 * scale
 * * scale(x, y)
 * * scaleX(x)
 * * scaleY(x)
 * * scaleZ(z)
 * * scale3d(x, y, z)
 *
 * translate (unit: none, px, %(relative to its bounds))
 * * translate(x, y) eg. translate(0, 0) translate(0, 30px) translate(100%, 100%)
 * * translateX(0)
 * * translateY(0)
 * * translateZ(0)
 * * translate3d(0, 0, 0)
 *
 * rotate (unit: deg rad turn)
 * * rotate(0.5turn) rotate(30deg) rotate(1rad)
 *
 * none
 *
 * unsupported for now:
 * * calc() eg. translate(calc(100% + 10px))
 * * matrix/matrix3d()
 * * skew/skewX/skewY
 * * perspective
 */

var CSSPropertyTransform =
/** @class */
function () {
  function CSSPropertyTransform() {
    this.parser = parseTransform;
    this.mixer = mergeTransforms;
  }

  CSSPropertyTransform.prototype.calculator = function (name, oldValue, newValue, object) {
    if (newValue instanceof CSSKeywordValue) {
      newValue = [];
    } // const uniqTypes = uniq([
    //   ...(oldValue || []).map(({ t }) => t),
    //   ...(newValue || []).map(({ t }) => t),
    // ]);


    newValue.forEach(function (transform) {
      var t = transform.t;
      var value = (newValue || []).find(function (o) {
        return o.t === t;
      });
      var old = (oldValue || []).find(function (o) {
        return o.t === t;
      });

      if (t === 'scale') {
        // scale(1) scale(1, 1)
        var newScale = value && value.d && value.d.map(function (s) {
          return s.value;
        }) || [1, 1];
        var oldScale = old && old.d && old.d.map(function (s) {
          return s.value;
        }) || [1, 1];
        object.scaleLocal(newScale[0] / oldScale[0], newScale[1] / oldScale[1], 1);
      } else if (t === 'scalex') {
        var newScale = value && value.d && value.d.map(function (s) {
          return s.value;
        }) || [1];
        var oldScale = old && old.d && old.d.map(function (s) {
          return s.value;
        }) || [1];
        object.scaleLocal(newScale[0] / oldScale[0], 1, 1);
      } else if (t === 'scaley') {
        var newScale = value && value.d && value.d.map(function (s) {
          return s.value;
        }) || [1];
        var oldScale = old && old.d && old.d.map(function (s) {
          return s.value;
        }) || [1];
        object.scaleLocal(1, newScale[0] / oldScale[0], 1);
      } else if (t === 'scalez') {
        var newScale = value && value.d && value.d.map(function (s) {
          return s.value;
        }) || [1];
        var oldScale = old && old.d && old.d.map(function (s) {
          return s.value;
        }) || [1];
        object.scaleLocal(1, 1, newScale[0] / oldScale[0]);
      } else if (t === 'scale3d') {
        var newScale = value && value.d && value.d.map(function (s) {
          return s.value;
        }) || [1, 1, 1];
        var oldScale = old && old.d && old.d.map(function (s) {
          return s.value;
        }) || [1, 1, 1];
        object.scaleLocal(newScale[0] / oldScale[0], newScale[1] / oldScale[1], newScale[2] / oldScale[2]);
      } else if (t === 'translate') {
        var newTranslation = value && value.d || [Opx, Opx];
        var oldTranslation = old && old.d || [Opx, Opx];
        object.translateLocal(newTranslation[0].value - oldTranslation[0].value, newTranslation[1].value - oldTranslation[1].value, 0);
      } else if (t === 'translatex') {
        var newTranslation = value && value.d || [Opx];
        var oldTranslation = old && old.d || [Opx];
        object.translateLocal(newTranslation[0].value - oldTranslation[0].value, 0, 0);
      } else if (t === 'translatey') {
        var newTranslation = value && value.d || [Opx];
        var oldTranslation = old && old.d || [Opx];
        object.translateLocal(0, newTranslation[0].value - oldTranslation[0].value, 0);
      } else if (t === 'translatez') {
        var newTranslation = value && value.d || [Opx];
        var oldTranslation = old && old.d || [Opx];
        object.translateLocal(0, 0, newTranslation[0].value - oldTranslation[0].value);
      } else if (t === 'translate3d') {
        var newTranslation = value && value.d || [Opx, Opx, Opx];
        var oldTranslation = old && old.d || [Opx, Opx, Opx];
        object.translateLocal(newTranslation[0].value - oldTranslation[0].value, newTranslation[1].value - oldTranslation[1].value, newTranslation[2].value - oldTranslation[2].value);
      } else if (t === 'rotate') {
        var newAngles = value && value.d || [Odeg];
        var oldAngles = old && old.d || [Odeg];
        object.rotateLocal(0, 0, newAngles[0].value - oldAngles[0].value);
      } else if (t === 'rotatex') {
        var newAngles = value && value.d || [Odeg];
        var oldAngles = old && old.d || [Odeg];
        object.rotateLocal(newAngles[0].value - oldAngles[0].value, 0, 0);
      } else if (t === 'rotatey') {
        var newAngles = value && value.d || [Odeg];
        var oldAngles = old && old.d || [Odeg];
        object.rotateLocal(0, newAngles[0].value - oldAngles[0].value, 0);
      } else if (t === 'rotatez') {
        var newAngles = value && value.d || [Odeg];
        var oldAngles = old && old.d || [Odeg];
        object.rotateLocal(0, 0, newAngles[0].value - oldAngles[0].value);
      } else ;
    });
    return newValue;
  };

  CSSPropertyTransform = __decorate([singleton()], CSSPropertyTransform);
  return CSSPropertyTransform;
}();

export { CSSPropertyTransform };
