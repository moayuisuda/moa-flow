import { __spreadArray, __read } from '../../../../_tslib@2.4.0@tslib/tslib.es6.js';
import '../../../../_inversify@5.1.1@inversify/lib/inversify.js';
import '../../../../_mana-syringe@0.3.1@mana-syringe/es/core.js';
import '../../../../_mana-syringe@0.3.1@mana-syringe/es/inversify/index.js';
import { GlobalContainer } from '../../../../_mana-syringe@0.3.1@mana-syringe/es/container.js';
import '../../../../_mana-syringe@0.3.1@mana-syringe/es/contribution/contribution-protocol.js';
import '../../../../_mana-syringe@0.3.1@mana-syringe/es/register.js';
import '../../../../_mana-syringe@0.3.1@mana-syringe/es/contribution/index.js';
import '../css/cssom/types.js';
import '../css/cssom/CSSColorValue.js';
import '../css/cssom/CSSKeywordValue.js';
import '../css/cssom/CSSMathOperator.js';
import '../css/cssom/CSSMathInvert.js';
import '../css/cssom/CSSMathMax.js';
import '../css/cssom/CSSMathMin.js';
import '../css/cssom/CSSMathNegate.js';
import '../css/cssom/CSSMathProduct.js';
import '../css/cssom/CSSMathSum.js';
import '../css/cssom/CSSMathValue.js';
import '../css/cssom/CSSMathVariadic.js';
import '../css/cssom/CSSNumericValue.js';
import '../css/cssom/CSSNumericValueType.js';
import '../css/cssom/CSSRGB.js';
import '../css/cssom/CSSGradientValue.js';
import '../css/cssom/CSSStyleValue.js';
import '../css/cssom/CSSTransformValue.js';
import '../css/cssom/CSSTranslate.js';
import '../css/cssom/CSSUnitValue.js';
import '../css/parser/dimension.js';
import '../types.js';
import '../shapes/Rectangle.js';
import '../css/parser/filter.js';
import '../css/parser/transform.js';
import '../css/properties/CSSPropertyLengthOrPercentage.js';
import '../css/properties/CSSPropertyLocalPosition.js';
import '../css/properties/CSSPropertyOpacity.js';
import '../css/properties/CSSPropertyColor.js';
import '../css/properties/CSSPropertyFilter.js';
import '../css/properties/CSSPropertyLineDash.js';
import '../css/properties/CSSPropertyShadowBlur.js';
import '../css/properties/CSSPropertyOffsetPath.js';
import '../css/properties/CSSPropertyOffsetDistance.js';
import '../css/properties/CSSPropertyAnchor.js';
import '../css/properties/CSSPropertyZIndex.js';
import '../css/properties/CSSPropertyTransform.js';
import '../css/properties/CSSPropertyTransformOrigin.js';
import '../css/properties/CSSPropertyPath.js';
import '../css/properties/CSSPropertyPoints.js';
import '../css/properties/CSSPropertyClipPath.js';
import '../css/properties/CSSPropertyText.js';
import '../css/properties/CSSPropertyTextTransform.js';
import { StyleValueRegistry } from '../css/StyleValueRegistry.js';
import '../css/LayoutRegistry.js';
import { parseEasingFunction } from './animation.js';
import { camelCase } from './string.js';

function convertEffectInput(keyframes, timing, target) {
  var propertySpecificKeyframeGroups = makePropertySpecificKeyframeGroups(keyframes, timing);
  var interpolations = makeInterpolations(propertySpecificKeyframeGroups, target);
  return function (target, fraction) {
    if (fraction !== null) {
      interpolations.filter(function (interpolation) {
        return fraction >= interpolation.applyFrom && fraction < interpolation.applyTo;
      }).forEach(function (interpolation) {
        var offsetFraction = fraction - interpolation.startOffset;
        var localDuration = interpolation.endOffset - interpolation.startOffset;
        var scaledLocalTime = localDuration === 0 ? 0 : interpolation.easingFunction(offsetFraction / localDuration); // apply updated attribute

        target.style[interpolation.property] = interpolation.interpolation(scaledLocalTime);
      });
    } else {
      for (var property in propertySpecificKeyframeGroups) {
        if (isNotReservedWord(property)) {
          // clear attribute
          target.style[property] = null;
        }
      }
    }
  };
}

function isNotReservedWord(member) {
  return member !== 'offset' && member !== 'easing' && member !== 'composite' && member !== 'computedOffset';
}

function makePropertySpecificKeyframeGroups(keyframes, timing) {
  var propertySpecificKeyframeGroups = {};

  for (var i = 0; i < keyframes.length; i++) {
    for (var member in keyframes[i]) {
      if (isNotReservedWord(member)) {
        var propertySpecificKeyframe = {
          offset: keyframes[i].offset,
          computedOffset: keyframes[i].computedOffset,
          easing: keyframes[i].easing,
          easingFunction: parseEasingFunction(keyframes[i].easing) || timing.easingFunction,
          value: keyframes[i][member]
        };
        propertySpecificKeyframeGroups[member] = propertySpecificKeyframeGroups[member] || []; // @ts-ignore

        propertySpecificKeyframeGroups[member].push(propertySpecificKeyframe);
      }
    }
  }

  return propertySpecificKeyframeGroups;
}

function makeInterpolations(propertySpecificKeyframeGroups, target) {
  var interpolations = [];

  for (var groupName in propertySpecificKeyframeGroups) {
    var keyframes = propertySpecificKeyframeGroups[groupName];

    for (var i = 0; i < keyframes.length - 1; i++) {
      var startIndex = i;
      var endIndex = i + 1;
      var startOffset = keyframes[startIndex].computedOffset;
      var endOffset = keyframes[endIndex].computedOffset;
      var applyFrom = startOffset;
      var applyTo = endOffset;

      if (i === 0) {
        applyFrom = -Infinity;

        if (endOffset === 0) {
          endIndex = startIndex;
        }
      }

      if (i === keyframes.length - 2) {
        applyTo = Infinity;

        if (startOffset === 1) {
          startIndex = endIndex;
        }
      }

      interpolations.push({
        applyFrom: applyFrom,
        applyTo: applyTo,
        startOffset: keyframes[startIndex].computedOffset,
        endOffset: keyframes[endIndex].computedOffset,
        easingFunction: keyframes[startIndex].easingFunction,
        property: groupName,
        interpolation: propertyInterpolation(groupName, keyframes[startIndex].value, keyframes[endIndex].value, target)
      });
    }
  }

  interpolations.sort(function (leftInterpolation, rightInterpolation) {
    return leftInterpolation.startOffset - rightInterpolation.startOffset;
  });
  return interpolations;
}

var InterpolationFactory = function InterpolationFactory(from, to, // eslint-disable-next-line @typescript-eslint/ban-types
convertToString) {
  return function (f) {
    return convertToString(interpolate(from, to, f));
  };
};

function propertyInterpolation(property, left, right, target) {
  var parsedLeft = left;
  var parsedRight = right;
  var registry = GlobalContainer.get(StyleValueRegistry);
  var metadata = registry.getMetadata(property);

  if (metadata && metadata.handler && metadata.interpolable) {
    var propertyHandler = GlobalContainer.get(metadata.handler);

    if (propertyHandler) {
      if (propertyHandler.parser) {
        parsedLeft = propertyHandler.parser(left);
        parsedRight = propertyHandler.parser(right);
      } // if (propertyHandler.calculator) {
      //   parsedLeft = propertyHandler.calculator(parsedLeft);
      //   // parsedLeft = handler.calculator
      // }
      // merger [left, right, n2string()]


      var interpolationArgs = propertyHandler.mixer(parsedLeft, parsedRight, target);

      if (interpolationArgs) {
        // @ts-ignore
        var interp_1 = InterpolationFactory.apply(void 0, __spreadArray([], __read(interpolationArgs), false));
        return function (t) {
          if (t === 0) return left;
          if (t === 1) return right;
          return interp_1(t);
        };
      }
    }
  } // eslint-disable-next-line @typescript-eslint/no-use-before-define


  return InterpolationFactory(false, true, function (bool) {
    return bool ? right : left;
  });
}
/**
 * interpolate with number, boolean, number[], boolean[]
 */


function interpolate(from, to, f) {
  if (typeof from === 'number' && typeof to === 'number') {
    return from * (1 - f) + to * f;
  }

  if (typeof from === 'boolean' && typeof to === 'boolean' || typeof from === 'string' && typeof to === 'string' // skip string, eg. path ['M', 10, 10]
  ) {
    return f < 0.5 ? from : to;
  }

  if (Array.isArray(from) && Array.isArray(to)) {
    // interpolate arrays/matrix
    if (from.length === to.length) {
      var r = [];

      for (var i = 0; i < from.length; i++) {
        r.push(interpolate(from[i], to[i], f));
      }

      return r;
    }
  }

  throw new Error('Mismatched interpolation arguments ' + from + ':' + to);
}

var FORMAT_ATTR_MAP = {
  d: {
    alias: 'path'
  },
  cx: {
    alias: 'x'
  },
  cy: {
    alias: 'y'
  },
  strokeDasharray: {
    alias: 'lineDash'
  },
  strokeWidth: {
    alias: 'lineWidth'
  },
  textAnchor: {
    alias: 'textAlign',
    values: {
      middle: 'center'
    }
  },
  src: {
    alias: 'img'
  }
};
function formatAttribute(name, value) {
  var _a;

  var attributeName = camelCase(name);
  var map = FORMAT_ATTR_MAP[attributeName];
  attributeName = (map === null || map === void 0 ? void 0 : map.alias) || attributeName;
  var attributeValue = ((_a = map === null || map === void 0 ? void 0 : map.values) === null || _a === void 0 ? void 0 : _a[value]) || value;
  return [attributeName, attributeValue];
}

export { convertEffectInput, formatAttribute };
