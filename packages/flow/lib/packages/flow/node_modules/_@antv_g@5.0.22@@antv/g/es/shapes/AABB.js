import { copy, create, fromValues, sub, add, scale, set, max, min } from '../../../../_gl-matrix@3.4.3@gl-matrix/esm/vec3.js';

/**
 * Axis-Aligned Bounding Box
 * 为了便于后续 Frustum Culling，通过查找表定义 p-vertex 和 n-vertex
 * @see https://github.com/antvis/GWebGPUEngine/issues/3
 */

var AABB =
/** @class */
function () {
  function AABB(center, halfExtents) {
    this.min = create();
    this.max = create();
    this.update(center, halfExtents);
  }

  AABB.isEmpty = function (aabb) {
    return !aabb || aabb.halfExtents[0] === 0 && aabb.halfExtents[1] === 0 && aabb.halfExtents[2] === 0;
  };

  AABB.prototype.update = function (center, halfExtents) {
    this.center = copy(create(), center || create());
    this.halfExtents = copy(create(), halfExtents || fromValues(0, 0, 0));
    this.min = sub(this.min, this.center, this.halfExtents);
    this.max = add(this.max, this.center, this.halfExtents);
  };

  AABB.prototype.setMinMax = function (min, max) {
    add(this.center, max, min);
    scale(this.center, this.center, 0.5);
    sub(this.halfExtents, max, min);
    scale(this.halfExtents, this.halfExtents, 0.5);
    copy(this.min, min);
    copy(this.max, max);
  };

  AABB.prototype.getMin = function () {
    return this.min;
  };

  AABB.prototype.getMax = function () {
    return this.max;
  };

  AABB.prototype.add = function (aabb) {
    if (AABB.isEmpty(aabb)) {
      return;
    }

    if (AABB.isEmpty(this)) {
      this.setMinMax(aabb.getMin(), aabb.getMax());
      return;
    }

    var tc = this.center;
    var tcx = tc[0];
    var tcy = tc[1];
    var tcz = tc[2];
    var th = this.halfExtents;
    var thx = th[0];
    var thy = th[1];
    var thz = th[2];
    var tminx = tcx - thx;
    var tmaxx = tcx + thx;
    var tminy = tcy - thy;
    var tmaxy = tcy + thy;
    var tminz = tcz - thz;
    var tmaxz = tcz + thz;
    var oc = aabb.center;
    var ocx = oc[0];
    var ocy = oc[1];
    var ocz = oc[2];
    var oh = aabb.halfExtents;
    var ohx = oh[0];
    var ohy = oh[1];
    var ohz = oh[2];
    var ominx = ocx - ohx;
    var omaxx = ocx + ohx;
    var ominy = ocy - ohy;
    var omaxy = ocy + ohy;
    var ominz = ocz - ohz;
    var omaxz = ocz + ohz;

    if (ominx < tminx) {
      tminx = ominx;
    }

    if (omaxx > tmaxx) {
      tmaxx = omaxx;
    }

    if (ominy < tminy) {
      tminy = ominy;
    }

    if (omaxy > tmaxy) {
      tmaxy = omaxy;
    }

    if (ominz < tminz) {
      tminz = ominz;
    }

    if (omaxz > tmaxz) {
      tmaxz = omaxz;
    }

    tc[0] = (tminx + tmaxx) * 0.5;
    tc[1] = (tminy + tmaxy) * 0.5;
    tc[2] = (tminz + tmaxz) * 0.5;
    th[0] = (tmaxx - tminx) * 0.5;
    th[1] = (tmaxy - tminy) * 0.5;
    th[2] = (tmaxz - tminz) * 0.5;
    this.min[0] = tminx;
    this.min[1] = tminy;
    this.min[2] = tminz;
    this.max[0] = tmaxx;
    this.max[1] = tmaxy;
    this.max[2] = tmaxz;
  };

  AABB.prototype.setFromTransformedAABB = function (aabb, m) {
    var bc = this.center;
    var br = this.halfExtents;
    var ac = aabb.center;
    var ar = aabb.halfExtents;
    var mx0 = m[0];
    var mx1 = m[4];
    var mx2 = m[8];
    var my0 = m[1];
    var my1 = m[5];
    var my2 = m[9];
    var mz0 = m[2];
    var mz1 = m[6];
    var mz2 = m[10];
    var mx0a = Math.abs(mx0);
    var mx1a = Math.abs(mx1);
    var mx2a = Math.abs(mx2);
    var my0a = Math.abs(my0);
    var my1a = Math.abs(my1);
    var my2a = Math.abs(my2);
    var mz0a = Math.abs(mz0);
    var mz1a = Math.abs(mz1);
    var mz2a = Math.abs(mz2);
    set(bc, m[12] + mx0 * ac[0] + mx1 * ac[1] + mx2 * ac[2], m[13] + my0 * ac[0] + my1 * ac[1] + my2 * ac[2], m[14] + mz0 * ac[0] + mz1 * ac[1] + mz2 * ac[2]);
    set(br, mx0a * ar[0] + mx1a * ar[1] + mx2a * ar[2], my0a * ar[0] + my1a * ar[1] + my2a * ar[2], mz0a * ar[0] + mz1a * ar[1] + mz2a * ar[2]);
    this.min = sub(this.min, bc, br);
    this.max = add(this.max, bc, br);
  };

  AABB.prototype.intersects = function (aabb) {
    var aMax = this.getMax();
    var aMin = this.getMin();
    var bMax = aabb.getMax();
    var bMin = aabb.getMin();
    return aMin[0] <= bMax[0] && aMax[0] >= bMin[0] && aMin[1] <= bMax[1] && aMax[1] >= bMin[1] && aMin[2] <= bMax[2] && aMax[2] >= bMin[2];
  };

  AABB.prototype.intersection = function (aabb) {
    if (!this.intersects(aabb)) {
      return null;
    }

    var intersection = new AABB();
    var min$1 = max(create(), this.getMin(), aabb.getMin());
    var max$1 = min(create(), this.getMax(), aabb.getMax());
    intersection.setMinMax(min$1, max$1);
    return intersection;
  };

  AABB.prototype.containsPoint = function (point) {
    var min = this.getMin();
    var max = this.getMax();
    return !(point[0] < min[0] || point[0] > max[0] || point[1] < min[1] || point[1] > max[1] || point[2] < min[2] || point[2] > max[2]);
  };
  /**
   * get n-vertex
   * @param plane plane of CullingVolume
   */


  AABB.prototype.getNegativeFarPoint = function (plane) {
    if (plane.pnVertexFlag === 0x111) {
      return copy(create(), this.min);
    } else if (plane.pnVertexFlag === 0x110) {
      return fromValues(this.min[0], this.min[1], this.max[2]);
    } else if (plane.pnVertexFlag === 0x101) {
      return fromValues(this.min[0], this.max[1], this.min[2]);
    } else if (plane.pnVertexFlag === 0x100) {
      return fromValues(this.min[0], this.max[1], this.max[2]);
    } else if (plane.pnVertexFlag === 0x011) {
      return fromValues(this.max[0], this.min[1], this.min[2]);
    } else if (plane.pnVertexFlag === 0x010) {
      return fromValues(this.max[0], this.min[1], this.max[2]);
    } else if (plane.pnVertexFlag === 0x001) {
      return fromValues(this.max[0], this.max[1], this.min[2]);
    } else {
      return fromValues(this.max[0], this.max[1], this.max[2]);
    }
  };
  /**
   * get p-vertex
   * @param plane plane of CullingVolume
   */


  AABB.prototype.getPositiveFarPoint = function (plane) {
    if (plane.pnVertexFlag === 0x111) {
      return copy(create(), this.max);
    } else if (plane.pnVertexFlag === 0x110) {
      return fromValues(this.max[0], this.max[1], this.min[2]);
    } else if (plane.pnVertexFlag === 0x101) {
      return fromValues(this.max[0], this.min[1], this.max[2]);
    } else if (plane.pnVertexFlag === 0x100) {
      return fromValues(this.max[0], this.min[1], this.min[2]);
    } else if (plane.pnVertexFlag === 0x011) {
      return fromValues(this.min[0], this.max[1], this.max[2]);
    } else if (plane.pnVertexFlag === 0x010) {
      return fromValues(this.min[0], this.max[1], this.min[2]);
    } else if (plane.pnVertexFlag === 0x001) {
      return fromValues(this.min[0], this.min[1], this.max[2]);
    } else {
      return fromValues(this.min[0], this.min[1], this.min[2]);
    }
  };

  return AABB;
}();

export { AABB };
