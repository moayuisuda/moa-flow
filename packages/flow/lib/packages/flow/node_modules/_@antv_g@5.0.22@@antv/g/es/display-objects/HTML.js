import { __extends, __rest, __assign } from '../../../../_tslib@2.4.0@tslib/tslib.es6.js';
import { Shape } from '../types.js';
import { DisplayObject } from './DisplayObject.js';
import { AABB } from '../shapes/AABB.js';
import '../shapes/BoundingSphere.js';
import '../shapes/Frustum.js';
import '../shapes/Plane.js';
import '../shapes/Ray.js';
import '../shapes/Point.js';
import '../shapes/Rectangle.js';
import { fromValues } from '../../../../_gl-matrix@3.4.3@gl-matrix/esm/vec3.js';
import { invert, create } from '../../../../_gl-matrix@3.4.3@gl-matrix/esm/mat4.js';

/**
 * HTML container
 * @see https://github.com/pmndrs/drei#html
 */

var HTML =
/** @class */
function (_super) {
  __extends(HTML, _super);

  function HTML(_a) {
    if (_a === void 0) {
      _a = {};
    }

    var _this = this;

    var style = _a.style,
        rest = __rest(_a, ["style"]);

    _this = _super.call(this, __assign({
      type: Shape.HTML,
      style: __assign({
        innerHTML: '',
        className: '',
        style: ''
      }, style)
    }, rest)) || this;
    _this.cullable.enable = false;
    return _this;
  }
  /**
   * return wrapper HTMLElement
   * * <div> in g-webgl/canvas
   * * <foreignObject> in g-svg
   */


  HTML.prototype.getDomElement = function () {
    return this.parsedStyle.$el;
  };
  /**
   * override with $el.getBoundingClientRect
   * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect
   */


  HTML.prototype.getBoundingClientRect = function () {
    return this.parsedStyle.$el.getBoundingClientRect();
  };

  HTML.prototype.getClientRects = function () {
    return [this.getBoundingClientRect()];
  };

  HTML.prototype.getBounds = function () {
    var _a, _b;

    var clientRect = this.getBoundingClientRect(); // calc context's offset
    // @ts-ignore

    var canvasRect = (_b = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView) === null || _b === void 0 ? void 0 : _b.getContextService().getBoundingClientRect();

    if (canvasRect) {
      var minX = clientRect.left - canvasRect.left;
      var minY = clientRect.top - canvasRect.top;
      var aabb = new AABB();
      aabb.setMinMax(fromValues(minX, minY, 0), fromValues(minX + clientRect.width, minY + clientRect.height, 0));
      return aabb;
    }

    return null;
  };

  HTML.prototype.getLocalBounds = function () {
    if (this.parentNode) {
      var parentInvert = invert(create(), this.parentNode.getWorldTransform());
      var bounds = this.getBounds();

      if (!AABB.isEmpty(bounds)) {
        var localBounds = new AABB();
        localBounds.setFromTransformedAABB(bounds, parentInvert);
        return localBounds;
      }
    }

    return this.getBounds();
  };

  return HTML;
}(DisplayObject);

export { HTML };
