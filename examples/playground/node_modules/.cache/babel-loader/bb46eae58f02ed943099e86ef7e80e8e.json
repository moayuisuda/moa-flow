{"ast":null,"code":"import { __read, __spreadArray } from \"tslib\";\nimport { GlobalContainer } from 'mana-syringe';\nimport { StyleValueRegistry } from '../css';\nimport { parseEasingFunction } from './animation';\nimport { camelCase } from './string';\nexport function convertEffectInput(keyframes, timing, target) {\n  var propertySpecificKeyframeGroups = makePropertySpecificKeyframeGroups(keyframes, timing);\n  var interpolations = makeInterpolations(propertySpecificKeyframeGroups, target);\n  return function (target, fraction) {\n    if (fraction !== null) {\n      interpolations.filter(function (interpolation) {\n        return fraction >= interpolation.applyFrom && fraction < interpolation.applyTo;\n      }).forEach(function (interpolation) {\n        var offsetFraction = fraction - interpolation.startOffset;\n        var localDuration = interpolation.endOffset - interpolation.startOffset;\n        var scaledLocalTime = localDuration === 0 ? 0 : interpolation.easingFunction(offsetFraction / localDuration); // apply updated attribute\n\n        target.style[interpolation.property] = interpolation.interpolation(scaledLocalTime);\n      });\n    } else {\n      for (var property in propertySpecificKeyframeGroups) {\n        if (isNotReservedWord(property)) {\n          // clear attribute\n          target.style[property] = null;\n        }\n      }\n    }\n  };\n}\n\nfunction isNotReservedWord(member) {\n  return member !== 'offset' && member !== 'easing' && member !== 'composite' && member !== 'computedOffset';\n}\n\nfunction makePropertySpecificKeyframeGroups(keyframes, timing) {\n  var propertySpecificKeyframeGroups = {};\n\n  for (var i = 0; i < keyframes.length; i++) {\n    for (var member in keyframes[i]) {\n      if (isNotReservedWord(member)) {\n        var propertySpecificKeyframe = {\n          offset: keyframes[i].offset,\n          computedOffset: keyframes[i].computedOffset,\n          easing: keyframes[i].easing,\n          easingFunction: parseEasingFunction(keyframes[i].easing) || timing.easingFunction,\n          value: keyframes[i][member]\n        };\n        propertySpecificKeyframeGroups[member] = propertySpecificKeyframeGroups[member] || []; // @ts-ignore\n\n        propertySpecificKeyframeGroups[member].push(propertySpecificKeyframe);\n      }\n    }\n  }\n\n  return propertySpecificKeyframeGroups;\n}\n\nfunction makeInterpolations(propertySpecificKeyframeGroups, target) {\n  var interpolations = [];\n\n  for (var groupName in propertySpecificKeyframeGroups) {\n    var keyframes = propertySpecificKeyframeGroups[groupName];\n\n    for (var i = 0; i < keyframes.length - 1; i++) {\n      var startIndex = i;\n      var endIndex = i + 1;\n      var startOffset = keyframes[startIndex].computedOffset;\n      var endOffset = keyframes[endIndex].computedOffset;\n      var applyFrom = startOffset;\n      var applyTo = endOffset;\n\n      if (i === 0) {\n        applyFrom = -Infinity;\n\n        if (endOffset === 0) {\n          endIndex = startIndex;\n        }\n      }\n\n      if (i === keyframes.length - 2) {\n        applyTo = Infinity;\n\n        if (startOffset === 1) {\n          startIndex = endIndex;\n        }\n      }\n\n      interpolations.push({\n        applyFrom: applyFrom,\n        applyTo: applyTo,\n        startOffset: keyframes[startIndex].computedOffset,\n        endOffset: keyframes[endIndex].computedOffset,\n        easingFunction: keyframes[startIndex].easingFunction,\n        property: groupName,\n        interpolation: propertyInterpolation(groupName, keyframes[startIndex].value, keyframes[endIndex].value, target)\n      });\n    }\n  }\n\n  interpolations.sort(function (leftInterpolation, rightInterpolation) {\n    return leftInterpolation.startOffset - rightInterpolation.startOffset;\n  });\n  return interpolations;\n}\n\nvar InterpolationFactory = function InterpolationFactory(from, to, // eslint-disable-next-line @typescript-eslint/ban-types\nconvertToString) {\n  return function (f) {\n    return convertToString(interpolate(from, to, f));\n  };\n};\n\nfunction propertyInterpolation(property, left, right, target) {\n  var parsedLeft = left;\n  var parsedRight = right;\n  var registry = GlobalContainer.get(StyleValueRegistry);\n  var metadata = registry.getMetadata(property);\n\n  if (metadata && metadata.handler && metadata.interpolable) {\n    var propertyHandler = GlobalContainer.get(metadata.handler);\n\n    if (propertyHandler) {\n      if (propertyHandler.parser) {\n        parsedLeft = propertyHandler.parser(left);\n        parsedRight = propertyHandler.parser(right);\n      } // if (propertyHandler.calculator) {\n      //   parsedLeft = propertyHandler.calculator(parsedLeft);\n      //   // parsedLeft = handler.calculator\n      // }\n      // merger [left, right, n2string()]\n\n\n      var interpolationArgs = propertyHandler.mixer(parsedLeft, parsedRight, target);\n\n      if (interpolationArgs) {\n        // @ts-ignore\n        var interp_1 = InterpolationFactory.apply(void 0, __spreadArray([], __read(interpolationArgs), false));\n        return function (t) {\n          if (t === 0) return left;\n          if (t === 1) return right;\n          return interp_1(t);\n        };\n      }\n    }\n  } // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n\n  return InterpolationFactory(false, true, function (bool) {\n    return bool ? right : left;\n  });\n}\n/**\n * interpolate with number, boolean, number[], boolean[]\n */\n\n\nfunction interpolate(from, to, f) {\n  if (typeof from === 'number' && typeof to === 'number') {\n    return from * (1 - f) + to * f;\n  }\n\n  if (typeof from === 'boolean' && typeof to === 'boolean' || typeof from === 'string' && typeof to === 'string' // skip string, eg. path ['M', 10, 10]\n  ) {\n    return f < 0.5 ? from : to;\n  }\n\n  if (Array.isArray(from) && Array.isArray(to)) {\n    // interpolate arrays/matrix\n    if (from.length === to.length) {\n      var r = [];\n\n      for (var i = 0; i < from.length; i++) {\n        r.push(interpolate(from[i], to[i], f));\n      }\n\n      return r;\n    }\n  }\n\n  throw new Error('Mismatched interpolation arguments ' + from + ':' + to);\n}\n\nvar FORMAT_ATTR_MAP = {\n  d: {\n    alias: 'path'\n  },\n  cx: {\n    alias: 'x'\n  },\n  cy: {\n    alias: 'y'\n  },\n  strokeDasharray: {\n    alias: 'lineDash'\n  },\n  strokeWidth: {\n    alias: 'lineWidth'\n  },\n  textAnchor: {\n    alias: 'textAlign',\n    values: {\n      middle: 'center'\n    }\n  },\n  src: {\n    alias: 'img'\n  }\n};\nexport function formatAttribute(name, value) {\n  var _a;\n\n  var attributeName = camelCase(name);\n  var map = FORMAT_ATTR_MAP[attributeName];\n  attributeName = (map === null || map === void 0 ? void 0 : map.alias) || attributeName;\n  var attributeValue = ((_a = map === null || map === void 0 ? void 0 : map.values) === null || _a === void 0 ? void 0 : _a[value]) || value;\n  return [attributeName, attributeValue];\n}","map":{"version":3,"sources":["/Users/dennis.zhang/Desktop/其它代码库/moa-flow/node_modules/@antv/g/es/utils/interpolation.js"],"names":["__read","__spreadArray","GlobalContainer","StyleValueRegistry","parseEasingFunction","camelCase","convertEffectInput","keyframes","timing","target","propertySpecificKeyframeGroups","makePropertySpecificKeyframeGroups","interpolations","makeInterpolations","fraction","filter","interpolation","applyFrom","applyTo","forEach","offsetFraction","startOffset","localDuration","endOffset","scaledLocalTime","easingFunction","style","property","isNotReservedWord","member","i","length","propertySpecificKeyframe","offset","computedOffset","easing","value","push","groupName","startIndex","endIndex","Infinity","propertyInterpolation","sort","leftInterpolation","rightInterpolation","InterpolationFactory","from","to","convertToString","f","interpolate","left","right","parsedLeft","parsedRight","registry","get","metadata","getMetadata","handler","interpolable","propertyHandler","parser","interpolationArgs","mixer","interp_1","apply","t","bool","Array","isArray","r","Error","FORMAT_ATTR_MAP","d","alias","cx","cy","strokeDasharray","strokeWidth","textAnchor","values","middle","src","formatAttribute","name","_a","attributeName","map","attributeValue"],"mappings":"AAAA,SAASA,MAAT,EAAiBC,aAAjB,QAAsC,OAAtC;AACA,SAASC,eAAT,QAAgC,cAAhC;AACA,SAASC,kBAAT,QAAmC,QAAnC;AACA,SAASC,mBAAT,QAAoC,aAApC;AACA,SAASC,SAAT,QAA0B,UAA1B;AACA,OAAO,SAASC,kBAAT,CAA4BC,SAA5B,EAAuCC,MAAvC,EAA+CC,MAA/C,EAAuD;AAC5D,MAAIC,8BAA8B,GAAGC,kCAAkC,CAACJ,SAAD,EAAYC,MAAZ,CAAvE;AACA,MAAII,cAAc,GAAGC,kBAAkB,CAACH,8BAAD,EAAiCD,MAAjC,CAAvC;AACA,SAAO,UAAUA,MAAV,EAAkBK,QAAlB,EAA4B;AACjC,QAAIA,QAAQ,KAAK,IAAjB,EAAuB;AACrBF,MAAAA,cAAc,CAACG,MAAf,CAAsB,UAAUC,aAAV,EAAyB;AAC7C,eAAOF,QAAQ,IAAIE,aAAa,CAACC,SAA1B,IAAuCH,QAAQ,GAAGE,aAAa,CAACE,OAAvE;AACD,OAFD,EAEGC,OAFH,CAEW,UAAUH,aAAV,EAAyB;AAClC,YAAII,cAAc,GAAGN,QAAQ,GAAGE,aAAa,CAACK,WAA9C;AACA,YAAIC,aAAa,GAAGN,aAAa,CAACO,SAAd,GAA0BP,aAAa,CAACK,WAA5D;AACA,YAAIG,eAAe,GAAGF,aAAa,KAAK,CAAlB,GAAsB,CAAtB,GAA0BN,aAAa,CAACS,cAAd,CAA6BL,cAAc,GAAGE,aAA9C,CAAhD,CAHkC,CAG4E;;AAE9Gb,QAAAA,MAAM,CAACiB,KAAP,CAAaV,aAAa,CAACW,QAA3B,IAAuCX,aAAa,CAACA,aAAd,CAA4BQ,eAA5B,CAAvC;AACD,OARD;AASD,KAVD,MAUO;AACL,WAAK,IAAIG,QAAT,IAAqBjB,8BAArB,EAAqD;AACnD,YAAIkB,iBAAiB,CAACD,QAAD,CAArB,EAAiC;AAC/B;AACAlB,UAAAA,MAAM,CAACiB,KAAP,CAAaC,QAAb,IAAyB,IAAzB;AACD;AACF;AACF;AACF,GAnBD;AAoBD;;AAED,SAASC,iBAAT,CAA2BC,MAA3B,EAAmC;AACjC,SAAOA,MAAM,KAAK,QAAX,IAAuBA,MAAM,KAAK,QAAlC,IAA8CA,MAAM,KAAK,WAAzD,IAAwEA,MAAM,KAAK,gBAA1F;AACD;;AAED,SAASlB,kCAAT,CAA4CJ,SAA5C,EAAuDC,MAAvD,EAA+D;AAC7D,MAAIE,8BAA8B,GAAG,EAArC;;AAEA,OAAK,IAAIoB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGvB,SAAS,CAACwB,MAA9B,EAAsCD,CAAC,EAAvC,EAA2C;AACzC,SAAK,IAAID,MAAT,IAAmBtB,SAAS,CAACuB,CAAD,CAA5B,EAAiC;AAC/B,UAAIF,iBAAiB,CAACC,MAAD,CAArB,EAA+B;AAC7B,YAAIG,wBAAwB,GAAG;AAC7BC,UAAAA,MAAM,EAAE1B,SAAS,CAACuB,CAAD,CAAT,CAAaG,MADQ;AAE7BC,UAAAA,cAAc,EAAE3B,SAAS,CAACuB,CAAD,CAAT,CAAaI,cAFA;AAG7BC,UAAAA,MAAM,EAAE5B,SAAS,CAACuB,CAAD,CAAT,CAAaK,MAHQ;AAI7BV,UAAAA,cAAc,EAAErB,mBAAmB,CAACG,SAAS,CAACuB,CAAD,CAAT,CAAaK,MAAd,CAAnB,IAA4C3B,MAAM,CAACiB,cAJtC;AAK7BW,UAAAA,KAAK,EAAE7B,SAAS,CAACuB,CAAD,CAAT,CAAaD,MAAb;AALsB,SAA/B;AAOAnB,QAAAA,8BAA8B,CAACmB,MAAD,CAA9B,GAAyCnB,8BAA8B,CAACmB,MAAD,CAA9B,IAA0C,EAAnF,CAR6B,CAQ0D;;AAEvFnB,QAAAA,8BAA8B,CAACmB,MAAD,CAA9B,CAAuCQ,IAAvC,CAA4CL,wBAA5C;AACD;AACF;AACF;;AAED,SAAOtB,8BAAP;AACD;;AAED,SAASG,kBAAT,CAA4BH,8BAA5B,EAA4DD,MAA5D,EAAoE;AAClE,MAAIG,cAAc,GAAG,EAArB;;AAEA,OAAK,IAAI0B,SAAT,IAAsB5B,8BAAtB,EAAsD;AACpD,QAAIH,SAAS,GAAGG,8BAA8B,CAAC4B,SAAD,CAA9C;;AAEA,SAAK,IAAIR,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGvB,SAAS,CAACwB,MAAV,GAAmB,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,UAAIS,UAAU,GAAGT,CAAjB;AACA,UAAIU,QAAQ,GAAGV,CAAC,GAAG,CAAnB;AACA,UAAIT,WAAW,GAAGd,SAAS,CAACgC,UAAD,CAAT,CAAsBL,cAAxC;AACA,UAAIX,SAAS,GAAGhB,SAAS,CAACiC,QAAD,CAAT,CAAoBN,cAApC;AACA,UAAIjB,SAAS,GAAGI,WAAhB;AACA,UAAIH,OAAO,GAAGK,SAAd;;AAEA,UAAIO,CAAC,KAAK,CAAV,EAAa;AACXb,QAAAA,SAAS,GAAG,CAACwB,QAAb;;AAEA,YAAIlB,SAAS,KAAK,CAAlB,EAAqB;AACnBiB,UAAAA,QAAQ,GAAGD,UAAX;AACD;AACF;;AAED,UAAIT,CAAC,KAAKvB,SAAS,CAACwB,MAAV,GAAmB,CAA7B,EAAgC;AAC9Bb,QAAAA,OAAO,GAAGuB,QAAV;;AAEA,YAAIpB,WAAW,KAAK,CAApB,EAAuB;AACrBkB,UAAAA,UAAU,GAAGC,QAAb;AACD;AACF;;AAED5B,MAAAA,cAAc,CAACyB,IAAf,CAAoB;AAClBpB,QAAAA,SAAS,EAAEA,SADO;AAElBC,QAAAA,OAAO,EAAEA,OAFS;AAGlBG,QAAAA,WAAW,EAAEd,SAAS,CAACgC,UAAD,CAAT,CAAsBL,cAHjB;AAIlBX,QAAAA,SAAS,EAAEhB,SAAS,CAACiC,QAAD,CAAT,CAAoBN,cAJb;AAKlBT,QAAAA,cAAc,EAAElB,SAAS,CAACgC,UAAD,CAAT,CAAsBd,cALpB;AAMlBE,QAAAA,QAAQ,EAAEW,SANQ;AAOlBtB,QAAAA,aAAa,EAAE0B,qBAAqB,CAACJ,SAAD,EAAY/B,SAAS,CAACgC,UAAD,CAAT,CAAsBH,KAAlC,EAAyC7B,SAAS,CAACiC,QAAD,CAAT,CAAoBJ,KAA7D,EAAoE3B,MAApE;AAPlB,OAApB;AASD;AACF;;AAEDG,EAAAA,cAAc,CAAC+B,IAAf,CAAoB,UAAUC,iBAAV,EAA6BC,kBAA7B,EAAiD;AACnE,WAAOD,iBAAiB,CAACvB,WAAlB,GAAgCwB,kBAAkB,CAACxB,WAA1D;AACD,GAFD;AAGA,SAAOT,cAAP;AACD;;AAED,IAAIkC,oBAAoB,GAAG,SAASA,oBAAT,CAA8BC,IAA9B,EAAoCC,EAApC,EAAwC;AACnEC,eAD2B,EACV;AACf,SAAO,UAAUC,CAAV,EAAa;AAClB,WAAOD,eAAe,CAACE,WAAW,CAACJ,IAAD,EAAOC,EAAP,EAAWE,CAAX,CAAZ,CAAtB;AACD,GAFD;AAGD,CALD;;AAOA,SAASR,qBAAT,CAA+Bf,QAA/B,EAAyCyB,IAAzC,EAA+CC,KAA/C,EAAsD5C,MAAtD,EAA8D;AAC5D,MAAI6C,UAAU,GAAGF,IAAjB;AACA,MAAIG,WAAW,GAAGF,KAAlB;AACA,MAAIG,QAAQ,GAAGtD,eAAe,CAACuD,GAAhB,CAAoBtD,kBAApB,CAAf;AACA,MAAIuD,QAAQ,GAAGF,QAAQ,CAACG,WAAT,CAAqBhC,QAArB,CAAf;;AAEA,MAAI+B,QAAQ,IAAIA,QAAQ,CAACE,OAArB,IAAgCF,QAAQ,CAACG,YAA7C,EAA2D;AACzD,QAAIC,eAAe,GAAG5D,eAAe,CAACuD,GAAhB,CAAoBC,QAAQ,CAACE,OAA7B,CAAtB;;AAEA,QAAIE,eAAJ,EAAqB;AACnB,UAAIA,eAAe,CAACC,MAApB,EAA4B;AAC1BT,QAAAA,UAAU,GAAGQ,eAAe,CAACC,MAAhB,CAAuBX,IAAvB,CAAb;AACAG,QAAAA,WAAW,GAAGO,eAAe,CAACC,MAAhB,CAAuBV,KAAvB,CAAd;AACD,OAJkB,CAIjB;AACF;AACA;AACA;AACA;;;AAGA,UAAIW,iBAAiB,GAAGF,eAAe,CAACG,KAAhB,CAAsBX,UAAtB,EAAkCC,WAAlC,EAA+C9C,MAA/C,CAAxB;;AAEA,UAAIuD,iBAAJ,EAAuB;AACrB;AACA,YAAIE,QAAQ,GAAGpB,oBAAoB,CAACqB,KAArB,CAA2B,KAAK,CAAhC,EAAmClE,aAAa,CAAC,EAAD,EAAKD,MAAM,CAACgE,iBAAD,CAAX,EAAgC,KAAhC,CAAhD,CAAf;AACA,eAAO,UAAUI,CAAV,EAAa;AAClB,cAAIA,CAAC,KAAK,CAAV,EAAa,OAAOhB,IAAP;AACb,cAAIgB,CAAC,KAAK,CAAV,EAAa,OAAOf,KAAP;AACb,iBAAOa,QAAQ,CAACE,CAAD,CAAf;AACD,SAJD;AAKD;AACF;AACF,GAhC2D,CAgC1D;;;AAGF,SAAOtB,oBAAoB,CAAC,KAAD,EAAQ,IAAR,EAAc,UAAUuB,IAAV,EAAgB;AACvD,WAAOA,IAAI,GAAGhB,KAAH,GAAWD,IAAtB;AACD,GAF0B,CAA3B;AAGD;AACD;AACA;AACA;;;AAGA,SAASD,WAAT,CAAqBJ,IAArB,EAA2BC,EAA3B,EAA+BE,CAA/B,EAAkC;AAChC,MAAI,OAAOH,IAAP,KAAgB,QAAhB,IAA4B,OAAOC,EAAP,KAAc,QAA9C,EAAwD;AACtD,WAAOD,IAAI,IAAI,IAAIG,CAAR,CAAJ,GAAiBF,EAAE,GAAGE,CAA7B;AACD;;AAED,MAAI,OAAOH,IAAP,KAAgB,SAAhB,IAA6B,OAAOC,EAAP,KAAc,SAA3C,IAAwD,OAAOD,IAAP,KAAgB,QAAhB,IAA4B,OAAOC,EAAP,KAAc,QAAtG,CAA+G;AAA/G,IACE;AACA,WAAOE,CAAC,GAAG,GAAJ,GAAUH,IAAV,GAAiBC,EAAxB;AACD;;AAED,MAAIsB,KAAK,CAACC,OAAN,CAAcxB,IAAd,KAAuBuB,KAAK,CAACC,OAAN,CAAcvB,EAAd,CAA3B,EAA8C;AAC5C;AACA,QAAID,IAAI,CAAChB,MAAL,KAAgBiB,EAAE,CAACjB,MAAvB,EAA+B;AAC7B,UAAIyC,CAAC,GAAG,EAAR;;AAEA,WAAK,IAAI1C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiB,IAAI,CAAChB,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;AACpC0C,QAAAA,CAAC,CAACnC,IAAF,CAAOc,WAAW,CAACJ,IAAI,CAACjB,CAAD,CAAL,EAAUkB,EAAE,CAAClB,CAAD,CAAZ,EAAiBoB,CAAjB,CAAlB;AACD;;AAED,aAAOsB,CAAP;AACD;AACF;;AAED,QAAM,IAAIC,KAAJ,CAAU,wCAAwC1B,IAAxC,GAA+C,GAA/C,GAAqDC,EAA/D,CAAN;AACD;;AAED,IAAI0B,eAAe,GAAG;AACpBC,EAAAA,CAAC,EAAE;AACDC,IAAAA,KAAK,EAAE;AADN,GADiB;AAIpBC,EAAAA,EAAE,EAAE;AACFD,IAAAA,KAAK,EAAE;AADL,GAJgB;AAOpBE,EAAAA,EAAE,EAAE;AACFF,IAAAA,KAAK,EAAE;AADL,GAPgB;AAUpBG,EAAAA,eAAe,EAAE;AACfH,IAAAA,KAAK,EAAE;AADQ,GAVG;AAapBI,EAAAA,WAAW,EAAE;AACXJ,IAAAA,KAAK,EAAE;AADI,GAbO;AAgBpBK,EAAAA,UAAU,EAAE;AACVL,IAAAA,KAAK,EAAE,WADG;AAEVM,IAAAA,MAAM,EAAE;AACNC,MAAAA,MAAM,EAAE;AADF;AAFE,GAhBQ;AAsBpBC,EAAAA,GAAG,EAAE;AACHR,IAAAA,KAAK,EAAE;AADJ;AAtBe,CAAtB;AA0BA,OAAO,SAASS,eAAT,CAAyBC,IAAzB,EAA+BlD,KAA/B,EAAsC;AAC3C,MAAImD,EAAJ;;AAEA,MAAIC,aAAa,GAAGnF,SAAS,CAACiF,IAAD,CAA7B;AACA,MAAIG,GAAG,GAAGf,eAAe,CAACc,aAAD,CAAzB;AACAA,EAAAA,aAAa,GAAG,CAACC,GAAG,KAAK,IAAR,IAAgBA,GAAG,KAAK,KAAK,CAA7B,GAAiC,KAAK,CAAtC,GAA0CA,GAAG,CAACb,KAA/C,KAAyDY,aAAzE;AACA,MAAIE,cAAc,GAAG,CAAC,CAACH,EAAE,GAAGE,GAAG,KAAK,IAAR,IAAgBA,GAAG,KAAK,KAAK,CAA7B,GAAiC,KAAK,CAAtC,GAA0CA,GAAG,CAACP,MAApD,MAAgE,IAAhE,IAAwEK,EAAE,KAAK,KAAK,CAApF,GAAwF,KAAK,CAA7F,GAAiGA,EAAE,CAACnD,KAAD,CAApG,KAAgHA,KAArI;AACA,SAAO,CAACoD,aAAD,EAAgBE,cAAhB,CAAP;AACD","sourcesContent":["import { __read, __spreadArray } from \"tslib\";\nimport { GlobalContainer } from 'mana-syringe';\nimport { StyleValueRegistry } from '../css';\nimport { parseEasingFunction } from './animation';\nimport { camelCase } from './string';\nexport function convertEffectInput(keyframes, timing, target) {\n  var propertySpecificKeyframeGroups = makePropertySpecificKeyframeGroups(keyframes, timing);\n  var interpolations = makeInterpolations(propertySpecificKeyframeGroups, target);\n  return function (target, fraction) {\n    if (fraction !== null) {\n      interpolations.filter(function (interpolation) {\n        return fraction >= interpolation.applyFrom && fraction < interpolation.applyTo;\n      }).forEach(function (interpolation) {\n        var offsetFraction = fraction - interpolation.startOffset;\n        var localDuration = interpolation.endOffset - interpolation.startOffset;\n        var scaledLocalTime = localDuration === 0 ? 0 : interpolation.easingFunction(offsetFraction / localDuration); // apply updated attribute\n\n        target.style[interpolation.property] = interpolation.interpolation(scaledLocalTime);\n      });\n    } else {\n      for (var property in propertySpecificKeyframeGroups) {\n        if (isNotReservedWord(property)) {\n          // clear attribute\n          target.style[property] = null;\n        }\n      }\n    }\n  };\n}\n\nfunction isNotReservedWord(member) {\n  return member !== 'offset' && member !== 'easing' && member !== 'composite' && member !== 'computedOffset';\n}\n\nfunction makePropertySpecificKeyframeGroups(keyframes, timing) {\n  var propertySpecificKeyframeGroups = {};\n\n  for (var i = 0; i < keyframes.length; i++) {\n    for (var member in keyframes[i]) {\n      if (isNotReservedWord(member)) {\n        var propertySpecificKeyframe = {\n          offset: keyframes[i].offset,\n          computedOffset: keyframes[i].computedOffset,\n          easing: keyframes[i].easing,\n          easingFunction: parseEasingFunction(keyframes[i].easing) || timing.easingFunction,\n          value: keyframes[i][member]\n        };\n        propertySpecificKeyframeGroups[member] = propertySpecificKeyframeGroups[member] || []; // @ts-ignore\n\n        propertySpecificKeyframeGroups[member].push(propertySpecificKeyframe);\n      }\n    }\n  }\n\n  return propertySpecificKeyframeGroups;\n}\n\nfunction makeInterpolations(propertySpecificKeyframeGroups, target) {\n  var interpolations = [];\n\n  for (var groupName in propertySpecificKeyframeGroups) {\n    var keyframes = propertySpecificKeyframeGroups[groupName];\n\n    for (var i = 0; i < keyframes.length - 1; i++) {\n      var startIndex = i;\n      var endIndex = i + 1;\n      var startOffset = keyframes[startIndex].computedOffset;\n      var endOffset = keyframes[endIndex].computedOffset;\n      var applyFrom = startOffset;\n      var applyTo = endOffset;\n\n      if (i === 0) {\n        applyFrom = -Infinity;\n\n        if (endOffset === 0) {\n          endIndex = startIndex;\n        }\n      }\n\n      if (i === keyframes.length - 2) {\n        applyTo = Infinity;\n\n        if (startOffset === 1) {\n          startIndex = endIndex;\n        }\n      }\n\n      interpolations.push({\n        applyFrom: applyFrom,\n        applyTo: applyTo,\n        startOffset: keyframes[startIndex].computedOffset,\n        endOffset: keyframes[endIndex].computedOffset,\n        easingFunction: keyframes[startIndex].easingFunction,\n        property: groupName,\n        interpolation: propertyInterpolation(groupName, keyframes[startIndex].value, keyframes[endIndex].value, target)\n      });\n    }\n  }\n\n  interpolations.sort(function (leftInterpolation, rightInterpolation) {\n    return leftInterpolation.startOffset - rightInterpolation.startOffset;\n  });\n  return interpolations;\n}\n\nvar InterpolationFactory = function InterpolationFactory(from, to, // eslint-disable-next-line @typescript-eslint/ban-types\nconvertToString) {\n  return function (f) {\n    return convertToString(interpolate(from, to, f));\n  };\n};\n\nfunction propertyInterpolation(property, left, right, target) {\n  var parsedLeft = left;\n  var parsedRight = right;\n  var registry = GlobalContainer.get(StyleValueRegistry);\n  var metadata = registry.getMetadata(property);\n\n  if (metadata && metadata.handler && metadata.interpolable) {\n    var propertyHandler = GlobalContainer.get(metadata.handler);\n\n    if (propertyHandler) {\n      if (propertyHandler.parser) {\n        parsedLeft = propertyHandler.parser(left);\n        parsedRight = propertyHandler.parser(right);\n      } // if (propertyHandler.calculator) {\n      //   parsedLeft = propertyHandler.calculator(parsedLeft);\n      //   // parsedLeft = handler.calculator\n      // }\n      // merger [left, right, n2string()]\n\n\n      var interpolationArgs = propertyHandler.mixer(parsedLeft, parsedRight, target);\n\n      if (interpolationArgs) {\n        // @ts-ignore\n        var interp_1 = InterpolationFactory.apply(void 0, __spreadArray([], __read(interpolationArgs), false));\n        return function (t) {\n          if (t === 0) return left;\n          if (t === 1) return right;\n          return interp_1(t);\n        };\n      }\n    }\n  } // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n\n  return InterpolationFactory(false, true, function (bool) {\n    return bool ? right : left;\n  });\n}\n/**\n * interpolate with number, boolean, number[], boolean[]\n */\n\n\nfunction interpolate(from, to, f) {\n  if (typeof from === 'number' && typeof to === 'number') {\n    return from * (1 - f) + to * f;\n  }\n\n  if (typeof from === 'boolean' && typeof to === 'boolean' || typeof from === 'string' && typeof to === 'string' // skip string, eg. path ['M', 10, 10]\n  ) {\n    return f < 0.5 ? from : to;\n  }\n\n  if (Array.isArray(from) && Array.isArray(to)) {\n    // interpolate arrays/matrix\n    if (from.length === to.length) {\n      var r = [];\n\n      for (var i = 0; i < from.length; i++) {\n        r.push(interpolate(from[i], to[i], f));\n      }\n\n      return r;\n    }\n  }\n\n  throw new Error('Mismatched interpolation arguments ' + from + ':' + to);\n}\n\nvar FORMAT_ATTR_MAP = {\n  d: {\n    alias: 'path'\n  },\n  cx: {\n    alias: 'x'\n  },\n  cy: {\n    alias: 'y'\n  },\n  strokeDasharray: {\n    alias: 'lineDash'\n  },\n  strokeWidth: {\n    alias: 'lineWidth'\n  },\n  textAnchor: {\n    alias: 'textAlign',\n    values: {\n      middle: 'center'\n    }\n  },\n  src: {\n    alias: 'img'\n  }\n};\nexport function formatAttribute(name, value) {\n  var _a;\n\n  var attributeName = camelCase(name);\n  var map = FORMAT_ATTR_MAP[attributeName];\n  attributeName = (map === null || map === void 0 ? void 0 : map.alias) || attributeName;\n  var attributeValue = ((_a = map === null || map === void 0 ? void 0 : map.values) === null || _a === void 0 ? void 0 : _a[value]) || value;\n  return [attributeName, attributeValue];\n}"]},"metadata":{},"sourceType":"module"}