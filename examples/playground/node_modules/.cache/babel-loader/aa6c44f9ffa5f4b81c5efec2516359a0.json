{"ast":null,"code":"/**\n * @fileoverview 椭圆的一些计算，\n *  - 周长计算参考：https://www.mathsisfun.com/geometry/ellipse-perimeter.html\n *  - 距离计算参考：https://wet-robots.ghost.io/simple-method-for-distance-to-ellipse/\n * @author dxq613@gmail.com\n */\nimport { distance, piMod } from './util';\n\nfunction copysign(v1, v2) {\n  var absv = Math.abs(v1);\n  return v2 > 0 ? absv : absv * -1;\n}\n\nexport default {\n  /**\n   * 包围盒计算\n   * @param {number} x  椭圆中心 x\n   * @param {number} y  椭圆中心 y\n   * @param {number} rx 椭圆 x 方向半径\n   * @param {number} ry 椭圆 y 方向半径\n   * @return {object} 包围盒\n   */\n  box: function box(x, y, rx, ry) {\n    return {\n      x: x - rx,\n      y: y - ry,\n      width: rx * 2,\n      height: ry * 2\n    };\n  },\n\n  /**\n   * 计算周长，使用近似法\n   * @param {number} x  椭圆中心 x\n   * @param {number} y  椭圆中心 y\n   * @param {number} rx 椭圆 x 方向半径\n   * @param {number} ry 椭圆 y 方向半径\n   * @return {number} 椭圆周长\n   */\n  length: function length(x, y, rx, ry) {\n    return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));\n  },\n\n  /**\n   * 距离椭圆最近的点\n   * @param {number} x  椭圆中心 x\n   * @param {number} y  椭圆中心 y\n   * @param {number} rx 椭圆 x 方向半径\n   * @param {number} ry 椭圆 y 方向半径\n   * @param {number} x0  指定的点 x\n   * @param {number} y0  指定的点 y\n   * @return {object} 椭圆上距离指定点最近的点\n   */\n  nearestPoint: function nearestPoint(x, y, rx, ry, x0, y0) {\n    var a = rx;\n    var b = ry; // 假如椭圆半径为0则返回圆心\n\n    if (a === 0 || b === 0) {\n      return {\n        x: x,\n        y: y\n      };\n    } // 转换成 0， 0 为中心的椭圆计算\n\n\n    var relativeX = x0 - x;\n    var relativeY = y0 - y;\n    var px = Math.abs(relativeX);\n    var py = Math.abs(relativeY);\n    var squareA = a * a;\n    var squareB = b * b; // const angle0 = Math.atan2(relativeY, relativeX);\n\n    var t = Math.PI / 4;\n    var nearestX = 0; // 椭圆上的任一点\n\n    var nearestY = 0; // 迭代 4 次\n\n    for (var i = 0; i < 4; i++) {\n      nearestX = a * Math.cos(t);\n      nearestY = b * Math.sin(t);\n      var ex = (squareA - squareB) * Math.pow(Math.cos(t), 3) / a;\n      var ey = (squareB - squareA) * Math.pow(Math.sin(t), 3) / b;\n      var rx1 = nearestX - ex;\n      var ry1 = nearestY - ey;\n      var qx = px - ex;\n      var qy = py - ey;\n      var r = Math.hypot(ry1, rx1);\n      var q = Math.hypot(qy, qx);\n      var delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));\n      var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);\n      t += delta_t;\n      t = Math.min(Math.PI / 2, Math.max(0, t));\n    }\n\n    return {\n      x: x + copysign(nearestX, relativeX),\n      y: y + copysign(nearestY, relativeY)\n    };\n  },\n\n  /**\n   * 点到椭圆最近的距离\n   * @param {number} x  椭圆中心 x\n   * @param {number} y  椭圆中心 y\n   * @param {number} rx 椭圆 x 方向半径\n   * @param {number} ry 椭圆 y 方向半径\n   * @param {number} x0  指定的点 x\n   * @param {number} y0  指定的点 y\n   * @return {number} 点到椭圆的距离\n   */\n  pointDistance: function pointDistance(x, y, rx, ry, x0, y0) {\n    var nearestPoint = this.nearestPoint(x, y, rx, ry, x0, y0);\n    return distance(nearestPoint.x, nearestPoint.y, x0, y0);\n  },\n\n  /**\n   * 根据比例获取点\n   * @param {number} x 椭圆中心 x\n   * @param {number} y 椭圆中心 y\n   * @param {number} rx 椭圆 x 方向半径\n   * @param {number} ry 椭圆 y 方向半径\n   * @param {number} t 指定比例，x轴方向为 0\n   * @return {object} 点\n   */\n  pointAt: function pointAt(x, y, rx, ry, t) {\n    var angle = 2 * Math.PI * t; // 按照角度进行计算，而不按照周长计算\n\n    return {\n      x: x + rx * Math.cos(angle),\n      y: y + ry * Math.sin(angle)\n    };\n  },\n\n  /**\n   * 根据比例计算切线角度\n   * @param {number} x 椭圆中心 x\n   * @param {number} y 椭圆中心 y\n   * @param {number} rx 椭圆 x 方向半径\n   * @param {number} ry 椭圆 y 方向半径\n   * @param {number} t 指定比例 0 - 1 之间，x轴方向为 0。在 0-1 范围之外是循环还是返回 null，还需要调整\n   * @return {number} 角度，在 0 - 2PI 之间\n   */\n  tangentAngle: function tangentAngle(x, y, rx, ry, t) {\n    var angle = 2 * Math.PI * t; // 按照角度进行计算，而不按照周长计算\n    // 直接使用 x,y 的导数计算， x' = -rx * sin(t); y' = ry * cos(t);\n\n    var tangentAngle = Math.atan2(ry * Math.cos(angle), -rx * Math.sin(angle)); // 也可以使用指定点的切线方程计算，成本有些高\n    // const point = this.pointAt(0, 0, rx, ry, t); // 椭圆的切线同椭圆的中心不相关\n    // let tangentAngle = -1 * Math.atan((ry * ry * point.x) / (rx * rx * point.y));\n    // if (angle >= 0 && angle <= Math.PI) {\n    //   tangentAngle += Math.PI;\n    // }\n\n    return piMod(tangentAngle);\n  }\n};","map":{"version":3,"sources":["/Users/dennis.zhang/Desktop/其它代码库/moa-flow/node_modules/@antv/g-math/es/ellipse.js"],"names":["distance","piMod","copysign","v1","v2","absv","Math","abs","box","x","y","rx","ry","width","height","length","PI","sqrt","nearestPoint","x0","y0","a","b","relativeX","relativeY","px","py","squareA","squareB","t","nearestX","nearestY","i","cos","sin","ex","pow","ey","rx1","ry1","qx","qy","r","hypot","q","delta_c","asin","delta_t","min","max","pointDistance","pointAt","angle","tangentAngle","atan2"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,QAAT,EAAmBC,KAAnB,QAAgC,QAAhC;;AAEA,SAASC,QAAT,CAAkBC,EAAlB,EAAsBC,EAAtB,EAA0B;AACxB,MAAIC,IAAI,GAAGC,IAAI,CAACC,GAAL,CAASJ,EAAT,CAAX;AACA,SAAOC,EAAE,GAAG,CAAL,GAASC,IAAT,GAAgBA,IAAI,GAAG,CAAC,CAA/B;AACD;;AAED,eAAe;AACb;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACEG,EAAAA,GAAG,EAAE,SAASA,GAAT,CAAaC,CAAb,EAAgBC,CAAhB,EAAmBC,EAAnB,EAAuBC,EAAvB,EAA2B;AAC9B,WAAO;AACLH,MAAAA,CAAC,EAAEA,CAAC,GAAGE,EADF;AAELD,MAAAA,CAAC,EAAEA,CAAC,GAAGE,EAFF;AAGLC,MAAAA,KAAK,EAAEF,EAAE,GAAG,CAHP;AAILG,MAAAA,MAAM,EAAEF,EAAE,GAAG;AAJR,KAAP;AAMD,GAhBY;;AAkBb;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACEG,EAAAA,MAAM,EAAE,SAASA,MAAT,CAAgBN,CAAhB,EAAmBC,CAAnB,EAAsBC,EAAtB,EAA0BC,EAA1B,EAA8B;AACpC,WAAON,IAAI,CAACU,EAAL,IAAW,KAAKL,EAAE,GAAGC,EAAV,IAAgBN,IAAI,CAACW,IAAL,CAAU,CAAC,IAAIN,EAAJ,GAASC,EAAV,KAAiBD,EAAE,GAAG,IAAIC,EAA1B,CAAV,CAA3B,CAAP;AACD,GA5BY;;AA8Bb;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEM,EAAAA,YAAY,EAAE,SAASA,YAAT,CAAsBT,CAAtB,EAAyBC,CAAzB,EAA4BC,EAA5B,EAAgCC,EAAhC,EAAoCO,EAApC,EAAwCC,EAAxC,EAA4C;AACxD,QAAIC,CAAC,GAAGV,EAAR;AACA,QAAIW,CAAC,GAAGV,EAAR,CAFwD,CAE5C;;AAEZ,QAAIS,CAAC,KAAK,CAAN,IAAWC,CAAC,KAAK,CAArB,EAAwB;AACtB,aAAO;AACLb,QAAAA,CAAC,EAAEA,CADE;AAELC,QAAAA,CAAC,EAAEA;AAFE,OAAP;AAID,KATuD,CAStD;;;AAGF,QAAIa,SAAS,GAAGJ,EAAE,GAAGV,CAArB;AACA,QAAIe,SAAS,GAAGJ,EAAE,GAAGV,CAArB;AACA,QAAIe,EAAE,GAAGnB,IAAI,CAACC,GAAL,CAASgB,SAAT,CAAT;AACA,QAAIG,EAAE,GAAGpB,IAAI,CAACC,GAAL,CAASiB,SAAT,CAAT;AACA,QAAIG,OAAO,GAAGN,CAAC,GAAGA,CAAlB;AACA,QAAIO,OAAO,GAAGN,CAAC,GAAGA,CAAlB,CAjBwD,CAiBnC;;AAErB,QAAIO,CAAC,GAAGvB,IAAI,CAACU,EAAL,GAAU,CAAlB;AACA,QAAIc,QAAQ,GAAG,CAAf,CApBwD,CAoBtC;;AAElB,QAAIC,QAAQ,GAAG,CAAf,CAtBwD,CAsBtC;;AAElB,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1BF,MAAAA,QAAQ,GAAGT,CAAC,GAAGf,IAAI,CAAC2B,GAAL,CAASJ,CAAT,CAAf;AACAE,MAAAA,QAAQ,GAAGT,CAAC,GAAGhB,IAAI,CAAC4B,GAAL,CAASL,CAAT,CAAf;AACA,UAAIM,EAAE,GAAG,CAACR,OAAO,GAAGC,OAAX,IAAsBtB,IAAI,CAAC8B,GAAL,CAAS9B,IAAI,CAAC2B,GAAL,CAASJ,CAAT,CAAT,EAAsB,CAAtB,CAAtB,GAAiDR,CAA1D;AACA,UAAIgB,EAAE,GAAG,CAACT,OAAO,GAAGD,OAAX,IAAsBrB,IAAI,CAAC8B,GAAL,CAAS9B,IAAI,CAAC4B,GAAL,CAASL,CAAT,CAAT,EAAsB,CAAtB,CAAtB,GAAiDP,CAA1D;AACA,UAAIgB,GAAG,GAAGR,QAAQ,GAAGK,EAArB;AACA,UAAII,GAAG,GAAGR,QAAQ,GAAGM,EAArB;AACA,UAAIG,EAAE,GAAGf,EAAE,GAAGU,EAAd;AACA,UAAIM,EAAE,GAAGf,EAAE,GAAGW,EAAd;AACA,UAAIK,CAAC,GAAGpC,IAAI,CAACqC,KAAL,CAAWJ,GAAX,EAAgBD,GAAhB,CAAR;AACA,UAAIM,CAAC,GAAGtC,IAAI,CAACqC,KAAL,CAAWF,EAAX,EAAeD,EAAf,CAAR;AACA,UAAIK,OAAO,GAAGH,CAAC,GAAGpC,IAAI,CAACwC,IAAL,CAAU,CAACR,GAAG,GAAGG,EAAN,GAAWF,GAAG,GAAGC,EAAlB,KAAyBE,CAAC,GAAGE,CAA7B,CAAV,CAAlB;AACA,UAAIG,OAAO,GAAGF,OAAO,GAAGvC,IAAI,CAACW,IAAL,CAAUU,OAAO,GAAGC,OAAV,GAAoBE,QAAQ,GAAGA,QAA/B,GAA0CC,QAAQ,GAAGA,QAA/D,CAAxB;AACAF,MAAAA,CAAC,IAAIkB,OAAL;AACAlB,MAAAA,CAAC,GAAGvB,IAAI,CAAC0C,GAAL,CAAS1C,IAAI,CAACU,EAAL,GAAU,CAAnB,EAAsBV,IAAI,CAAC2C,GAAL,CAAS,CAAT,EAAYpB,CAAZ,CAAtB,CAAJ;AACD;;AAED,WAAO;AACLpB,MAAAA,CAAC,EAAEA,CAAC,GAAGP,QAAQ,CAAC4B,QAAD,EAAWP,SAAX,CADV;AAELb,MAAAA,CAAC,EAAEA,CAAC,GAAGR,QAAQ,CAAC6B,QAAD,EAAWP,SAAX;AAFV,KAAP;AAID,GArFY;;AAuFb;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE0B,EAAAA,aAAa,EAAE,SAASA,aAAT,CAAuBzC,CAAvB,EAA0BC,CAA1B,EAA6BC,EAA7B,EAAiCC,EAAjC,EAAqCO,EAArC,EAAyCC,EAAzC,EAA6C;AAC1D,QAAIF,YAAY,GAAG,KAAKA,YAAL,CAAkBT,CAAlB,EAAqBC,CAArB,EAAwBC,EAAxB,EAA4BC,EAA5B,EAAgCO,EAAhC,EAAoCC,EAApC,CAAnB;AACA,WAAOpB,QAAQ,CAACkB,YAAY,CAACT,CAAd,EAAiBS,YAAY,CAACR,CAA9B,EAAiCS,EAAjC,EAAqCC,EAArC,CAAf;AACD,GApGY;;AAsGb;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE+B,EAAAA,OAAO,EAAE,SAASA,OAAT,CAAiB1C,CAAjB,EAAoBC,CAApB,EAAuBC,EAAvB,EAA2BC,EAA3B,EAA+BiB,CAA/B,EAAkC;AACzC,QAAIuB,KAAK,GAAG,IAAI9C,IAAI,CAACU,EAAT,GAAca,CAA1B,CADyC,CACZ;;AAE7B,WAAO;AACLpB,MAAAA,CAAC,EAAEA,CAAC,GAAGE,EAAE,GAAGL,IAAI,CAAC2B,GAAL,CAASmB,KAAT,CADP;AAEL1C,MAAAA,CAAC,EAAEA,CAAC,GAAGE,EAAE,GAAGN,IAAI,CAAC4B,GAAL,CAASkB,KAAT;AAFP,KAAP;AAID,GAtHY;;AAwHb;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEC,EAAAA,YAAY,EAAE,SAASA,YAAT,CAAsB5C,CAAtB,EAAyBC,CAAzB,EAA4BC,EAA5B,EAAgCC,EAAhC,EAAoCiB,CAApC,EAAuC;AACnD,QAAIuB,KAAK,GAAG,IAAI9C,IAAI,CAACU,EAAT,GAAca,CAA1B,CADmD,CACtB;AAC7B;;AAEA,QAAIwB,YAAY,GAAG/C,IAAI,CAACgD,KAAL,CAAW1C,EAAE,GAAGN,IAAI,CAAC2B,GAAL,CAASmB,KAAT,CAAhB,EAAiC,CAACzC,EAAD,GAAML,IAAI,CAAC4B,GAAL,CAASkB,KAAT,CAAvC,CAAnB,CAJmD,CAIyB;AAC5E;AACA;AACA;AACA;AACA;;AAEA,WAAOnD,KAAK,CAACoD,YAAD,CAAZ;AACD;AA7IY,CAAf","sourcesContent":["/**\n * @fileoverview 椭圆的一些计算，\n *  - 周长计算参考：https://www.mathsisfun.com/geometry/ellipse-perimeter.html\n *  - 距离计算参考：https://wet-robots.ghost.io/simple-method-for-distance-to-ellipse/\n * @author dxq613@gmail.com\n */\nimport { distance, piMod } from './util';\n\nfunction copysign(v1, v2) {\n  var absv = Math.abs(v1);\n  return v2 > 0 ? absv : absv * -1;\n}\n\nexport default {\n  /**\n   * 包围盒计算\n   * @param {number} x  椭圆中心 x\n   * @param {number} y  椭圆中心 y\n   * @param {number} rx 椭圆 x 方向半径\n   * @param {number} ry 椭圆 y 方向半径\n   * @return {object} 包围盒\n   */\n  box: function box(x, y, rx, ry) {\n    return {\n      x: x - rx,\n      y: y - ry,\n      width: rx * 2,\n      height: ry * 2\n    };\n  },\n\n  /**\n   * 计算周长，使用近似法\n   * @param {number} x  椭圆中心 x\n   * @param {number} y  椭圆中心 y\n   * @param {number} rx 椭圆 x 方向半径\n   * @param {number} ry 椭圆 y 方向半径\n   * @return {number} 椭圆周长\n   */\n  length: function length(x, y, rx, ry) {\n    return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));\n  },\n\n  /**\n   * 距离椭圆最近的点\n   * @param {number} x  椭圆中心 x\n   * @param {number} y  椭圆中心 y\n   * @param {number} rx 椭圆 x 方向半径\n   * @param {number} ry 椭圆 y 方向半径\n   * @param {number} x0  指定的点 x\n   * @param {number} y0  指定的点 y\n   * @return {object} 椭圆上距离指定点最近的点\n   */\n  nearestPoint: function nearestPoint(x, y, rx, ry, x0, y0) {\n    var a = rx;\n    var b = ry; // 假如椭圆半径为0则返回圆心\n\n    if (a === 0 || b === 0) {\n      return {\n        x: x,\n        y: y\n      };\n    } // 转换成 0， 0 为中心的椭圆计算\n\n\n    var relativeX = x0 - x;\n    var relativeY = y0 - y;\n    var px = Math.abs(relativeX);\n    var py = Math.abs(relativeY);\n    var squareA = a * a;\n    var squareB = b * b; // const angle0 = Math.atan2(relativeY, relativeX);\n\n    var t = Math.PI / 4;\n    var nearestX = 0; // 椭圆上的任一点\n\n    var nearestY = 0; // 迭代 4 次\n\n    for (var i = 0; i < 4; i++) {\n      nearestX = a * Math.cos(t);\n      nearestY = b * Math.sin(t);\n      var ex = (squareA - squareB) * Math.pow(Math.cos(t), 3) / a;\n      var ey = (squareB - squareA) * Math.pow(Math.sin(t), 3) / b;\n      var rx1 = nearestX - ex;\n      var ry1 = nearestY - ey;\n      var qx = px - ex;\n      var qy = py - ey;\n      var r = Math.hypot(ry1, rx1);\n      var q = Math.hypot(qy, qx);\n      var delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));\n      var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);\n      t += delta_t;\n      t = Math.min(Math.PI / 2, Math.max(0, t));\n    }\n\n    return {\n      x: x + copysign(nearestX, relativeX),\n      y: y + copysign(nearestY, relativeY)\n    };\n  },\n\n  /**\n   * 点到椭圆最近的距离\n   * @param {number} x  椭圆中心 x\n   * @param {number} y  椭圆中心 y\n   * @param {number} rx 椭圆 x 方向半径\n   * @param {number} ry 椭圆 y 方向半径\n   * @param {number} x0  指定的点 x\n   * @param {number} y0  指定的点 y\n   * @return {number} 点到椭圆的距离\n   */\n  pointDistance: function pointDistance(x, y, rx, ry, x0, y0) {\n    var nearestPoint = this.nearestPoint(x, y, rx, ry, x0, y0);\n    return distance(nearestPoint.x, nearestPoint.y, x0, y0);\n  },\n\n  /**\n   * 根据比例获取点\n   * @param {number} x 椭圆中心 x\n   * @param {number} y 椭圆中心 y\n   * @param {number} rx 椭圆 x 方向半径\n   * @param {number} ry 椭圆 y 方向半径\n   * @param {number} t 指定比例，x轴方向为 0\n   * @return {object} 点\n   */\n  pointAt: function pointAt(x, y, rx, ry, t) {\n    var angle = 2 * Math.PI * t; // 按照角度进行计算，而不按照周长计算\n\n    return {\n      x: x + rx * Math.cos(angle),\n      y: y + ry * Math.sin(angle)\n    };\n  },\n\n  /**\n   * 根据比例计算切线角度\n   * @param {number} x 椭圆中心 x\n   * @param {number} y 椭圆中心 y\n   * @param {number} rx 椭圆 x 方向半径\n   * @param {number} ry 椭圆 y 方向半径\n   * @param {number} t 指定比例 0 - 1 之间，x轴方向为 0。在 0-1 范围之外是循环还是返回 null，还需要调整\n   * @return {number} 角度，在 0 - 2PI 之间\n   */\n  tangentAngle: function tangentAngle(x, y, rx, ry, t) {\n    var angle = 2 * Math.PI * t; // 按照角度进行计算，而不按照周长计算\n    // 直接使用 x,y 的导数计算， x' = -rx * sin(t); y' = ry * cos(t);\n\n    var tangentAngle = Math.atan2(ry * Math.cos(angle), -rx * Math.sin(angle)); // 也可以使用指定点的切线方程计算，成本有些高\n    // const point = this.pointAt(0, 0, rx, ry, t); // 椭圆的切线同椭圆的中心不相关\n    // let tangentAngle = -1 * Math.atan((ry * ry * point.x) / (rx * rx * point.y));\n    // if (angle >= 0 && angle <= Math.PI) {\n    //   tangentAngle += Math.PI;\n    // }\n\n    return piMod(tangentAngle);\n  }\n};"]},"metadata":{},"sourceType":"module"}