{"ast":null,"code":"import { parseNumber, mergeNumbers, parseAngle, parseLength, parseLengthOrPercentage, mergeDimensions } from './';\nimport { UnitType, CSSUnitValue } from '../cssom';\nvar _ = null;\nexport var Opx = new CSSUnitValue(0, 'px');\nexport var Odeg = new CSSUnitValue(0, 'deg');\n\nfunction cast(pattern) {\n  return function (contents) {\n    var i = 0;\n    return pattern.map(function (x) {\n      return x === _ ? contents[i++] : x;\n    });\n  };\n}\n\nfunction id(x) {\n  return x;\n} // type: [argTypes, convertTo3D, convertTo2D]\n// In the argument types string, lowercase characters represent optional arguments\n\n\nvar transformFunctions = {\n  // matrix: ['NNNNNN', [_, _, 0, 0, _, _, 0, 0, 0, 0, 1, 0, _, _, 0, 1], id],\n  // matrix3d: ['NNNNNNNNNNNNNNNN', id],\n  rotate: ['A'],\n  rotatex: ['A'],\n  rotatey: ['A'],\n  rotatez: ['A'],\n  rotate3d: ['NNNA'],\n  // perspective: ['L'],\n  scale: ['Nn', cast([_, _, new CSSUnitValue(1)]), id],\n  scalex: ['N', cast([_, new CSSUnitValue(1), new CSSUnitValue(1)]), cast([_, new CSSUnitValue(1)])],\n  scaley: ['N', cast([new CSSUnitValue(1), _, new CSSUnitValue(1)]), cast([new CSSUnitValue(1), _])],\n  scalez: ['N', cast([new CSSUnitValue(1), new CSSUnitValue(1), _])],\n  scale3d: ['NNN', id],\n  // skew: ['Aa', null, id],\n  // skewx: ['A', null, cast([_, Odeg])],\n  // skewy: ['A', null, cast([Odeg, _])],\n  translate: ['Tt', cast([_, _, Opx]), id],\n  translatex: ['T', cast([_, Opx, Opx]), cast([_, Opx])],\n  translatey: ['T', cast([Opx, _, Opx]), cast([Opx, _])],\n  translatez: ['L', cast([Opx, Opx, _])],\n  translate3d: ['TTL', id]\n};\n/**\n * none\n * scale(1) scale(1, 2)\n * scaleX(1)\n */\n\nexport function parseTransform(string) {\n  string = string.toLowerCase().trim();\n\n  if (string === 'none') {\n    return [];\n  }\n\n  var transformRegExp = /\\s*(\\w+)\\(([^)]*)\\)/g;\n  var result = [];\n  var match;\n  var prevLastIndex = 0;\n\n  while (match = transformRegExp.exec(string)) {\n    if (match.index !== prevLastIndex) {\n      return [];\n    }\n\n    prevLastIndex = match.index + match[0].length;\n    var functionName = match[1]; // scale\n\n    var functionData = transformFunctions[functionName]; // scale(1, 2)\n\n    if (!functionData) {\n      // invalid, eg. scale()\n      return [];\n    }\n\n    var args = match[2].split(','); // 1,2\n\n    var argTypes = functionData[0]; // Nn\n\n    if (argTypes.length < args.length) {\n      // scale(N, n)\n      return [];\n    }\n\n    var parsedArgs = [];\n\n    for (var i = 0; i < argTypes.length; i++) {\n      var arg = args[i];\n      var type = argTypes[i];\n      var parsedArg = void 0;\n\n      if (!arg) {\n        // @ts-ignore\n        parsedArg = {\n          a: Odeg,\n          n: parsedArgs[0],\n          t: Opx\n        }[type];\n      } else {\n        // @ts-ignore\n        parsedArg = {\n          A: function A(s) {\n            return s.trim() === '0' ? Odeg : parseAngle(s);\n          },\n          N: parseNumber,\n          T: parseLengthOrPercentage,\n          L: parseLength\n        }[type.toUpperCase()](arg);\n      }\n\n      if (parsedArg === undefined) {\n        return [];\n      }\n\n      parsedArgs.push(parsedArg);\n    }\n\n    result.push({\n      t: functionName,\n      d: parsedArgs\n    }); // { t: scale, d: [1, 2] }\n\n    if (transformRegExp.lastIndex === string.length) {\n      return result;\n    }\n  }\n\n  return [];\n} // function mergeMatrices(left: number[][], right: number[][]): [\n//   number[][], number[][], () => string,\n// ] {\n//   if (left.decompositionPair !== right) {\n//     left.decompositionPair = right;\n//     var leftArgs = makeMatrixDecomposition(left);\n//   }\n//   if (right.decompositionPair !== left) {\n//     right.decompositionPair = left;\n//     var rightArgs = makeMatrixDecomposition(right);\n//   }\n//   if (leftArgs[0] === null || rightArgs[0] === null)\n//     return [[false], [true], (x) => { return x ? right[0].d : left[0].d; }];\n//   leftArgs[0].push(0);\n//   rightArgs[0].push(1);\n//   return [\n//     leftArgs,\n//     rightArgs,\n//     (list) => {\n//       const q = quat(leftArgs[0][3], rightArgs[0][3], list[5]);\n//       const mat = composeMatrix(list[0], list[1], list[2], q, list[4]);\n//       const stringifiedArgs = mat.map(numberToLongString).join(',');\n//       return stringifiedArgs;\n//     }\n//   ];\n// }\n// scalex/y/z -> scale\n\nfunction typeTo2D(type) {\n  return type.replace(/[xy]/, '');\n} // scalex/y/z -> scale3d\n\n\nfunction typeTo3D(type) {\n  return type.replace(/(x|y|z|3d)?$/, '3d');\n}\n\nvar isMatrixOrPerspective = function isMatrixOrPerspective(lt, rt) {\n  return lt === 'perspective' && rt === 'perspective' || (lt === 'matrix' || lt === 'matrix3d') && (rt === 'matrix' || rt === 'matrix3d');\n};\n\nexport function mergeTransforms(left, right, target) {\n  var flipResults = false; // padding empty transform, eg. merge 'scale(10)' with 'none' -> scale(1)\n\n  if (!left.length || !right.length) {\n    if (!left.length) {\n      flipResults = true;\n      left = right;\n      right = [];\n    }\n\n    var _loop_1 = function _loop_1(i) {\n      var _a = left[i],\n          type = _a.t,\n          args = _a.d; // none -> scale(1)/translateX(0)\n\n      var defaultValue = type.substr(0, 5) === 'scale' ? 1 : 0;\n      right.push({\n        t: type,\n        d: args.map(function (arg) {\n          if (typeof arg === 'number') {\n            return new CSSUnitValue(defaultValue);\n          }\n\n          return new CSSUnitValue(defaultValue, arg.unit); //   {\n          //     unit: arg.unit,\n          //     value: defaultValue,\n          //   };\n        })\n      });\n    };\n\n    for (var i = 0; i < left.length; i++) {\n      _loop_1(i);\n    }\n  }\n\n  var leftResult = [];\n  var rightResult = [];\n  var types = []; // merge matrix() with matrix3d()\n\n  if (left.length !== right.length) {// const merged = mergeMatrices(left, right);\n    // leftResult = [merged[0]];\n    // rightResult = [merged[1]];\n    // types = [['matrix', [merged[2]]]];\n  } else {\n    for (var i = 0; i < left.length; i++) {\n      var leftType = left[i].t;\n      var rightType = right[i].t;\n      var leftArgs = left[i].d;\n      var rightArgs = right[i].d;\n      var leftFunctionData = transformFunctions[leftType];\n      var rightFunctionData = transformFunctions[rightType];\n      var type = void 0;\n\n      if (isMatrixOrPerspective(leftType, rightType)) {\n        // const merged = mergeMatrices([left[i]], [right[i]]);\n        // leftResult.push(merged[0]);\n        // rightResult.push(merged[1]);\n        // types.push(['matrix', [merged[2]]]);\n        continue;\n      } else if (leftType === rightType) {\n        type = leftType;\n      } else if (leftFunctionData[2] && rightFunctionData[2] && typeTo2D(leftType) === typeTo2D(rightType)) {\n        type = typeTo2D(leftType); // @ts-ignore\n\n        leftArgs = leftFunctionData[2](leftArgs); // @ts-ignore\n\n        rightArgs = rightFunctionData[2](rightArgs);\n      } else if (leftFunctionData[1] && rightFunctionData[1] && typeTo3D(leftType) === typeTo3D(rightType)) {\n        type = typeTo3D(leftType); // @ts-ignore\n\n        leftArgs = leftFunctionData[1](leftArgs); // @ts-ignore\n\n        rightArgs = rightFunctionData[1](rightArgs);\n      } else {\n        // const merged = mergeMatrices(left, right);\n        // leftResult = [merged[0]];\n        // rightResult = [merged[1]];\n        // types = [['matrix', [merged[2]]]];\n        break;\n      }\n\n      var leftArgsCopy = [];\n      var rightArgsCopy = [];\n      var stringConversions = [];\n\n      for (var j = 0; j < leftArgs.length; j++) {\n        var merge = leftArgs[j].unit === UnitType.kNumber ? mergeNumbers : mergeDimensions; // @ts-ignore\n\n        var merged = merge(leftArgs[j], rightArgs[j], target, false, j);\n        leftArgsCopy[j] = merged[0];\n        rightArgsCopy[j] = merged[1];\n        stringConversions.push(merged[2]);\n      }\n\n      leftResult.push(leftArgsCopy);\n      rightResult.push(rightArgsCopy);\n      types.push([type, stringConversions]);\n    }\n  }\n\n  if (flipResults) {\n    var tmp = leftResult;\n    leftResult = rightResult;\n    rightResult = tmp;\n  }\n\n  return [leftResult, rightResult, function (list) {\n    return list.map(function (args, i) {\n      var stringifiedArgs = args.map(function (arg, j) {\n        return types[i][1][j](arg);\n      }).join(',');\n      if (types[i][0] === 'matrix' && stringifiedArgs.split(',').length === 16) types[i][0] = 'matrix3d';\n      return types[i][0] + '(' + stringifiedArgs + ')';\n    }).join(' ');\n  }];\n}","map":{"version":3,"sources":["/Users/dennis.zhang/Desktop/其它代码库/moa-flow/node_modules/@antv/g/es/css/parser/transform.js"],"names":["parseNumber","mergeNumbers","parseAngle","parseLength","parseLengthOrPercentage","mergeDimensions","UnitType","CSSUnitValue","_","Opx","Odeg","cast","pattern","contents","i","map","x","id","transformFunctions","rotate","rotatex","rotatey","rotatez","rotate3d","scale","scalex","scaley","scalez","scale3d","translate","translatex","translatey","translatez","translate3d","parseTransform","string","toLowerCase","trim","transformRegExp","result","match","prevLastIndex","exec","index","length","functionName","functionData","args","split","argTypes","parsedArgs","arg","type","parsedArg","a","n","t","A","s","N","T","L","toUpperCase","undefined","push","d","lastIndex","typeTo2D","replace","typeTo3D","isMatrixOrPerspective","lt","rt","mergeTransforms","left","right","target","flipResults","_loop_1","_a","defaultValue","substr","unit","leftResult","rightResult","types","leftType","rightType","leftArgs","rightArgs","leftFunctionData","rightFunctionData","leftArgsCopy","rightArgsCopy","stringConversions","j","merge","kNumber","merged","tmp","list","stringifiedArgs","join"],"mappings":"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","sourcesContent":["import { parseNumber, mergeNumbers, parseAngle, parseLength, parseLengthOrPercentage, mergeDimensions } from './';\nimport { UnitType, CSSUnitValue } from '../cssom';\nvar _ = null;\nexport var Opx = new CSSUnitValue(0, 'px');\nexport var Odeg = new CSSUnitValue(0, 'deg');\n\nfunction cast(pattern) {\n  return function (contents) {\n    var i = 0;\n    return pattern.map(function (x) {\n      return x === _ ? contents[i++] : x;\n    });\n  };\n}\n\nfunction id(x) {\n  return x;\n} // type: [argTypes, convertTo3D, convertTo2D]\n// In the argument types string, lowercase characters represent optional arguments\n\n\nvar transformFunctions = {\n  // matrix: ['NNNNNN', [_, _, 0, 0, _, _, 0, 0, 0, 0, 1, 0, _, _, 0, 1], id],\n  // matrix3d: ['NNNNNNNNNNNNNNNN', id],\n  rotate: ['A'],\n  rotatex: ['A'],\n  rotatey: ['A'],\n  rotatez: ['A'],\n  rotate3d: ['NNNA'],\n  // perspective: ['L'],\n  scale: ['Nn', cast([_, _, new CSSUnitValue(1)]), id],\n  scalex: ['N', cast([_, new CSSUnitValue(1), new CSSUnitValue(1)]), cast([_, new CSSUnitValue(1)])],\n  scaley: ['N', cast([new CSSUnitValue(1), _, new CSSUnitValue(1)]), cast([new CSSUnitValue(1), _])],\n  scalez: ['N', cast([new CSSUnitValue(1), new CSSUnitValue(1), _])],\n  scale3d: ['NNN', id],\n  // skew: ['Aa', null, id],\n  // skewx: ['A', null, cast([_, Odeg])],\n  // skewy: ['A', null, cast([Odeg, _])],\n  translate: ['Tt', cast([_, _, Opx]), id],\n  translatex: ['T', cast([_, Opx, Opx]), cast([_, Opx])],\n  translatey: ['T', cast([Opx, _, Opx]), cast([Opx, _])],\n  translatez: ['L', cast([Opx, Opx, _])],\n  translate3d: ['TTL', id]\n};\n/**\n * none\n * scale(1) scale(1, 2)\n * scaleX(1)\n */\n\nexport function parseTransform(string) {\n  string = string.toLowerCase().trim();\n\n  if (string === 'none') {\n    return [];\n  }\n\n  var transformRegExp = /\\s*(\\w+)\\(([^)]*)\\)/g;\n  var result = [];\n  var match;\n  var prevLastIndex = 0;\n\n  while (match = transformRegExp.exec(string)) {\n    if (match.index !== prevLastIndex) {\n      return [];\n    }\n\n    prevLastIndex = match.index + match[0].length;\n    var functionName = match[1]; // scale\n\n    var functionData = transformFunctions[functionName]; // scale(1, 2)\n\n    if (!functionData) {\n      // invalid, eg. scale()\n      return [];\n    }\n\n    var args = match[2].split(','); // 1,2\n\n    var argTypes = functionData[0]; // Nn\n\n    if (argTypes.length < args.length) {\n      // scale(N, n)\n      return [];\n    }\n\n    var parsedArgs = [];\n\n    for (var i = 0; i < argTypes.length; i++) {\n      var arg = args[i];\n      var type = argTypes[i];\n      var parsedArg = void 0;\n\n      if (!arg) {\n        // @ts-ignore\n        parsedArg = {\n          a: Odeg,\n          n: parsedArgs[0],\n          t: Opx\n        }[type];\n      } else {\n        // @ts-ignore\n        parsedArg = {\n          A: function A(s) {\n            return s.trim() === '0' ? Odeg : parseAngle(s);\n          },\n          N: parseNumber,\n          T: parseLengthOrPercentage,\n          L: parseLength\n        }[type.toUpperCase()](arg);\n      }\n\n      if (parsedArg === undefined) {\n        return [];\n      }\n\n      parsedArgs.push(parsedArg);\n    }\n\n    result.push({\n      t: functionName,\n      d: parsedArgs\n    }); // { t: scale, d: [1, 2] }\n\n    if (transformRegExp.lastIndex === string.length) {\n      return result;\n    }\n  }\n\n  return [];\n} // function mergeMatrices(left: number[][], right: number[][]): [\n//   number[][], number[][], () => string,\n// ] {\n//   if (left.decompositionPair !== right) {\n//     left.decompositionPair = right;\n//     var leftArgs = makeMatrixDecomposition(left);\n//   }\n//   if (right.decompositionPair !== left) {\n//     right.decompositionPair = left;\n//     var rightArgs = makeMatrixDecomposition(right);\n//   }\n//   if (leftArgs[0] === null || rightArgs[0] === null)\n//     return [[false], [true], (x) => { return x ? right[0].d : left[0].d; }];\n//   leftArgs[0].push(0);\n//   rightArgs[0].push(1);\n//   return [\n//     leftArgs,\n//     rightArgs,\n//     (list) => {\n//       const q = quat(leftArgs[0][3], rightArgs[0][3], list[5]);\n//       const mat = composeMatrix(list[0], list[1], list[2], q, list[4]);\n//       const stringifiedArgs = mat.map(numberToLongString).join(',');\n//       return stringifiedArgs;\n//     }\n//   ];\n// }\n// scalex/y/z -> scale\n\nfunction typeTo2D(type) {\n  return type.replace(/[xy]/, '');\n} // scalex/y/z -> scale3d\n\n\nfunction typeTo3D(type) {\n  return type.replace(/(x|y|z|3d)?$/, '3d');\n}\n\nvar isMatrixOrPerspective = function isMatrixOrPerspective(lt, rt) {\n  return lt === 'perspective' && rt === 'perspective' || (lt === 'matrix' || lt === 'matrix3d') && (rt === 'matrix' || rt === 'matrix3d');\n};\n\nexport function mergeTransforms(left, right, target) {\n  var flipResults = false; // padding empty transform, eg. merge 'scale(10)' with 'none' -> scale(1)\n\n  if (!left.length || !right.length) {\n    if (!left.length) {\n      flipResults = true;\n      left = right;\n      right = [];\n    }\n\n    var _loop_1 = function _loop_1(i) {\n      var _a = left[i],\n          type = _a.t,\n          args = _a.d; // none -> scale(1)/translateX(0)\n\n      var defaultValue = type.substr(0, 5) === 'scale' ? 1 : 0;\n      right.push({\n        t: type,\n        d: args.map(function (arg) {\n          if (typeof arg === 'number') {\n            return new CSSUnitValue(defaultValue);\n          }\n\n          return new CSSUnitValue(defaultValue, arg.unit); //   {\n          //     unit: arg.unit,\n          //     value: defaultValue,\n          //   };\n        })\n      });\n    };\n\n    for (var i = 0; i < left.length; i++) {\n      _loop_1(i);\n    }\n  }\n\n  var leftResult = [];\n  var rightResult = [];\n  var types = []; // merge matrix() with matrix3d()\n\n  if (left.length !== right.length) {// const merged = mergeMatrices(left, right);\n    // leftResult = [merged[0]];\n    // rightResult = [merged[1]];\n    // types = [['matrix', [merged[2]]]];\n  } else {\n    for (var i = 0; i < left.length; i++) {\n      var leftType = left[i].t;\n      var rightType = right[i].t;\n      var leftArgs = left[i].d;\n      var rightArgs = right[i].d;\n      var leftFunctionData = transformFunctions[leftType];\n      var rightFunctionData = transformFunctions[rightType];\n      var type = void 0;\n\n      if (isMatrixOrPerspective(leftType, rightType)) {\n        // const merged = mergeMatrices([left[i]], [right[i]]);\n        // leftResult.push(merged[0]);\n        // rightResult.push(merged[1]);\n        // types.push(['matrix', [merged[2]]]);\n        continue;\n      } else if (leftType === rightType) {\n        type = leftType;\n      } else if (leftFunctionData[2] && rightFunctionData[2] && typeTo2D(leftType) === typeTo2D(rightType)) {\n        type = typeTo2D(leftType); // @ts-ignore\n\n        leftArgs = leftFunctionData[2](leftArgs); // @ts-ignore\n\n        rightArgs = rightFunctionData[2](rightArgs);\n      } else if (leftFunctionData[1] && rightFunctionData[1] && typeTo3D(leftType) === typeTo3D(rightType)) {\n        type = typeTo3D(leftType); // @ts-ignore\n\n        leftArgs = leftFunctionData[1](leftArgs); // @ts-ignore\n\n        rightArgs = rightFunctionData[1](rightArgs);\n      } else {\n        // const merged = mergeMatrices(left, right);\n        // leftResult = [merged[0]];\n        // rightResult = [merged[1]];\n        // types = [['matrix', [merged[2]]]];\n        break;\n      }\n\n      var leftArgsCopy = [];\n      var rightArgsCopy = [];\n      var stringConversions = [];\n\n      for (var j = 0; j < leftArgs.length; j++) {\n        var merge = leftArgs[j].unit === UnitType.kNumber ? mergeNumbers : mergeDimensions; // @ts-ignore\n\n        var merged = merge(leftArgs[j], rightArgs[j], target, false, j);\n        leftArgsCopy[j] = merged[0];\n        rightArgsCopy[j] = merged[1];\n        stringConversions.push(merged[2]);\n      }\n\n      leftResult.push(leftArgsCopy);\n      rightResult.push(rightArgsCopy);\n      types.push([type, stringConversions]);\n    }\n  }\n\n  if (flipResults) {\n    var tmp = leftResult;\n    leftResult = rightResult;\n    rightResult = tmp;\n  }\n\n  return [leftResult, rightResult, function (list) {\n    return list.map(function (args, i) {\n      var stringifiedArgs = args.map(function (arg, j) {\n        return types[i][1][j](arg);\n      }).join(',');\n      if (types[i][0] === 'matrix' && stringifiedArgs.split(',').length === 16) types[i][0] = 'matrix3d';\n      return types[i][0] + '(' + stringifiedArgs + ')';\n    }).join(' ');\n  }];\n}"]},"metadata":{},"sourceType":"module"}