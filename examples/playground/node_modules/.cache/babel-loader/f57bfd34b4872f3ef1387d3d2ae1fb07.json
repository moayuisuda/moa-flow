{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { singleton } from 'mana-syringe';\nimport { GeometryAABBUpdater } from './interfaces';\nimport { Shape } from '../../types';\n\nvar PathUpdater =\n/** @class */\nfunction () {\n  function PathUpdater() {}\n\n  PathUpdater.prototype.update = function (parsedStyle) {\n    var path = parsedStyle.path;\n    var _a = path.rect,\n        minX = _a.x,\n        minY = _a.y,\n        width = _a.width,\n        height = _a.height;\n    return {\n      width: width,\n      height: height,\n      x: minX,\n      y: minY\n    };\n  };\n\n  PathUpdater = __decorate([singleton({\n    token: {\n      token: GeometryAABBUpdater,\n      named: Shape.PATH\n    }\n  })], PathUpdater);\n  return PathUpdater;\n}();\n\nexport { PathUpdater }; // function getPathBox(segments: PathSegment[], lineWidth: number) {\n//   let xArr = [];\n//   let yArr = [];\n//   const segmentsWithAngle = [];\n//   for (let i = 0; i < segments.length; i++) {\n//     const segment = segments[i];\n//     const { currentPoint, params, prePoint } = segment;\n//     let box;\n//     switch (segment.command) {\n//       case 'Q':\n//         box = QuadUtil.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);\n//         break;\n//       case 'C':\n//         box = CubicUtil.box(\n//           prePoint[0],\n//           prePoint[1],\n//           params[1],\n//           params[2],\n//           params[3],\n//           params[4],\n//           params[5],\n//           params[6],\n//         );\n//         break;\n//       case 'A':\n//         // eslint-disable-next-line no-case-declarations\n//         const { arcParams } = segment;\n//         box = EllipseArcUtil.box(\n//           arcParams.cx,\n//           arcParams.cy,\n//           arcParams.rx,\n//           arcParams.ry,\n//           arcParams.xRotation,\n//           arcParams.startAngle,\n//           arcParams.endAngle,\n//         );\n//         break;\n//       default:\n//         xArr.push(currentPoint[0]);\n//         yArr.push(currentPoint[1]);\n//         break;\n//     }\n//     if (box) {\n//       segment.box = box;\n//       xArr.push(box.x, box.x + box.width);\n//       yArr.push(box.y, box.y + box.height);\n//     }\n//     if (\n//       lineWidth &&\n//       (segment.command === 'L' || segment.command === 'M') &&\n//       segment.prePoint &&\n//       segment.nextPoint\n//     ) {\n//       segmentsWithAngle.push(segment);\n//     }\n//   }\n//   // bbox calculation should ignore NaN for path attribute\n//   // ref: https://github.com/antvis/g/issues/210\n//   xArr = xArr.filter((item) => !Number.isNaN(item));\n//   yArr = yArr.filter((item) => !Number.isNaN(item));\n//   let minX = min(xArr);\n//   let minY = min(yArr);\n//   let maxX = max(xArr);\n//   let maxY = max(yArr);\n//   if (segmentsWithAngle.length === 0) {\n//     return {\n//       x: minX,\n//       y: minY,\n//       width: maxX - minX,\n//       height: maxY - minY,\n//     };\n//   }\n//   for (let i = 0; i < segmentsWithAngle.length; i++) {\n//     const segment = segmentsWithAngle[i];\n//     const { currentPoint } = segment;\n//     let extra;\n//     if (currentPoint[0] === minX) {\n//       extra = getExtraFromSegmentWithAngle(segment, lineWidth);\n//       minX -= extra.xExtra;\n//     } else if (currentPoint[0] === maxX) {\n//       extra = getExtraFromSegmentWithAngle(segment, lineWidth);\n//       maxX += extra.xExtra;\n//     }\n//     if (currentPoint[1] === minY) {\n//       extra = getExtraFromSegmentWithAngle(segment, lineWidth);\n//       minY -= extra.yExtra;\n//     } else if (currentPoint[1] === maxY) {\n//       extra = getExtraFromSegmentWithAngle(segment, lineWidth);\n//       maxY += extra.yExtra;\n//     }\n//   }\n//   return {\n//     x: minX,\n//     y: minY,\n//     width: maxX - minX,\n//     height: maxY - minY,\n//   };\n// }\n// function getExtraFromSegmentWithAngle(segment: any, lineWidth: number) {\n//   const { prePoint, currentPoint, nextPoint } = segment;\n//   const currentAndPre =\n//     Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);\n//   const currentAndNext =\n//     Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);\n//   const preAndNext =\n//     Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);\n//   // 以 currentPoint 为顶点的夹角\n//   const currentAngle = Math.acos(\n//     (currentAndPre + currentAndNext - preAndNext) /\n//     (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)),\n//   );\n//   // 夹角为空、 0 或 PI 时，不需要计算夹角处的额外宽度\n//   // 注意: 由于计算精度问题，夹角为 0 的情况计算出来的角度可能是一个很小的值，还需要判断其与 0 是否近似相等\n//   if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual(currentAngle, 0)) {\n//     return {\n//       xExtra: 0,\n//       yExtra: 0,\n//     };\n//   }\n//   let xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));\n//   let yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));\n//   // 将夹角转为锐角\n//   xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;\n//   yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;\n//   // 这里不考虑在水平和垂直方向的投影，直接使用最大差值\n//   // 由于上层统一加减了二分之一线宽，这里需要进行弥补\n//   const extra = {\n//     // 水平方向投影\n//     xExtra:\n//       Math.cos(currentAngle / 2 - xAngle) * ((lineWidth / 2) * (1 / Math.sin(currentAngle / 2))) -\n//       lineWidth / 2 || 0,\n//     // 垂直方向投影\n//     yExtra:\n//       Math.cos(yAngle - currentAngle / 2) * ((lineWidth / 2) * (1 / Math.sin(currentAngle / 2))) -\n//       lineWidth / 2 || 0,\n//   };\n//   return extra;\n// }","map":{"version":3,"sources":["/Users/dennis.zhang/Desktop/其它代码库/moa-flow/node_modules/@antv/g/es/services/aabb/PathUpdater.js"],"names":["__decorate","singleton","GeometryAABBUpdater","Shape","PathUpdater","prototype","update","parsedStyle","path","_a","rect","minX","x","minY","y","width","height","token","named","PATH"],"mappings":"AAAA,SAASA,UAAT,QAA2B,OAA3B;AACA,SAASC,SAAT,QAA0B,cAA1B;AACA,SAASC,mBAAT,QAAoC,cAApC;AACA,SAASC,KAAT,QAAsB,aAAtB;;AAEA,IAAIC,WAAW;AACf;AACA,YAAY;AACV,WAASA,WAAT,GAAuB,CAAE;;AAEzBA,EAAAA,WAAW,CAACC,SAAZ,CAAsBC,MAAtB,GAA+B,UAAUC,WAAV,EAAuB;AACpD,QAAIC,IAAI,GAAGD,WAAW,CAACC,IAAvB;AACA,QAAIC,EAAE,GAAGD,IAAI,CAACE,IAAd;AAAA,QACIC,IAAI,GAAGF,EAAE,CAACG,CADd;AAAA,QAEIC,IAAI,GAAGJ,EAAE,CAACK,CAFd;AAAA,QAGIC,KAAK,GAAGN,EAAE,CAACM,KAHf;AAAA,QAIIC,MAAM,GAAGP,EAAE,CAACO,MAJhB;AAKA,WAAO;AACLD,MAAAA,KAAK,EAAEA,KADF;AAELC,MAAAA,MAAM,EAAEA,MAFH;AAGLJ,MAAAA,CAAC,EAAED,IAHE;AAILG,MAAAA,CAAC,EAAED;AAJE,KAAP;AAMD,GAbD;;AAeAT,EAAAA,WAAW,GAAGJ,UAAU,CAAC,CAACC,SAAS,CAAC;AAClCgB,IAAAA,KAAK,EAAE;AACLA,MAAAA,KAAK,EAAEf,mBADF;AAELgB,MAAAA,KAAK,EAAEf,KAAK,CAACgB;AAFR;AAD2B,GAAD,CAAV,CAAD,EAKnBf,WALmB,CAAxB;AAMA,SAAOA,WAAP;AACD,CAzBD,EAFA;;AA6BA,SAASA,WAAT,G,CAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { __decorate } from \"tslib\";\nimport { singleton } from 'mana-syringe';\nimport { GeometryAABBUpdater } from './interfaces';\nimport { Shape } from '../../types';\n\nvar PathUpdater =\n/** @class */\nfunction () {\n  function PathUpdater() {}\n\n  PathUpdater.prototype.update = function (parsedStyle) {\n    var path = parsedStyle.path;\n    var _a = path.rect,\n        minX = _a.x,\n        minY = _a.y,\n        width = _a.width,\n        height = _a.height;\n    return {\n      width: width,\n      height: height,\n      x: minX,\n      y: minY\n    };\n  };\n\n  PathUpdater = __decorate([singleton({\n    token: {\n      token: GeometryAABBUpdater,\n      named: Shape.PATH\n    }\n  })], PathUpdater);\n  return PathUpdater;\n}();\n\nexport { PathUpdater }; // function getPathBox(segments: PathSegment[], lineWidth: number) {\n//   let xArr = [];\n//   let yArr = [];\n//   const segmentsWithAngle = [];\n//   for (let i = 0; i < segments.length; i++) {\n//     const segment = segments[i];\n//     const { currentPoint, params, prePoint } = segment;\n//     let box;\n//     switch (segment.command) {\n//       case 'Q':\n//         box = QuadUtil.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);\n//         break;\n//       case 'C':\n//         box = CubicUtil.box(\n//           prePoint[0],\n//           prePoint[1],\n//           params[1],\n//           params[2],\n//           params[3],\n//           params[4],\n//           params[5],\n//           params[6],\n//         );\n//         break;\n//       case 'A':\n//         // eslint-disable-next-line no-case-declarations\n//         const { arcParams } = segment;\n//         box = EllipseArcUtil.box(\n//           arcParams.cx,\n//           arcParams.cy,\n//           arcParams.rx,\n//           arcParams.ry,\n//           arcParams.xRotation,\n//           arcParams.startAngle,\n//           arcParams.endAngle,\n//         );\n//         break;\n//       default:\n//         xArr.push(currentPoint[0]);\n//         yArr.push(currentPoint[1]);\n//         break;\n//     }\n//     if (box) {\n//       segment.box = box;\n//       xArr.push(box.x, box.x + box.width);\n//       yArr.push(box.y, box.y + box.height);\n//     }\n//     if (\n//       lineWidth &&\n//       (segment.command === 'L' || segment.command === 'M') &&\n//       segment.prePoint &&\n//       segment.nextPoint\n//     ) {\n//       segmentsWithAngle.push(segment);\n//     }\n//   }\n//   // bbox calculation should ignore NaN for path attribute\n//   // ref: https://github.com/antvis/g/issues/210\n//   xArr = xArr.filter((item) => !Number.isNaN(item));\n//   yArr = yArr.filter((item) => !Number.isNaN(item));\n//   let minX = min(xArr);\n//   let minY = min(yArr);\n//   let maxX = max(xArr);\n//   let maxY = max(yArr);\n//   if (segmentsWithAngle.length === 0) {\n//     return {\n//       x: minX,\n//       y: minY,\n//       width: maxX - minX,\n//       height: maxY - minY,\n//     };\n//   }\n//   for (let i = 0; i < segmentsWithAngle.length; i++) {\n//     const segment = segmentsWithAngle[i];\n//     const { currentPoint } = segment;\n//     let extra;\n//     if (currentPoint[0] === minX) {\n//       extra = getExtraFromSegmentWithAngle(segment, lineWidth);\n//       minX -= extra.xExtra;\n//     } else if (currentPoint[0] === maxX) {\n//       extra = getExtraFromSegmentWithAngle(segment, lineWidth);\n//       maxX += extra.xExtra;\n//     }\n//     if (currentPoint[1] === minY) {\n//       extra = getExtraFromSegmentWithAngle(segment, lineWidth);\n//       minY -= extra.yExtra;\n//     } else if (currentPoint[1] === maxY) {\n//       extra = getExtraFromSegmentWithAngle(segment, lineWidth);\n//       maxY += extra.yExtra;\n//     }\n//   }\n//   return {\n//     x: minX,\n//     y: minY,\n//     width: maxX - minX,\n//     height: maxY - minY,\n//   };\n// }\n// function getExtraFromSegmentWithAngle(segment: any, lineWidth: number) {\n//   const { prePoint, currentPoint, nextPoint } = segment;\n//   const currentAndPre =\n//     Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);\n//   const currentAndNext =\n//     Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);\n//   const preAndNext =\n//     Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);\n//   // 以 currentPoint 为顶点的夹角\n//   const currentAngle = Math.acos(\n//     (currentAndPre + currentAndNext - preAndNext) /\n//     (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)),\n//   );\n//   // 夹角为空、 0 或 PI 时，不需要计算夹角处的额外宽度\n//   // 注意: 由于计算精度问题，夹角为 0 的情况计算出来的角度可能是一个很小的值，还需要判断其与 0 是否近似相等\n//   if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual(currentAngle, 0)) {\n//     return {\n//       xExtra: 0,\n//       yExtra: 0,\n//     };\n//   }\n//   let xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));\n//   let yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));\n//   // 将夹角转为锐角\n//   xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;\n//   yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;\n//   // 这里不考虑在水平和垂直方向的投影，直接使用最大差值\n//   // 由于上层统一加减了二分之一线宽，这里需要进行弥补\n//   const extra = {\n//     // 水平方向投影\n//     xExtra:\n//       Math.cos(currentAngle / 2 - xAngle) * ((lineWidth / 2) * (1 / Math.sin(currentAngle / 2))) -\n//       lineWidth / 2 || 0,\n//     // 垂直方向投影\n//     yExtra:\n//       Math.cos(yAngle - currentAngle / 2) * ((lineWidth / 2) * (1 / Math.sin(currentAngle / 2))) -\n//       lineWidth / 2 || 0,\n//   };\n//   return extra;\n// }"]},"metadata":{},"sourceType":"module"}