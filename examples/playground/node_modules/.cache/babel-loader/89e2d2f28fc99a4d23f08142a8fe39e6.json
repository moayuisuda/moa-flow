{"ast":null,"code":"var TAU = Math.PI * 2;\n\nvar mapToEllipse = function (_a, rx, ry, cosphi, sinphi, centerx, centery) {\n  var x = _a.x,\n      y = _a.y;\n  x *= rx;\n  y *= ry;\n  var xp = cosphi * x - sinphi * y;\n  var yp = sinphi * x + cosphi * y;\n  return {\n    x: xp + centerx,\n    y: yp + centery\n  };\n};\n\nvar approxUnitArc = function (ang1, ang2) {\n  // If 90 degree circular arc, use a constant\n  // as derived from http://spencermortensen.com/articles/bezier-circle\n  var a = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n  var x1 = Math.cos(ang1);\n  var y1 = Math.sin(ang1);\n  var x2 = Math.cos(ang1 + ang2);\n  var y2 = Math.sin(ang1 + ang2);\n  return [{\n    x: x1 - y1 * a,\n    y: y1 + x1 * a\n  }, {\n    x: x2 + y2 * a,\n    y: y2 - x2 * a\n  }, {\n    x: x2,\n    y: y2\n  }];\n};\n\nvar vectorAngle = function (ux, uy, vx, vy) {\n  var sign = ux * vy - uy * vx < 0 ? -1 : 1;\n  var dot = ux * vx + uy * vy;\n\n  if (dot > 1) {\n    dot = 1;\n  }\n\n  if (dot < -1) {\n    dot = -1;\n  }\n\n  return sign * Math.acos(dot);\n};\n\nvar getArcCenter = function (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {\n  var rxsq = Math.pow(rx, 2);\n  var rysq = Math.pow(ry, 2);\n  var pxpsq = Math.pow(pxp, 2);\n  var pypsq = Math.pow(pyp, 2);\n  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;\n\n  if (radicant < 0) {\n    radicant = 0;\n  }\n\n  radicant /= rxsq * pypsq + rysq * pxpsq;\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n  var centerxp = radicant * rx / ry * pyp;\n  var centeryp = radicant * -ry / rx * pxp;\n  var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;\n  var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;\n  var vx1 = (pxp - centerxp) / rx;\n  var vy1 = (pyp - centeryp) / ry;\n  var vx2 = (-pxp - centerxp) / rx;\n  var vy2 = (-pyp - centeryp) / ry;\n  var ang1 = vectorAngle(1, 0, vx1, vy1);\n  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU;\n  }\n\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU;\n  }\n\n  return [centerx, centery, ang1, ang2];\n};\n\nvar arcToBezier = function (_a) {\n  var px = _a.px,\n      py = _a.py,\n      cx = _a.cx,\n      cy = _a.cy,\n      rx = _a.rx,\n      ry = _a.ry,\n      _b = _a.xAxisRotation,\n      xAxisRotation = _b === void 0 ? 0 : _b,\n      _c = _a.largeArcFlag,\n      largeArcFlag = _c === void 0 ? 0 : _c,\n      _d = _a.sweepFlag,\n      sweepFlag = _d === void 0 ? 0 : _d;\n  var curves = [];\n\n  if (rx === 0 || ry === 0) {\n    return [{\n      x1: 0,\n      y1: 0,\n      x2: 0,\n      y2: 0,\n      x: cx,\n      y: cy\n    }];\n  }\n\n  var sinphi = Math.sin(xAxisRotation * TAU / 360);\n  var cosphi = Math.cos(xAxisRotation * TAU / 360);\n  var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;\n  var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;\n\n  if (pxp === 0 && pyp === 0) {\n    return [{\n      x1: 0,\n      y1: 0,\n      x2: 0,\n      y2: 0,\n      x: cx,\n      y: cy\n    }];\n  }\n\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n\n  var _e = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp),\n      centerx = _e[0],\n      centery = _e[1],\n      ang1 = _e[2],\n      ang2 = _e[3]; // If 'ang2' == 90.0000000001, then `ratio` will evaluate to\n  // 1.0000000001. This causes `segments` to be greater than one, which is an\n  // unecessary split, and adds extra points to the bezier curve. To alleviate\n  // this issue, we round to 1.0 when the ratio is close to 1.0.\n\n\n  var ratio = Math.abs(ang2) / (TAU / 4);\n\n  if (Math.abs(1.0 - ratio) < 0.0000001) {\n    ratio = 1.0;\n  }\n\n  var segments = Math.max(Math.ceil(ratio), 1);\n  ang2 /= segments;\n\n  for (var i = 0; i < segments; i++) {\n    curves.push(approxUnitArc(ang1, ang2));\n    ang1 += ang2;\n  }\n\n  return curves.map(function (curve) {\n    var _a = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery),\n        x1 = _a.x,\n        y1 = _a.y;\n\n    var _b = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery),\n        x2 = _b.x,\n        y2 = _b.y;\n\n    var _c = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery),\n        x = _c.x,\n        y = _c.y;\n\n    return {\n      x1: x1,\n      y1: y1,\n      x2: x2,\n      y2: y2,\n      x: x,\n      y: y\n    };\n  });\n};\n\nexport function arcToCubic(x1, y1, rx, ry, angle, LAF, SF, x2, y2) {\n  var curves = arcToBezier({\n    px: x1,\n    py: y1,\n    cx: x2,\n    cy: y2,\n    rx: rx,\n    ry: ry,\n    xAxisRotation: angle,\n    largeArcFlag: LAF,\n    sweepFlag: SF\n  });\n  return curves.reduce(function (prev, cur) {\n    var x1 = cur.x1,\n        y1 = cur.y1,\n        x2 = cur.x2,\n        y2 = cur.y2,\n        x = cur.x,\n        y = cur.y;\n    prev.push(x1, y1, x2, y2, x, y);\n    return prev;\n  }, []);\n}","map":{"version":3,"mappings":"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","names":["TAU","Math","PI","mapToEllipse","_a","rx","ry","cosphi","sinphi","centerx","centery","x","y","xp","yp","approxUnitArc","ang1","ang2","a","tan","x1","cos","y1","sin","x2","y2","vectorAngle","ux","uy","vx","vy","sign","dot","acos","getArcCenter","px","py","cx","cy","largeArcFlag","sweepFlag","pxp","pyp","rxsq","pow","rysq","pxpsq","pypsq","radicant","sqrt","centerxp","centeryp","vx1","vy1","vx2","vy2","arcToBezier","_b","xAxisRotation","_c","_d","curves","abs","lambda","ratio","segments","max","ceil","i","push","map","curve","arcToCubic","angle","LAF","SF","reduce","prev","cur"],"sources":["/Users/dennis.zhang/Desktop/其它代码库/moa-flow/node_modules/@antv/path-util/src/process/arc-2-cubic.ts"],"sourcesContent":["const TAU = Math.PI * 2\n\nconst mapToEllipse = ({ x, y }: { x: number, y: number }, rx: number, ry: number, cosphi: number, sinphi: number, centerx: number, centery: number) => {\n  x *= rx\n  y *= ry\n\n  const xp = cosphi * x - sinphi * y\n  const yp = sinphi * x + cosphi * y\n\n  return {\n    x: xp + centerx,\n    y: yp + centery\n  }\n}\n\nconst approxUnitArc = (ang1: number, ang2: number) => {\n  // If 90 degree circular arc, use a constant\n  // as derived from http://spencermortensen.com/articles/bezier-circle\n  const a = ang2 === 1.5707963267948966\n    ? 0.551915024494\n    : ang2 === -1.5707963267948966\n      ? -0.551915024494\n      : 4 / 3 * Math.tan(ang2 / 4)\n\n  const x1 = Math.cos(ang1)\n  const y1 = Math.sin(ang1)\n  const x2 = Math.cos(ang1 + ang2)\n  const y2 = Math.sin(ang1 + ang2)\n\n  return [\n    {\n      x: x1 - y1 * a,\n      y: y1 + x1 * a\n    },\n    {\n      x: x2 + y2 * a,\n      y: y2 - x2 * a\n    },\n    {\n      x: x2,\n      y: y2\n    }\n  ]\n}\n\nconst vectorAngle = (ux: number, uy: number, vx: number, vy: number) => {\n  const sign = (ux * vy - uy * vx < 0) ? -1 : 1\n\n  let dot = ux * vx + uy * vy\n\n  if (dot > 1) {\n    dot = 1\n  }\n\n  if (dot < -1) {\n    dot = -1\n  }\n\n  return sign * Math.acos(dot)\n}\n\nconst getArcCenter = (\n  px: any,\n  py: any,\n  cx: any,\n  cy: any,\n  rx: number,\n  ry: number,\n  largeArcFlag: number,\n  sweepFlag: number,\n  sinphi: number,\n  cosphi: number,\n  pxp: number,\n  pyp: number\n) => {\n  const rxsq = Math.pow(rx, 2)\n  const rysq = Math.pow(ry, 2)\n  const pxpsq = Math.pow(pxp, 2)\n  const pypsq = Math.pow(pyp, 2)\n\n  let radicant = (rxsq * rysq) - (rxsq * pypsq) - (rysq * pxpsq)\n\n  if (radicant < 0) {\n    radicant = 0\n  }\n\n  radicant /= (rxsq * pypsq) + (rysq * pxpsq)\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1)\n\n  const centerxp = radicant * rx / ry * pyp\n  const centeryp = radicant * -ry / rx * pxp\n\n  const centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2\n  const centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2\n\n  const vx1 = (pxp - centerxp) / rx\n  const vy1 = (pyp - centeryp) / ry\n  const vx2 = (-pxp - centerxp) / rx\n  const vy2 = (-pyp - centeryp) / ry\n\n  let ang1 = vectorAngle(1, 0, vx1, vy1)\n  let ang2 = vectorAngle(vx1, vy1, vx2, vy2)\n\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU\n  }\n\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU\n  }\n\n  return [ centerx, centery, ang1, ang2 ]\n}\n\nconst arcToBezier = ({\n  px,\n  py,\n  cx,\n  cy,\n  rx,\n  ry,\n  xAxisRotation = 0,\n  largeArcFlag = 0,\n  sweepFlag = 0\n}) => {\n  const curves = []\n\n  if (rx === 0 || ry === 0) {\n    return [{ x1: 0, y1: 0, x2: 0, y2: 0, x: cx, y: cy }];\n  }\n\n  const sinphi = Math.sin(xAxisRotation * TAU / 360)\n  const cosphi = Math.cos(xAxisRotation * TAU / 360)\n\n  const pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2\n  const pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2\n\n  if (pxp === 0 && pyp === 0) {\n    return [{ x1: 0, y1: 0, x2: 0, y2: 0, x: cx, y: cy }];\n  }\n\n  rx = Math.abs(rx)\n  ry = Math.abs(ry)\n\n  const lambda =\n    Math.pow(pxp, 2) / Math.pow(rx, 2) +\n    Math.pow(pyp, 2) / Math.pow(ry, 2)\n\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda)\n    ry *= Math.sqrt(lambda)\n  }\n\n  let [ centerx, centery, ang1, ang2 ] = getArcCenter(\n    px,\n    py,\n    cx,\n    cy,\n    rx,\n    ry,\n    largeArcFlag,\n    sweepFlag,\n    sinphi,\n    cosphi,\n    pxp,\n    pyp\n  )\n\n  // If 'ang2' == 90.0000000001, then `ratio` will evaluate to\n  // 1.0000000001. This causes `segments` to be greater than one, which is an\n  // unecessary split, and adds extra points to the bezier curve. To alleviate\n  // this issue, we round to 1.0 when the ratio is close to 1.0.\n  let ratio = Math.abs(ang2) / (TAU / 4)\n  if (Math.abs(1.0 - ratio) < 0.0000001) {\n    ratio = 1.0\n  }\n\n  const segments = Math.max(Math.ceil(ratio), 1)\n\n  ang2 /= segments\n\n  for (let i = 0; i < segments; i++) {\n    curves.push(approxUnitArc(ang1, ang2))\n    ang1 += ang2\n  }\n\n  return curves.map(curve => {\n    const { x: x1, y: y1 } = mapToEllipse(curve[ 0 ], rx, ry, cosphi, sinphi, centerx, centery)\n    const { x: x2, y: y2 } = mapToEllipse(curve[ 1 ], rx, ry, cosphi, sinphi, centerx, centery)\n    const { x, y } = mapToEllipse(curve[ 2 ], rx, ry, cosphi, sinphi, centerx, centery)\n\n    return { x1, y1, x2, y2, x, y }\n  })\n}\n\nexport function arcToCubic(x1: number, y1: number, rx: number, ry: number, angle: number, LAF: number, SF: number, x2: number, y2: number) {\n  const curves = arcToBezier({\n    px: x1,\n    py: y1,\n    cx: x2,\n    cy: y2,\n    rx,\n    ry,\n    xAxisRotation: angle,\n    largeArcFlag: LAF,\n    sweepFlag: SF,\n  });\n\n  return curves.reduce((prev, cur) => {\n    const { x1, y1, x2, y2, x, y } = cur;\n    prev.push(x1, y1, x2, y2, x, y);\n    return prev;\n  }, [] as number[]);\n}\n"]},"metadata":{},"sourceType":"module"}