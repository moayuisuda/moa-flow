{"ast":null,"code":"import { __read, __spreadArray } from \"tslib\";\nimport { distance } from './util';\nvar EPSILON = 0.0001;\n/**\n * 使用牛顿切割法求最近的点\n * @param {number[]} xArr      点的 x 数组\n * @param {number[]} yArr      点的 y 数组\n * @param {number}   x         指定的点 x\n * @param {number}   y         指定的点 y\n * @param {Function} tCallback 差值函数\n */\n\nexport function nearestPoint(xArr, yArr, x, y, tCallback, length) {\n  var t = -1;\n  var d = Infinity;\n  var v0 = [x, y];\n  var segNum = 20;\n\n  if (length && length > 200) {\n    segNum = length / 10;\n  }\n\n  var increaseRate = 1 / segNum;\n  var interval = increaseRate / 10;\n\n  for (var i = 0; i <= segNum; i++) {\n    var _t = i * increaseRate;\n\n    var v1 = [tCallback.apply(void 0, __spreadArray([], __read(xArr.concat([_t])), false)), tCallback.apply(void 0, __spreadArray([], __read(yArr.concat([_t])), false))];\n    var d1 = distance(v0[0], v0[1], v1[0], v1[1]);\n\n    if (d1 < d) {\n      t = _t;\n      d = d1;\n    }\n  } // 提前终止\n\n\n  if (t === 0) {\n    return {\n      x: xArr[0],\n      y: yArr[0]\n    };\n  }\n\n  if (t === 1) {\n    var count = xArr.length;\n    return {\n      x: xArr[count - 1],\n      y: yArr[count - 1]\n    };\n  }\n\n  d = Infinity;\n\n  for (var i = 0; i < 32; i++) {\n    if (interval < EPSILON) {\n      break;\n    }\n\n    var prev = t - interval;\n    var next = t + interval;\n    var v1 = [tCallback.apply(void 0, __spreadArray([], __read(xArr.concat([prev])), false)), tCallback.apply(void 0, __spreadArray([], __read(yArr.concat([prev])), false))];\n    var d1 = distance(v0[0], v0[1], v1[0], v1[1]);\n\n    if (prev >= 0 && d1 < d) {\n      t = prev;\n      d = d1;\n    } else {\n      var v2 = [tCallback.apply(void 0, __spreadArray([], __read(xArr.concat([next])), false)), tCallback.apply(void 0, __spreadArray([], __read(yArr.concat([next])), false))];\n      var d2 = distance(v0[0], v0[1], v2[0], v2[1]);\n\n      if (next <= 1 && d2 < d) {\n        t = next;\n        d = d2;\n      } else {\n        interval *= 0.5;\n      }\n    }\n  }\n\n  return {\n    x: tCallback.apply(void 0, __spreadArray([], __read(xArr.concat([t])), false)),\n    y: tCallback.apply(void 0, __spreadArray([], __read(yArr.concat([t])), false))\n  };\n} // 近似求解 https://community.khronos.org/t/3d-cubic-bezier-segment-length/62363/2\n\nexport function snapLength(xArr, yArr) {\n  var totalLength = 0;\n  var count = xArr.length;\n\n  for (var i = 0; i < count; i++) {\n    var x = xArr[i];\n    var y = yArr[i];\n    var nextX = xArr[(i + 1) % count];\n    var nextY = yArr[(i + 1) % count];\n    totalLength += distance(x, y, nextX, nextY);\n  }\n\n  return totalLength / 2;\n}","map":{"version":3,"sources":["/Users/dennis.zhang/Desktop/其它代码库/moa-flow/node_modules/@antv/g-math/es/bezier.js"],"names":["__read","__spreadArray","distance","EPSILON","nearestPoint","xArr","yArr","x","y","tCallback","length","t","d","Infinity","v0","segNum","increaseRate","interval","i","_t","v1","apply","concat","d1","count","prev","next","v2","d2","snapLength","totalLength","nextX","nextY"],"mappings":"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","sourcesContent":["import { __read, __spreadArray } from \"tslib\";\nimport { distance } from './util';\nvar EPSILON = 0.0001;\n/**\n * 使用牛顿切割法求最近的点\n * @param {number[]} xArr      点的 x 数组\n * @param {number[]} yArr      点的 y 数组\n * @param {number}   x         指定的点 x\n * @param {number}   y         指定的点 y\n * @param {Function} tCallback 差值函数\n */\n\nexport function nearestPoint(xArr, yArr, x, y, tCallback, length) {\n  var t = -1;\n  var d = Infinity;\n  var v0 = [x, y];\n  var segNum = 20;\n\n  if (length && length > 200) {\n    segNum = length / 10;\n  }\n\n  var increaseRate = 1 / segNum;\n  var interval = increaseRate / 10;\n\n  for (var i = 0; i <= segNum; i++) {\n    var _t = i * increaseRate;\n\n    var v1 = [tCallback.apply(void 0, __spreadArray([], __read(xArr.concat([_t])), false)), tCallback.apply(void 0, __spreadArray([], __read(yArr.concat([_t])), false))];\n    var d1 = distance(v0[0], v0[1], v1[0], v1[1]);\n\n    if (d1 < d) {\n      t = _t;\n      d = d1;\n    }\n  } // 提前终止\n\n\n  if (t === 0) {\n    return {\n      x: xArr[0],\n      y: yArr[0]\n    };\n  }\n\n  if (t === 1) {\n    var count = xArr.length;\n    return {\n      x: xArr[count - 1],\n      y: yArr[count - 1]\n    };\n  }\n\n  d = Infinity;\n\n  for (var i = 0; i < 32; i++) {\n    if (interval < EPSILON) {\n      break;\n    }\n\n    var prev = t - interval;\n    var next = t + interval;\n    var v1 = [tCallback.apply(void 0, __spreadArray([], __read(xArr.concat([prev])), false)), tCallback.apply(void 0, __spreadArray([], __read(yArr.concat([prev])), false))];\n    var d1 = distance(v0[0], v0[1], v1[0], v1[1]);\n\n    if (prev >= 0 && d1 < d) {\n      t = prev;\n      d = d1;\n    } else {\n      var v2 = [tCallback.apply(void 0, __spreadArray([], __read(xArr.concat([next])), false)), tCallback.apply(void 0, __spreadArray([], __read(yArr.concat([next])), false))];\n      var d2 = distance(v0[0], v0[1], v2[0], v2[1]);\n\n      if (next <= 1 && d2 < d) {\n        t = next;\n        d = d2;\n      } else {\n        interval *= 0.5;\n      }\n    }\n  }\n\n  return {\n    x: tCallback.apply(void 0, __spreadArray([], __read(xArr.concat([t])), false)),\n    y: tCallback.apply(void 0, __spreadArray([], __read(yArr.concat([t])), false))\n  };\n} // 近似求解 https://community.khronos.org/t/3d-cubic-bezier-segment-length/62363/2\n\nexport function snapLength(xArr, yArr) {\n  var totalLength = 0;\n  var count = xArr.length;\n\n  for (var i = 0; i < count; i++) {\n    var x = xArr[i];\n    var y = yArr[i];\n    var nextX = xArr[(i + 1) % count];\n    var nextY = yArr[(i + 1) % count];\n    totalLength += distance(x, y, nextX, nextY);\n  }\n\n  return totalLength / 2;\n}"]},"metadata":{},"sourceType":"module"}