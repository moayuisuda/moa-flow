{"ast":null,"code":"import { mat4, quat, vec3 } from 'gl-matrix';\n/**\n * do RTS transformation for 2D/3D\n */\n\nvar Transform =\n/** @class */\nfunction () {\n  function Transform() {\n    this.dirtyFlag = false;\n    this.localDirtyFlag = false;\n    this.frozen = false;\n    /**\n     * local space RTS\n     */\n\n    this.localPosition = vec3.fromValues(0, 0, 0);\n    this.localRotation = quat.fromValues(0, 0, 0, 1);\n    this.localScale = vec3.fromValues(1, 1, 1);\n    this.localTransform = mat4.create();\n    /**\n     * world space RTS\n     */\n\n    this.position = vec3.fromValues(0, 0, 0);\n    this.rotation = quat.fromValues(0, 0, 0, 1);\n    this.scaling = vec3.fromValues(1, 1, 1);\n    this.worldTransform = mat4.create();\n    /**\n     * the origin of scaling and rotation\n     */\n\n    this.origin = vec3.fromValues(0, 0, 0); // /**\n    //  * apply lerp to RTS, which can be used in camera animation\n    //  *\n    //  * @see https://xiaoiver.github.io/coding/2018/12/28/Camera-%E8%AE%BE%E8%AE%A1-%E4%B8%80.html\n    //  */\n    // lerp = (() => {\n    //   const aS = vec3.create();\n    //   const aR = quat.create();\n    //   const aT = vec3.create();\n    //   const bS = vec3.create();\n    //   const bR = quat.create();\n    //   const bT = vec3.create();\n    //   return (a: Transform, b: Transform, t: number) => {\n    //     this.setDirty();\n    //     mat4.getScaling(aS, a.worldTransform);\n    //     mat4.getTranslation(aT, a.worldTransform);\n    //     mat4.getRotation(aR, a.worldTransform);\n    //     mat4.getScaling(bS, b.worldTransform);\n    //     mat4.getTranslation(bT, b.worldTransform);\n    //     mat4.getRotation(bR, b.worldTransform);\n    //     vec3.lerp(this.localScale, aS, bS, t);\n    //     quat.slerp(this.localRotation, aR, bR, t);\n    //     vec3.lerp(this.localPosition, aT, bT, t);\n    //   };\n    // })();\n  }\n\n  Transform.tag = 'c-transform';\n  return Transform;\n}();\n\nexport { Transform };","map":{"version":3,"sources":["/Users/dennis.zhang/Desktop/其它代码库/moa-flow/node_modules/@antv/g/es/components/Transform.js"],"names":["mat4","quat","vec3","Transform","dirtyFlag","localDirtyFlag","frozen","localPosition","fromValues","localRotation","localScale","localTransform","create","position","rotation","scaling","worldTransform","origin","tag"],"mappings":"AAAA,SAASA,IAAT,EAAeC,IAAf,EAAqBC,IAArB,QAAiC,WAAjC;AACA;AACA;AACA;;AAEA,IAAIC,SAAS;AACb;AACA,YAAY;AACV,WAASA,SAAT,GAAqB;AACnB,SAAKC,SAAL,GAAiB,KAAjB;AACA,SAAKC,cAAL,GAAsB,KAAtB;AACA,SAAKC,MAAL,GAAc,KAAd;AACA;AACJ;AACA;;AAEI,SAAKC,aAAL,GAAqBL,IAAI,CAACM,UAAL,CAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,CAArB;AACA,SAAKC,aAAL,GAAqBR,IAAI,CAACO,UAAL,CAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,CAArB;AACA,SAAKE,UAAL,GAAkBR,IAAI,CAACM,UAAL,CAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,CAAlB;AACA,SAAKG,cAAL,GAAsBX,IAAI,CAACY,MAAL,EAAtB;AACA;AACJ;AACA;;AAEI,SAAKC,QAAL,GAAgBX,IAAI,CAACM,UAAL,CAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,CAAhB;AACA,SAAKM,QAAL,GAAgBb,IAAI,CAACO,UAAL,CAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,CAAhB;AACA,SAAKO,OAAL,GAAeb,IAAI,CAACM,UAAL,CAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,CAAf;AACA,SAAKQ,cAAL,GAAsBhB,IAAI,CAACY,MAAL,EAAtB;AACA;AACJ;AACA;;AAEI,SAAKK,MAAL,GAAcf,IAAI,CAACM,UAAL,CAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,CAAd,CAxBmB,CAwBqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACD;;AAEDL,EAAAA,SAAS,CAACe,GAAV,GAAgB,aAAhB;AACA,SAAOf,SAAP;AACD,CAtDD,EAFA;;AA0DA,SAASA,SAAT","sourcesContent":["import { mat4, quat, vec3 } from 'gl-matrix';\n/**\n * do RTS transformation for 2D/3D\n */\n\nvar Transform =\n/** @class */\nfunction () {\n  function Transform() {\n    this.dirtyFlag = false;\n    this.localDirtyFlag = false;\n    this.frozen = false;\n    /**\n     * local space RTS\n     */\n\n    this.localPosition = vec3.fromValues(0, 0, 0);\n    this.localRotation = quat.fromValues(0, 0, 0, 1);\n    this.localScale = vec3.fromValues(1, 1, 1);\n    this.localTransform = mat4.create();\n    /**\n     * world space RTS\n     */\n\n    this.position = vec3.fromValues(0, 0, 0);\n    this.rotation = quat.fromValues(0, 0, 0, 1);\n    this.scaling = vec3.fromValues(1, 1, 1);\n    this.worldTransform = mat4.create();\n    /**\n     * the origin of scaling and rotation\n     */\n\n    this.origin = vec3.fromValues(0, 0, 0); // /**\n    //  * apply lerp to RTS, which can be used in camera animation\n    //  *\n    //  * @see https://xiaoiver.github.io/coding/2018/12/28/Camera-%E8%AE%BE%E8%AE%A1-%E4%B8%80.html\n    //  */\n    // lerp = (() => {\n    //   const aS = vec3.create();\n    //   const aR = quat.create();\n    //   const aT = vec3.create();\n    //   const bS = vec3.create();\n    //   const bR = quat.create();\n    //   const bT = vec3.create();\n    //   return (a: Transform, b: Transform, t: number) => {\n    //     this.setDirty();\n    //     mat4.getScaling(aS, a.worldTransform);\n    //     mat4.getTranslation(aT, a.worldTransform);\n    //     mat4.getRotation(aR, a.worldTransform);\n    //     mat4.getScaling(bS, b.worldTransform);\n    //     mat4.getTranslation(bT, b.worldTransform);\n    //     mat4.getRotation(bR, b.worldTransform);\n    //     vec3.lerp(this.localScale, aS, bS, t);\n    //     quat.slerp(this.localRotation, aR, bR, t);\n    //     vec3.lerp(this.localPosition, aT, bT, t);\n    //   };\n    // })();\n  }\n\n  Transform.tag = 'c-transform';\n  return Transform;\n}();\n\nexport { Transform };"]},"metadata":{},"sourceType":"module"}