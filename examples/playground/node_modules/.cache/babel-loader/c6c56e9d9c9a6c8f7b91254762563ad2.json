{"ast":null,"code":"import { distance, getBBoxByArray } from './util';\nimport { vec2 } from 'gl-matrix';\nexport default {\n  /**\n   * 计算线段的包围盒\n   * @param {number} x1 起始点 x\n   * @param {number} y1 起始点 y\n   * @param {number} x2 结束点 x\n   * @param {number} y2 结束点 y\n   * @return {object} 包围盒对象\n   */\n  box: function box(x1, y1, x2, y2) {\n    return getBBoxByArray([x1, x2], [y1, y2]);\n  },\n\n  /**\n   * 线段的长度\n   * @param {number} x1 起始点 x\n   * @param {number} y1 起始点 y\n   * @param {number} x2 结束点 x\n   * @param {number} y2 结束点 y\n   * @return {number} 距离\n   */\n  length: function length(x1, y1, x2, y2) {\n    return distance(x1, y1, x2, y2);\n  },\n\n  /**\n   * 根据比例获取点\n   * @param {number} x1 起始点 x\n   * @param {number} y1 起始点 y\n   * @param {number} x2 结束点 x\n   * @param {number} y2 结束点 y\n   * @param {number} t 指定比例\n   * @return {object} 包含 x, y 的点\n   */\n  pointAt: function pointAt(x1, y1, x2, y2, t) {\n    return {\n      x: (1 - t) * x1 + t * x2,\n      y: (1 - t) * y1 + t * y2\n    };\n  },\n\n  /**\n   * 点到线段的距离\n   * @param {number} x1 起始点 x\n   * @param {number} y1 起始点 y\n   * @param {number} x2 结束点 x\n   * @param {number} y2 结束点 y\n   * @param {number} x  测试点 x\n   * @param {number} y  测试点 y\n   * @return {number} 距离\n   */\n  pointDistance: function pointDistance(x1, y1, x2, y2, x, y) {\n    // 投影距离 x1, y1 的向量，假设 p, p1, p2 三个点，投影点为 a\n    // p1a = p1p.p1p2/|p1p2| * (p1p 的单位向量)\n    var cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);\n\n    if (cross < 0) {\n      return distance(x1, y1, x, y);\n    }\n\n    var lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n\n    if (cross > lengthSquare) {\n      return distance(x2, y2, x, y);\n    }\n\n    return this.pointToLine(x1, y1, x2, y2, x, y);\n  },\n\n  /**\n   * 点到直线的距离，而不是点到线段的距离\n   * @param {number} x1 起始点 x\n   * @param {number} y1 起始点 y\n   * @param {number} x2 结束点 x\n   * @param {number} y2 结束点 y\n   * @param {number} x  测试点 x\n   * @param {number} y  测试点 y\n   * @return {number} 距离\n   */\n  pointToLine: function pointToLine(x1, y1, x2, y2, x, y) {\n    var d = [x2 - x1, y2 - y1]; // 如果端点相等，则判定点到点的距离\n\n    if (vec2.exactEquals(d, [0, 0])) {\n      return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\n    }\n\n    var u = [-d[1], d[0]];\n    vec2.normalize(u, u);\n    var a = [x - x1, y - y1];\n    return Math.abs(vec2.dot(a, u));\n  },\n\n  /**\n   * 线段的角度\n   * @param {number} x1 起始点 x\n   * @param {number} y1 起始点 y\n   * @param {number} x2 结束点 x\n   * @param {number} y2 结束点 y\n   * @return {number} 导数\n   */\n  tangentAngle: function tangentAngle(x1, y1, x2, y2) {\n    return Math.atan2(y2 - y1, x2 - x1);\n  }\n};","map":{"version":3,"sources":["/Users/dennis.zhang/Desktop/其它代码库/moa-flow/node_modules/@antv/g-math/es/line.js"],"names":["distance","getBBoxByArray","vec2","box","x1","y1","x2","y2","length","pointAt","t","x","y","pointDistance","cross","lengthSquare","pointToLine","d","exactEquals","Math","sqrt","u","normalize","a","abs","dot","tangentAngle","atan2"],"mappings":"AAAA,SAASA,QAAT,EAAmBC,cAAnB,QAAyC,QAAzC;AACA,SAASC,IAAT,QAAqB,WAArB;AACA,eAAe;AACb;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACEC,EAAAA,GAAG,EAAE,SAASA,GAAT,CAAaC,EAAb,EAAiBC,EAAjB,EAAqBC,EAArB,EAAyBC,EAAzB,EAA6B;AAChC,WAAON,cAAc,CAAC,CAACG,EAAD,EAAKE,EAAL,CAAD,EAAW,CAACD,EAAD,EAAKE,EAAL,CAAX,CAArB;AACD,GAXY;;AAab;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACEC,EAAAA,MAAM,EAAE,SAASA,MAAT,CAAgBJ,EAAhB,EAAoBC,EAApB,EAAwBC,EAAxB,EAA4BC,EAA5B,EAAgC;AACtC,WAAOP,QAAQ,CAACI,EAAD,EAAKC,EAAL,EAASC,EAAT,EAAaC,EAAb,CAAf;AACD,GAvBY;;AAyBb;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEE,EAAAA,OAAO,EAAE,SAASA,OAAT,CAAiBL,EAAjB,EAAqBC,EAArB,EAAyBC,EAAzB,EAA6BC,EAA7B,EAAiCG,CAAjC,EAAoC;AAC3C,WAAO;AACLC,MAAAA,CAAC,EAAE,CAAC,IAAID,CAAL,IAAUN,EAAV,GAAeM,CAAC,GAAGJ,EADjB;AAELM,MAAAA,CAAC,EAAE,CAAC,IAAIF,CAAL,IAAUL,EAAV,GAAeK,CAAC,GAAGH;AAFjB,KAAP;AAID,GAvCY;;AAyCb;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEM,EAAAA,aAAa,EAAE,SAASA,aAAT,CAAuBT,EAAvB,EAA2BC,EAA3B,EAA+BC,EAA/B,EAAmCC,EAAnC,EAAuCI,CAAvC,EAA0CC,CAA1C,EAA6C;AAC1D;AACA;AACA,QAAIE,KAAK,GAAG,CAACR,EAAE,GAAGF,EAAN,KAAaO,CAAC,GAAGP,EAAjB,IAAuB,CAACG,EAAE,GAAGF,EAAN,KAAaO,CAAC,GAAGP,EAAjB,CAAnC;;AAEA,QAAIS,KAAK,GAAG,CAAZ,EAAe;AACb,aAAOd,QAAQ,CAACI,EAAD,EAAKC,EAAL,EAASM,CAAT,EAAYC,CAAZ,CAAf;AACD;;AAED,QAAIG,YAAY,GAAG,CAACT,EAAE,GAAGF,EAAN,KAAaE,EAAE,GAAGF,EAAlB,IAAwB,CAACG,EAAE,GAAGF,EAAN,KAAaE,EAAE,GAAGF,EAAlB,CAA3C;;AAEA,QAAIS,KAAK,GAAGC,YAAZ,EAA0B;AACxB,aAAOf,QAAQ,CAACM,EAAD,EAAKC,EAAL,EAASI,CAAT,EAAYC,CAAZ,CAAf;AACD;;AAED,WAAO,KAAKI,WAAL,CAAiBZ,EAAjB,EAAqBC,EAArB,EAAyBC,EAAzB,EAA6BC,EAA7B,EAAiCI,CAAjC,EAAoCC,CAApC,CAAP;AACD,GAnEY;;AAqEb;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEI,EAAAA,WAAW,EAAE,SAASA,WAAT,CAAqBZ,EAArB,EAAyBC,EAAzB,EAA6BC,EAA7B,EAAiCC,EAAjC,EAAqCI,CAArC,EAAwCC,CAAxC,EAA2C;AACtD,QAAIK,CAAC,GAAG,CAACX,EAAE,GAAGF,EAAN,EAAUG,EAAE,GAAGF,EAAf,CAAR,CADsD,CAC1B;;AAE5B,QAAIH,IAAI,CAACgB,WAAL,CAAiBD,CAAjB,EAAoB,CAAC,CAAD,EAAI,CAAJ,CAApB,CAAJ,EAAiC;AAC/B,aAAOE,IAAI,CAACC,IAAL,CAAU,CAACT,CAAC,GAAGP,EAAL,KAAYO,CAAC,GAAGP,EAAhB,IAAsB,CAACQ,CAAC,GAAGP,EAAL,KAAYO,CAAC,GAAGP,EAAhB,CAAhC,CAAP;AACD;;AAED,QAAIgB,CAAC,GAAG,CAAC,CAACJ,CAAC,CAAC,CAAD,CAAH,EAAQA,CAAC,CAAC,CAAD,CAAT,CAAR;AACAf,IAAAA,IAAI,CAACoB,SAAL,CAAeD,CAAf,EAAkBA,CAAlB;AACA,QAAIE,CAAC,GAAG,CAACZ,CAAC,GAAGP,EAAL,EAASQ,CAAC,GAAGP,EAAb,CAAR;AACA,WAAOc,IAAI,CAACK,GAAL,CAAStB,IAAI,CAACuB,GAAL,CAASF,CAAT,EAAYF,CAAZ,CAAT,CAAP;AACD,GA1FY;;AA4Fb;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACEK,EAAAA,YAAY,EAAE,SAASA,YAAT,CAAsBtB,EAAtB,EAA0BC,EAA1B,EAA8BC,EAA9B,EAAkCC,EAAlC,EAAsC;AAClD,WAAOY,IAAI,CAACQ,KAAL,CAAWpB,EAAE,GAAGF,EAAhB,EAAoBC,EAAE,GAAGF,EAAzB,CAAP;AACD;AAtGY,CAAf","sourcesContent":["import { distance, getBBoxByArray } from './util';\nimport { vec2 } from 'gl-matrix';\nexport default {\n  /**\n   * 计算线段的包围盒\n   * @param {number} x1 起始点 x\n   * @param {number} y1 起始点 y\n   * @param {number} x2 结束点 x\n   * @param {number} y2 结束点 y\n   * @return {object} 包围盒对象\n   */\n  box: function box(x1, y1, x2, y2) {\n    return getBBoxByArray([x1, x2], [y1, y2]);\n  },\n\n  /**\n   * 线段的长度\n   * @param {number} x1 起始点 x\n   * @param {number} y1 起始点 y\n   * @param {number} x2 结束点 x\n   * @param {number} y2 结束点 y\n   * @return {number} 距离\n   */\n  length: function length(x1, y1, x2, y2) {\n    return distance(x1, y1, x2, y2);\n  },\n\n  /**\n   * 根据比例获取点\n   * @param {number} x1 起始点 x\n   * @param {number} y1 起始点 y\n   * @param {number} x2 结束点 x\n   * @param {number} y2 结束点 y\n   * @param {number} t 指定比例\n   * @return {object} 包含 x, y 的点\n   */\n  pointAt: function pointAt(x1, y1, x2, y2, t) {\n    return {\n      x: (1 - t) * x1 + t * x2,\n      y: (1 - t) * y1 + t * y2\n    };\n  },\n\n  /**\n   * 点到线段的距离\n   * @param {number} x1 起始点 x\n   * @param {number} y1 起始点 y\n   * @param {number} x2 结束点 x\n   * @param {number} y2 结束点 y\n   * @param {number} x  测试点 x\n   * @param {number} y  测试点 y\n   * @return {number} 距离\n   */\n  pointDistance: function pointDistance(x1, y1, x2, y2, x, y) {\n    // 投影距离 x1, y1 的向量，假设 p, p1, p2 三个点，投影点为 a\n    // p1a = p1p.p1p2/|p1p2| * (p1p 的单位向量)\n    var cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);\n\n    if (cross < 0) {\n      return distance(x1, y1, x, y);\n    }\n\n    var lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n\n    if (cross > lengthSquare) {\n      return distance(x2, y2, x, y);\n    }\n\n    return this.pointToLine(x1, y1, x2, y2, x, y);\n  },\n\n  /**\n   * 点到直线的距离，而不是点到线段的距离\n   * @param {number} x1 起始点 x\n   * @param {number} y1 起始点 y\n   * @param {number} x2 结束点 x\n   * @param {number} y2 结束点 y\n   * @param {number} x  测试点 x\n   * @param {number} y  测试点 y\n   * @return {number} 距离\n   */\n  pointToLine: function pointToLine(x1, y1, x2, y2, x, y) {\n    var d = [x2 - x1, y2 - y1]; // 如果端点相等，则判定点到点的距离\n\n    if (vec2.exactEquals(d, [0, 0])) {\n      return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\n    }\n\n    var u = [-d[1], d[0]];\n    vec2.normalize(u, u);\n    var a = [x - x1, y - y1];\n    return Math.abs(vec2.dot(a, u));\n  },\n\n  /**\n   * 线段的角度\n   * @param {number} x1 起始点 x\n   * @param {number} y1 起始点 y\n   * @param {number} x2 结束点 x\n   * @param {number} y2 结束点 y\n   * @return {number} 导数\n   */\n  tangentAngle: function tangentAngle(x1, y1, x2, y2) {\n    return Math.atan2(y2 - y1, x2 - x1);\n  }\n};"]},"metadata":{},"sourceType":"module"}