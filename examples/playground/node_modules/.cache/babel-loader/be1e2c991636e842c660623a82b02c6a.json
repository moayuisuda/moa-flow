{"ast":null,"code":"/**\n * https://github.com/gre/bezier-easing\n * BezierEasing - use bezier curve for transition easing function\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\n */\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\nexport var NEWTON_ITERATIONS = 4;\nexport var NEWTON_MIN_SLOPE = 0.001;\nexport var SUBDIVISION_PRECISION = 0.0000001;\nexport var SUBDIVISION_MAX_ITERATIONS = 10;\nexport var kSplineTableSize = 11;\nexport var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nexport var float32ArraySupported = typeof Float32Array === 'function';\nexport var A = function A(aA1, aA2) {\n  return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n};\nexport var B = function B(aA1, aA2) {\n  return 3.0 * aA2 - 6.0 * aA1;\n};\nexport var C = function C(aA1) {\n  return 3.0 * aA1;\n}; // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n\nexport var calcBezier = function calcBezier(aT, aA1, aA2) {\n  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n}; // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\n\nexport var getSlope = function getSlope(aT, aA1, aA2) {\n  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n};\nexport var binarySubdivide = function binarySubdivide(aX, aA, aB, mX1, mX2) {\n  var currentX,\n      currentT,\n      i = 0;\n\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0.0) aB = currentT;else aA = currentT;\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n\n  return currentT;\n};\nexport var newtonRaphsonIterate = function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n    var currentSlope = getSlope(aGuessT, mX1, mX2);\n    if (currentSlope === 0.0) return aGuessT;\n    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n\n  return aGuessT;\n};\nexport var bezier = function bezier(mX1, mY1, mX2, mY2) {\n  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) throw new Error('bezier x values must be in [0, 1] range');\n  if (mX1 === mY1 && mX2 === mY2) return function (t) {\n    return t;\n  }; // Precompute samples table\n\n  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n\n  for (var i = 0; i < kSplineTableSize; ++i) {\n    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n  }\n\n  var getTForX = function getTForX(aX) {\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n\n    --currentSample; // Interpolate to provide an initial guess for t\n\n    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n    if (initialSlope >= NEWTON_MIN_SLOPE) return newtonRaphsonIterate(aX, guessForT, mX1, mX2);else if (initialSlope === 0.0) return guessForT;else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  };\n\n  return function (t) {\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (t === 0 || t === 1) return t;\n    return calcBezier(getTForX(t), mY1, mY2);\n  };\n};","map":{"version":3,"sources":["/Users/dennis.zhang/Desktop/其它代码库/moa-flow/node_modules/@antv/g/es/utils/bezier-easing.js"],"names":["NEWTON_ITERATIONS","NEWTON_MIN_SLOPE","SUBDIVISION_PRECISION","SUBDIVISION_MAX_ITERATIONS","kSplineTableSize","kSampleStepSize","float32ArraySupported","Float32Array","A","aA1","aA2","B","C","calcBezier","aT","getSlope","binarySubdivide","aX","aA","aB","mX1","mX2","currentX","currentT","i","Math","abs","newtonRaphsonIterate","aGuessT","currentSlope","bezier","mY1","mY2","Error","t","sampleValues","Array","getTForX","intervalStart","currentSample","lastSample","dist","guessForT","initialSlope"],"mappings":"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","sourcesContent":["/**\n * https://github.com/gre/bezier-easing\n * BezierEasing - use bezier curve for transition easing function\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\n */\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\nexport var NEWTON_ITERATIONS = 4;\nexport var NEWTON_MIN_SLOPE = 0.001;\nexport var SUBDIVISION_PRECISION = 0.0000001;\nexport var SUBDIVISION_MAX_ITERATIONS = 10;\nexport var kSplineTableSize = 11;\nexport var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nexport var float32ArraySupported = typeof Float32Array === 'function';\nexport var A = function A(aA1, aA2) {\n  return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n};\nexport var B = function B(aA1, aA2) {\n  return 3.0 * aA2 - 6.0 * aA1;\n};\nexport var C = function C(aA1) {\n  return 3.0 * aA1;\n}; // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n\nexport var calcBezier = function calcBezier(aT, aA1, aA2) {\n  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n}; // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\n\nexport var getSlope = function getSlope(aT, aA1, aA2) {\n  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n};\nexport var binarySubdivide = function binarySubdivide(aX, aA, aB, mX1, mX2) {\n  var currentX,\n      currentT,\n      i = 0;\n\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0.0) aB = currentT;else aA = currentT;\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n\n  return currentT;\n};\nexport var newtonRaphsonIterate = function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n    var currentSlope = getSlope(aGuessT, mX1, mX2);\n    if (currentSlope === 0.0) return aGuessT;\n    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n\n  return aGuessT;\n};\nexport var bezier = function bezier(mX1, mY1, mX2, mY2) {\n  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) throw new Error('bezier x values must be in [0, 1] range');\n  if (mX1 === mY1 && mX2 === mY2) return function (t) {\n    return t;\n  }; // Precompute samples table\n\n  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n\n  for (var i = 0; i < kSplineTableSize; ++i) {\n    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n  }\n\n  var getTForX = function getTForX(aX) {\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n\n    --currentSample; // Interpolate to provide an initial guess for t\n\n    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n    if (initialSlope >= NEWTON_MIN_SLOPE) return newtonRaphsonIterate(aX, guessForT, mX1, mX2);else if (initialSlope === 0.0) return guessForT;else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  };\n\n  return function (t) {\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (t === 0 || t === 1) return t;\n    return calcBezier(getTForX(t), mY1, mY2);\n  };\n};"]},"metadata":{},"sourceType":"module"}