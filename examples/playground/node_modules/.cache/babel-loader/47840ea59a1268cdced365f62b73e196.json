{"ast":null,"code":"import { ElementEvent } from './interfaces';\nimport { MutationEvent } from './MutationEvent';\nimport { MutationRecord } from './MutationRecord';\nvar uidCounter = 0;\nvar registrationsTable = new WeakMap();\n\nvar Registration =\n/** @class */\nfunction () {\n  function Registration(observer, target, options) {\n    this.observer = observer;\n    this.target = target;\n    this.options = options;\n    this.transientObservedNodes = [];\n  }\n\n  Registration.prototype.enqueue = function (record) {\n    var records = this.observer.records;\n    var length = records.length; // There are cases where we replace the last record with the new record.\n    // For example if the record represents the same mutation we need to use\n    // the one with the oldValue. If we get same record (this can happen as we\n    // walk up the tree) we ignore the new record.\n\n    if (records.length > 0) {\n      var lastRecord = records[length - 1];\n      var recordToReplaceLast = selectRecord(lastRecord, record);\n\n      if (recordToReplaceLast) {\n        records[length - 1] = recordToReplaceLast;\n        return;\n      }\n    } else {\n      scheduleCallback(this.observer);\n    }\n\n    records[length] = record;\n  };\n\n  Registration.prototype.addListeners = function () {\n    this.addListeners_(this.target);\n  };\n\n  Registration.prototype.addListeners_ = function (node) {\n    var options = this.options;\n    if (options.attributes) node.addEventListener(ElementEvent.ATTR_MODIFIED, this, true); // if (options.characterData) node.addEventListener('DOMCharacterDataModified', this, true);\n\n    if (options.childList) node.addEventListener(ElementEvent.INSERTED, this, true);\n    if (options.childList || options.subtree) node.addEventListener(ElementEvent.REMOVED, this, true);\n  };\n\n  Registration.prototype.removeListeners = function () {\n    this.removeListeners_(this.target);\n  };\n\n  Registration.prototype.removeListeners_ = function (node) {\n    var options = this.options;\n    if (options.attributes) node.removeEventListener(ElementEvent.ATTR_MODIFIED, this, true); // if (options.characterData) node.removeEventListener('DOMCharacterDataModified', this, true);\n\n    if (options.childList) node.removeEventListener(ElementEvent.INSERTED, this, true);\n    if (options.childList || options.subtree) node.removeEventListener(ElementEvent.REMOVED, this, true);\n  };\n  /**\n   * Adds a transient observer on node. The transient observer gets removed\n   * next time we deliver the change records.\n   */\n  // addTransientObserver(node: IElement) {\n  //   // Don't add transient observers on the target itself. We already have all\n  //   // the required listeners set up on the target.\n  //   if (node === this.target) return;\n  //   this.addListeners_(node);\n  //   this.transientObservedNodes.push(node);\n  //   let registrations = registrationsTable.get(node);\n  //   if (!registrations) registrationsTable.set(node, (registrations = []));\n  //   // We know that registrations does not contain this because we already\n  //   // checked if node === this.target.\n  //   registrations.push(this);\n  // }\n\n\n  Registration.prototype.removeTransientObservers = function () {\n    var transientObservedNodes = this.transientObservedNodes;\n    this.transientObservedNodes = [];\n    transientObservedNodes.forEach(function (node) {\n      // Transient observers are never added to the target.\n      this.removeListeners_(node);\n      var registrations = registrationsTable.get(node);\n\n      for (var i = 0; i < registrations.length; i++) {\n        if (registrations[i] === this) {\n          registrations.splice(i, 1); // Each node can only have one registered observer associated with\n          // this observer.\n\n          break;\n        }\n      }\n    }, this);\n  };\n\n  Registration.prototype.handleEvent = function (e) {\n    // Stop propagation since we are managing the propagation manually.\n    // This means that other mutation events on the page will not work\n    // correctly but that is by design.\n    e.stopImmediatePropagation();\n    var record;\n    var target;\n\n    switch (e.type) {\n      case ElementEvent.ATTR_MODIFIED:\n        // http://dom.spec.whatwg.org/#concept-mo-queue-attributes\n        var name_1 = e.attrName; // @ts-ignore\n\n        var namespace_1 = e.relatedNode.namespaceURI;\n        target = e.target; // 1.\n\n        record = getRecord('attributes', target);\n        record.attributeName = name_1;\n        record.attributeNamespace = namespace_1; // 2.\n\n        var oldValue_1 = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;\n        forEachAncestorAndObserverEnqueueRecord(target, function (options) {\n          // 3.1, 4.2\n          if (!options.attributes) return; // 3.2, 4.3\n\n          if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name_1) === -1 && options.attributeFilter.indexOf(namespace_1) === -1) {\n            return;\n          } // 3.3, 4.4\n\n\n          if (options.attributeOldValue) return getRecordWithOldValue(oldValue_1); // 3.4, 4.5\n\n          return record;\n        });\n        break;\n      // case 'DOMCharacterDataModified':\n      //   // http://dom.spec.whatwg.org/#concept-mo-queue-characterdata\n      //   var target = e.target;\n      //   // 1.\n      //   var record = getRecord('characterData', target);\n      //   // 2.\n      //   var oldValue = e.prevValue;\n      //   forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n      //     // 3.1, 4.2\n      //     if (!options.characterData)\n      //       return;\n      //     // 3.2, 4.3\n      //     if (options.characterDataOldValue)\n      //       return getRecordWithOldValue(oldValue);\n      //     // 3.3, 4.4\n      //     return record;\n      //   });\n      //   break;\n\n      case ElementEvent.REMOVED: // this.addTransientObserver(e.target as IElement);\n      // Fall through.\n\n      case ElementEvent.INSERTED:\n        // http://dom.spec.whatwg.org/#concept-mo-queue-childlist\n        target = e.relatedNode;\n        var changedNode = e.target;\n        var addedNodes = void 0;\n        var removedNodes = void 0;\n\n        if (e.type === ElementEvent.INSERTED) {\n          addedNodes = [changedNode];\n          removedNodes = [];\n        } else {\n          addedNodes = [];\n          removedNodes = [changedNode];\n        }\n\n        var previousSibling = changedNode.previousSibling;\n        var nextSibling = changedNode.nextSibling; // 1.\n\n        record = getRecord('childList', target);\n        record.addedNodes = addedNodes;\n        record.removedNodes = removedNodes;\n        record.previousSibling = previousSibling;\n        record.nextSibling = nextSibling;\n        forEachAncestorAndObserverEnqueueRecord(target, function (options) {\n          // 2.1, 3.2\n          if (!options.childList) return; // 2.2, 3.3\n\n          return record;\n        });\n    }\n\n    clearRecords();\n  };\n\n  return Registration;\n}();\n\nexport { Registration };\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver\n * @see https://github.com/googlearchive/MutationObservers/blob/master/MutationObserver.js\n */\n\nvar MutationObserver =\n/** @class */\nfunction () {\n  function MutationObserver(callback) {\n    this.callback = callback;\n    this.nodes = [];\n    this.records = [];\n    this.uid = uidCounter++;\n  }\n\n  MutationObserver.prototype.observe = function (target, options) {\n    // 1.1\n    if (!options.childList && !options.attributes && !options.characterData || // 1.2\n    options.attributeOldValue && !options.attributes || // 1.3\n    options.attributeFilter && options.attributeFilter.length && !options.attributes || // 1.4\n    options.characterDataOldValue && !options.characterData) {\n      throw new SyntaxError();\n    }\n\n    var registrations = registrationsTable.get(target);\n    if (!registrations) registrationsTable.set(target, registrations = []); // 2\n    // If target's list of registered observers already includes a registered\n    // observer associated with the context object, replace that registered\n    // observer's options with options.\n\n    var registration;\n\n    for (var i = 0; i < registrations.length; i++) {\n      if (registrations[i].observer === this) {\n        registration = registrations[i];\n        registration.removeListeners();\n        registration.options = options;\n        break;\n      }\n    } // 3.\n    // Otherwise, add a new registered observer to target's list of registered\n    // observers with the context object as the observer and options as the\n    // options, and add target to context object's list of nodes on which it\n    // is registered.\n\n\n    if (!registration) {\n      registration = new Registration(this, target, options);\n      registrations.push(registration);\n      this.nodes.push(target);\n    }\n\n    registration.addListeners();\n  };\n\n  MutationObserver.prototype.disconnect = function () {\n    var _this = this;\n\n    this.nodes.forEach(function (node) {\n      var registrations = registrationsTable.get(node);\n\n      for (var i = 0; i < registrations.length; i++) {\n        var registration = registrations[i];\n\n        if (registration.observer === _this) {\n          registration.removeListeners();\n          registrations.splice(i, 1); // Each node can only have one registered observer associated with\n          // this observer.\n\n          break;\n        }\n      }\n    }, this);\n    this.records = [];\n  };\n\n  MutationObserver.prototype.takeRecords = function () {\n    var copyOfRecords = this.records;\n    this.records = [];\n    return copyOfRecords;\n  };\n\n  return MutationObserver;\n}();\n\nexport { MutationObserver }; // We keep track of the two (possibly one) records used in a single mutation.\n\nvar currentRecord;\nvar recordWithOldValue;\n/**\n * Creates a record without |oldValue| and caches it as |currentRecord| for\n * later use.\n */\n\nfunction getRecord(type, target) {\n  return currentRecord = new MutationRecord(type, target);\n}\n/**\n * Gets or creates a record with |oldValue| based in the |currentRecord|\n */\n\n\nfunction getRecordWithOldValue(oldValue) {\n  if (recordWithOldValue) return recordWithOldValue;\n  recordWithOldValue = MutationRecord.copy(currentRecord);\n  recordWithOldValue.oldValue = oldValue;\n  return recordWithOldValue;\n}\n\nfunction clearRecords() {\n  currentRecord = recordWithOldValue = undefined;\n}\n/**\n * Whether the record represents a record from the current\n * mutation event.\n */\n\n\nfunction recordRepresentsCurrentMutation(record) {\n  return record === recordWithOldValue || record === currentRecord;\n}\n/**\n * Selects which record, if any, to replace the last record in the queue.\n * This returns |null| if no record should be replaced.\n */\n\n\nfunction selectRecord(lastRecord, newRecord) {\n  if (lastRecord === newRecord) return lastRecord; // Check if the the record we are adding represents the same record. If\n  // so, we keep the one with the oldValue in it.\n\n  if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;\n  return null;\n}\n\nfunction removeTransientObserversFor(observer) {\n  observer.nodes.forEach(function (node) {\n    var registrations = registrationsTable.get(node);\n    if (!registrations) return;\n    registrations.forEach(function (registration) {\n      if (registration.observer === observer) registration.removeTransientObservers();\n    });\n  });\n}\n/**\n * This function is used for the \"For each registered observer observer (with\n * observer's options as options) in target's list of registered observers,\n * run these substeps:\" and the \"For each ancestor ancestor of target, and for\n * each registered observer observer (with options options) in ancestor's list\n * of registered observers, run these substeps:\" part of the algorithms. The\n * |options.subtree| is checked to ensure that the callback is called\n * correctly.\n *\n * @param {Node} target\n * @param {function(MutationObserverInit):MutationRecord} callback\n */\n\n\nfunction forEachAncestorAndObserverEnqueueRecord(target, callback) {\n  for (var node = target; node; node = node.parentNode) {\n    var registrations = registrationsTable.get(node);\n\n    if (registrations) {\n      for (var j = 0; j < registrations.length; j++) {\n        var registration = registrations[j];\n        var options = registration.options; // Only target ignores subtree.\n\n        if (node !== target && !options.subtree) continue;\n        var record = callback(options);\n        if (record) registration.enqueue(record);\n      }\n    }\n  }\n} // This is used to ensure that we never schedule 2 callas to setImmediate\n\n\nvar isScheduled = false; // Keep track of observers that needs to be notified next time.\n\nvar scheduledObservers = [];\n/**\n * Schedules |dispatchCallback| to be called in the future.\n */\n\nfunction scheduleCallback(observer) {\n  scheduledObservers.push(observer);\n\n  if (!isScheduled) {\n    isScheduled = true; // setImmediate(dispatchCallbacks);\n\n    if (typeof globalThis !== 'undefined') {\n      globalThis.setTimeout(dispatchCallbacks);\n    } else {\n      dispatchCallbacks();\n    }\n  }\n}\n\nfunction dispatchCallbacks() {\n  // http://dom.spec.whatwg.org/#mutation-observers\n  isScheduled = false; // Used to allow a new setImmediate call above.\n\n  var observers = scheduledObservers;\n  scheduledObservers = []; // Sort observers based on their creation UID (incremental).\n\n  observers.sort(function (o1, o2) {\n    return o1.uid - o2.uid;\n  });\n  var anyNonEmpty = false;\n  observers.forEach(function (observer) {\n    // 2.1, 2.2\n    var queue = observer.takeRecords(); // 2.3. Remove all transient registered observers whose observer is mo.\n\n    removeTransientObserversFor(observer); // 2.4\n\n    if (queue.length) {\n      // @ts-ignore\n      observer.callback(queue, observer);\n      anyNonEmpty = true;\n    }\n  }); // 3.\n\n  if (anyNonEmpty) dispatchCallbacks();\n}","map":{"version":3,"sources":["/Users/dennis.zhang/Desktop/其它代码库/moa-flow/node_modules/@antv/g/es/dom/MutationObserver.js"],"names":["ElementEvent","MutationEvent","MutationRecord","uidCounter","registrationsTable","WeakMap","Registration","observer","target","options","transientObservedNodes","prototype","enqueue","record","records","length","lastRecord","recordToReplaceLast","selectRecord","scheduleCallback","addListeners","addListeners_","node","attributes","addEventListener","ATTR_MODIFIED","childList","INSERTED","subtree","REMOVED","removeListeners","removeListeners_","removeEventListener","removeTransientObservers","forEach","registrations","get","i","splice","handleEvent","e","stopImmediatePropagation","type","name_1","attrName","namespace_1","relatedNode","namespaceURI","getRecord","attributeName","attributeNamespace","oldValue_1","attrChange","ADDITION","prevValue","forEachAncestorAndObserverEnqueueRecord","attributeFilter","indexOf","attributeOldValue","getRecordWithOldValue","changedNode","addedNodes","removedNodes","previousSibling","nextSibling","clearRecords","MutationObserver","callback","nodes","uid","observe","characterData","characterDataOldValue","SyntaxError","set","registration","push","disconnect","_this","takeRecords","copyOfRecords","currentRecord","recordWithOldValue","oldValue","copy","undefined","recordRepresentsCurrentMutation","newRecord","removeTransientObserversFor","parentNode","j","isScheduled","scheduledObservers","globalThis","setTimeout","dispatchCallbacks","observers","sort","o1","o2","anyNonEmpty","queue"],"mappings":"AAAA,SAASA,YAAT,QAA6B,cAA7B;AACA,SAASC,aAAT,QAA8B,iBAA9B;AACA,SAASC,cAAT,QAA+B,kBAA/B;AACA,IAAIC,UAAU,GAAG,CAAjB;AACA,IAAIC,kBAAkB,GAAG,IAAIC,OAAJ,EAAzB;;AAEA,IAAIC,YAAY;AAChB;AACA,YAAY;AACV,WAASA,YAAT,CAAsBC,QAAtB,EAAgCC,MAAhC,EAAwCC,OAAxC,EAAiD;AAC/C,SAAKF,QAAL,GAAgBA,QAAhB;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKC,sBAAL,GAA8B,EAA9B;AACD;;AAEDJ,EAAAA,YAAY,CAACK,SAAb,CAAuBC,OAAvB,GAAiC,UAAUC,MAAV,EAAkB;AACjD,QAAIC,OAAO,GAAG,KAAKP,QAAL,CAAcO,OAA5B;AACA,QAAIC,MAAM,GAAGD,OAAO,CAACC,MAArB,CAFiD,CAEpB;AAC7B;AACA;AACA;;AAEA,QAAID,OAAO,CAACC,MAAR,GAAiB,CAArB,EAAwB;AACtB,UAAIC,UAAU,GAAGF,OAAO,CAACC,MAAM,GAAG,CAAV,CAAxB;AACA,UAAIE,mBAAmB,GAAGC,YAAY,CAACF,UAAD,EAAaH,MAAb,CAAtC;;AAEA,UAAII,mBAAJ,EAAyB;AACvBH,QAAAA,OAAO,CAACC,MAAM,GAAG,CAAV,CAAP,GAAsBE,mBAAtB;AACA;AACD;AACF,KARD,MAQO;AACLE,MAAAA,gBAAgB,CAAC,KAAKZ,QAAN,CAAhB;AACD;;AAEDO,IAAAA,OAAO,CAACC,MAAD,CAAP,GAAkBF,MAAlB;AACD,GApBD;;AAsBAP,EAAAA,YAAY,CAACK,SAAb,CAAuBS,YAAvB,GAAsC,YAAY;AAChD,SAAKC,aAAL,CAAmB,KAAKb,MAAxB;AACD,GAFD;;AAIAF,EAAAA,YAAY,CAACK,SAAb,CAAuBU,aAAvB,GAAuC,UAAUC,IAAV,EAAgB;AACrD,QAAIb,OAAO,GAAG,KAAKA,OAAnB;AACA,QAAIA,OAAO,CAACc,UAAZ,EAAwBD,IAAI,CAACE,gBAAL,CAAsBxB,YAAY,CAACyB,aAAnC,EAAkD,IAAlD,EAAwD,IAAxD,EAF6B,CAEkC;;AAEvF,QAAIhB,OAAO,CAACiB,SAAZ,EAAuBJ,IAAI,CAACE,gBAAL,CAAsBxB,YAAY,CAAC2B,QAAnC,EAA6C,IAA7C,EAAmD,IAAnD;AACvB,QAAIlB,OAAO,CAACiB,SAAR,IAAqBjB,OAAO,CAACmB,OAAjC,EAA0CN,IAAI,CAACE,gBAAL,CAAsBxB,YAAY,CAAC6B,OAAnC,EAA4C,IAA5C,EAAkD,IAAlD;AAC3C,GAND;;AAQAvB,EAAAA,YAAY,CAACK,SAAb,CAAuBmB,eAAvB,GAAyC,YAAY;AACnD,SAAKC,gBAAL,CAAsB,KAAKvB,MAA3B;AACD,GAFD;;AAIAF,EAAAA,YAAY,CAACK,SAAb,CAAuBoB,gBAAvB,GAA0C,UAAUT,IAAV,EAAgB;AACxD,QAAIb,OAAO,GAAG,KAAKA,OAAnB;AACA,QAAIA,OAAO,CAACc,UAAZ,EAAwBD,IAAI,CAACU,mBAAL,CAAyBhC,YAAY,CAACyB,aAAtC,EAAqD,IAArD,EAA2D,IAA3D,EAFgC,CAEkC;;AAE1F,QAAIhB,OAAO,CAACiB,SAAZ,EAAuBJ,IAAI,CAACU,mBAAL,CAAyBhC,YAAY,CAAC2B,QAAtC,EAAgD,IAAhD,EAAsD,IAAtD;AACvB,QAAIlB,OAAO,CAACiB,SAAR,IAAqBjB,OAAO,CAACmB,OAAjC,EAA0CN,IAAI,CAACU,mBAAL,CAAyBhC,YAAY,CAAC6B,OAAtC,EAA+C,IAA/C,EAAqD,IAArD;AAC3C,GAND;AAOA;AACF;AACA;AACA;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGAvB,EAAAA,YAAY,CAACK,SAAb,CAAuBsB,wBAAvB,GAAkD,YAAY;AAC5D,QAAIvB,sBAAsB,GAAG,KAAKA,sBAAlC;AACA,SAAKA,sBAAL,GAA8B,EAA9B;AACAA,IAAAA,sBAAsB,CAACwB,OAAvB,CAA+B,UAAUZ,IAAV,EAAgB;AAC7C;AACA,WAAKS,gBAAL,CAAsBT,IAAtB;AACA,UAAIa,aAAa,GAAG/B,kBAAkB,CAACgC,GAAnB,CAAuBd,IAAvB,CAApB;;AAEA,WAAK,IAAIe,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,aAAa,CAACpB,MAAlC,EAA0CsB,CAAC,EAA3C,EAA+C;AAC7C,YAAIF,aAAa,CAACE,CAAD,CAAb,KAAqB,IAAzB,EAA+B;AAC7BF,UAAAA,aAAa,CAACG,MAAd,CAAqBD,CAArB,EAAwB,CAAxB,EAD6B,CACD;AAC5B;;AAEA;AACD;AACF;AACF,KAbD,EAaG,IAbH;AAcD,GAjBD;;AAmBA/B,EAAAA,YAAY,CAACK,SAAb,CAAuB4B,WAAvB,GAAqC,UAAUC,CAAV,EAAa;AAChD;AACA;AACA;AACAA,IAAAA,CAAC,CAACC,wBAAF;AACA,QAAI5B,MAAJ;AACA,QAAIL,MAAJ;;AAEA,YAAQgC,CAAC,CAACE,IAAV;AACE,WAAK1C,YAAY,CAACyB,aAAlB;AACE;AACA,YAAIkB,MAAM,GAAGH,CAAC,CAACI,QAAf,CAFF,CAE2B;;AAEzB,YAAIC,WAAW,GAAGL,CAAC,CAACM,WAAF,CAAcC,YAAhC;AACAvC,QAAAA,MAAM,GAAGgC,CAAC,CAAChC,MAAX,CALF,CAKqB;;AAEnBK,QAAAA,MAAM,GAAGmC,SAAS,CAAC,YAAD,EAAexC,MAAf,CAAlB;AACAK,QAAAA,MAAM,CAACoC,aAAP,GAAuBN,MAAvB;AACA9B,QAAAA,MAAM,CAACqC,kBAAP,GAA4BL,WAA5B,CATF,CAS2C;;AAEzC,YAAIM,UAAU,GAAGX,CAAC,CAACY,UAAF,KAAiBnD,aAAa,CAACoD,QAA/B,GAA0C,IAA1C,GAAiDb,CAAC,CAACc,SAApE;AACAC,QAAAA,uCAAuC,CAAC/C,MAAD,EAAS,UAAUC,OAAV,EAAmB;AACjE;AACA,cAAI,CAACA,OAAO,CAACc,UAAb,EAAyB,OAFwC,CAEhC;;AAEjC,cAAId,OAAO,CAAC+C,eAAR,IAA2B/C,OAAO,CAAC+C,eAAR,CAAwBzC,MAAnD,IAA6DN,OAAO,CAAC+C,eAAR,CAAwBC,OAAxB,CAAgCd,MAAhC,MAA4C,CAAC,CAA1G,IAA+GlC,OAAO,CAAC+C,eAAR,CAAwBC,OAAxB,CAAgCZ,WAAhC,MAAiD,CAAC,CAArK,EAAwK;AACtK;AACD,WANgE,CAM/D;;;AAGF,cAAIpC,OAAO,CAACiD,iBAAZ,EAA+B,OAAOC,qBAAqB,CAACR,UAAD,CAA5B,CATkC,CASQ;;AAEzE,iBAAOtC,MAAP;AACD,SAZsC,CAAvC;AAaA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAKb,YAAY,CAAC6B,OAAlB,CA9CF,CA8C6B;AAC3B;;AAEA,WAAK7B,YAAY,CAAC2B,QAAlB;AACE;AACAnB,QAAAA,MAAM,GAAGgC,CAAC,CAACM,WAAX;AACA,YAAIc,WAAW,GAAGpB,CAAC,CAAChC,MAApB;AACA,YAAIqD,UAAU,GAAG,KAAK,CAAtB;AACA,YAAIC,YAAY,GAAG,KAAK,CAAxB;;AAEA,YAAItB,CAAC,CAACE,IAAF,KAAW1C,YAAY,CAAC2B,QAA5B,EAAsC;AACpCkC,UAAAA,UAAU,GAAG,CAACD,WAAD,CAAb;AACAE,UAAAA,YAAY,GAAG,EAAf;AACD,SAHD,MAGO;AACLD,UAAAA,UAAU,GAAG,EAAb;AACAC,UAAAA,YAAY,GAAG,CAACF,WAAD,CAAf;AACD;;AAED,YAAIG,eAAe,GAAGH,WAAW,CAACG,eAAlC;AACA,YAAIC,WAAW,GAAGJ,WAAW,CAACI,WAA9B,CAhBF,CAgB6C;;AAE3CnD,QAAAA,MAAM,GAAGmC,SAAS,CAAC,WAAD,EAAcxC,MAAd,CAAlB;AACAK,QAAAA,MAAM,CAACgD,UAAP,GAAoBA,UAApB;AACAhD,QAAAA,MAAM,CAACiD,YAAP,GAAsBA,YAAtB;AACAjD,QAAAA,MAAM,CAACkD,eAAP,GAAyBA,eAAzB;AACAlD,QAAAA,MAAM,CAACmD,WAAP,GAAqBA,WAArB;AACAT,QAAAA,uCAAuC,CAAC/C,MAAD,EAAS,UAAUC,OAAV,EAAmB;AACjE;AACA,cAAI,CAACA,OAAO,CAACiB,SAAb,EAAwB,OAFyC,CAEjC;;AAEhC,iBAAOb,MAAP;AACD,SALsC,CAAvC;AAxEJ;;AAgFAoD,IAAAA,YAAY;AACb,GAzFD;;AA2FA,SAAO3D,YAAP;AACD,CAtLD,EAFA;;AA0LA,SAASA,YAAT;AACA;AACA;AACA;AACA;;AAEA,IAAI4D,gBAAgB;AACpB;AACA,YAAY;AACV,WAASA,gBAAT,CAA0BC,QAA1B,EAAoC;AAClC,SAAKA,QAAL,GAAgBA,QAAhB;AACA,SAAKC,KAAL,GAAa,EAAb;AACA,SAAKtD,OAAL,GAAe,EAAf;AACA,SAAKuD,GAAL,GAAWlE,UAAU,EAArB;AACD;;AAED+D,EAAAA,gBAAgB,CAACvD,SAAjB,CAA2B2D,OAA3B,GAAqC,UAAU9D,MAAV,EAAkBC,OAAlB,EAA2B;AAC9D;AACA,QAAI,CAACA,OAAO,CAACiB,SAAT,IAAsB,CAACjB,OAAO,CAACc,UAA/B,IAA6C,CAACd,OAAO,CAAC8D,aAAtD,IAAuE;AAC3E9D,IAAAA,OAAO,CAACiD,iBAAR,IAA6B,CAACjD,OAAO,CAACc,UADlC,IACgD;AACpDd,IAAAA,OAAO,CAAC+C,eAAR,IAA2B/C,OAAO,CAAC+C,eAAR,CAAwBzC,MAAnD,IAA6D,CAACN,OAAO,CAACc,UAFlE,IAEgF;AACpFd,IAAAA,OAAO,CAAC+D,qBAAR,IAAiC,CAAC/D,OAAO,CAAC8D,aAH1C,EAGyD;AACvD,YAAM,IAAIE,WAAJ,EAAN;AACD;;AAED,QAAItC,aAAa,GAAG/B,kBAAkB,CAACgC,GAAnB,CAAuB5B,MAAvB,CAApB;AACA,QAAI,CAAC2B,aAAL,EAAoB/B,kBAAkB,CAACsE,GAAnB,CAAuBlE,MAAvB,EAA+B2B,aAAa,GAAG,EAA/C,EAV0C,CAUU;AACxE;AACA;AACA;;AAEA,QAAIwC,YAAJ;;AAEA,SAAK,IAAItC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,aAAa,CAACpB,MAAlC,EAA0CsB,CAAC,EAA3C,EAA+C;AAC7C,UAAIF,aAAa,CAACE,CAAD,CAAb,CAAiB9B,QAAjB,KAA8B,IAAlC,EAAwC;AACtCoE,QAAAA,YAAY,GAAGxC,aAAa,CAACE,CAAD,CAA5B;AACAsC,QAAAA,YAAY,CAAC7C,eAAb;AACA6C,QAAAA,YAAY,CAAClE,OAAb,GAAuBA,OAAvB;AACA;AACD;AACF,KAxB6D,CAwB5D;AACF;AACA;AACA;AACA;;;AAGA,QAAI,CAACkE,YAAL,EAAmB;AACjBA,MAAAA,YAAY,GAAG,IAAIrE,YAAJ,CAAiB,IAAjB,EAAuBE,MAAvB,EAA+BC,OAA/B,CAAf;AACA0B,MAAAA,aAAa,CAACyC,IAAd,CAAmBD,YAAnB;AACA,WAAKP,KAAL,CAAWQ,IAAX,CAAgBpE,MAAhB;AACD;;AAEDmE,IAAAA,YAAY,CAACvD,YAAb;AACD,GAtCD;;AAwCA8C,EAAAA,gBAAgB,CAACvD,SAAjB,CAA2BkE,UAA3B,GAAwC,YAAY;AAClD,QAAIC,KAAK,GAAG,IAAZ;;AAEA,SAAKV,KAAL,CAAWlC,OAAX,CAAmB,UAAUZ,IAAV,EAAgB;AACjC,UAAIa,aAAa,GAAG/B,kBAAkB,CAACgC,GAAnB,CAAuBd,IAAvB,CAApB;;AAEA,WAAK,IAAIe,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,aAAa,CAACpB,MAAlC,EAA0CsB,CAAC,EAA3C,EAA+C;AAC7C,YAAIsC,YAAY,GAAGxC,aAAa,CAACE,CAAD,CAAhC;;AAEA,YAAIsC,YAAY,CAACpE,QAAb,KAA0BuE,KAA9B,EAAqC;AACnCH,UAAAA,YAAY,CAAC7C,eAAb;AACAK,UAAAA,aAAa,CAACG,MAAd,CAAqBD,CAArB,EAAwB,CAAxB,EAFmC,CAEP;AAC5B;;AAEA;AACD;AACF;AACF,KAdD,EAcG,IAdH;AAeA,SAAKvB,OAAL,GAAe,EAAf;AACD,GAnBD;;AAqBAoD,EAAAA,gBAAgB,CAACvD,SAAjB,CAA2BoE,WAA3B,GAAyC,YAAY;AACnD,QAAIC,aAAa,GAAG,KAAKlE,OAAzB;AACA,SAAKA,OAAL,GAAe,EAAf;AACA,WAAOkE,aAAP;AACD,GAJD;;AAMA,SAAOd,gBAAP;AACD,CA5ED,EAFA;;AAgFA,SAASA,gBAAT,G,CAA6B;;AAE7B,IAAIe,aAAJ;AACA,IAAIC,kBAAJ;AACA;AACA;AACA;AACA;;AAEA,SAASlC,SAAT,CAAmBN,IAAnB,EAAyBlC,MAAzB,EAAiC;AAC/B,SAAOyE,aAAa,GAAG,IAAI/E,cAAJ,CAAmBwC,IAAnB,EAAyBlC,MAAzB,CAAvB;AACD;AACD;AACA;AACA;;;AAGA,SAASmD,qBAAT,CAA+BwB,QAA/B,EAAyC;AACvC,MAAID,kBAAJ,EAAwB,OAAOA,kBAAP;AACxBA,EAAAA,kBAAkB,GAAGhF,cAAc,CAACkF,IAAf,CAAoBH,aAApB,CAArB;AACAC,EAAAA,kBAAkB,CAACC,QAAnB,GAA8BA,QAA9B;AACA,SAAOD,kBAAP;AACD;;AAED,SAASjB,YAAT,GAAwB;AACtBgB,EAAAA,aAAa,GAAGC,kBAAkB,GAAGG,SAArC;AACD;AACD;AACA;AACA;AACA;;;AAGA,SAASC,+BAAT,CAAyCzE,MAAzC,EAAiD;AAC/C,SAAOA,MAAM,KAAKqE,kBAAX,IAAiCrE,MAAM,KAAKoE,aAAnD;AACD;AACD;AACA;AACA;AACA;;;AAGA,SAAS/D,YAAT,CAAsBF,UAAtB,EAAkCuE,SAAlC,EAA6C;AAC3C,MAAIvE,UAAU,KAAKuE,SAAnB,EAA8B,OAAOvE,UAAP,CADa,CACM;AACjD;;AAEA,MAAIkE,kBAAkB,IAAII,+BAA+B,CAACtE,UAAD,CAAzD,EAAuE,OAAOkE,kBAAP;AACvE,SAAO,IAAP;AACD;;AAED,SAASM,2BAAT,CAAqCjF,QAArC,EAA+C;AAC7CA,EAAAA,QAAQ,CAAC6D,KAAT,CAAelC,OAAf,CAAuB,UAAUZ,IAAV,EAAgB;AACrC,QAAIa,aAAa,GAAG/B,kBAAkB,CAACgC,GAAnB,CAAuBd,IAAvB,CAApB;AACA,QAAI,CAACa,aAAL,EAAoB;AACpBA,IAAAA,aAAa,CAACD,OAAd,CAAsB,UAAUyC,YAAV,EAAwB;AAC5C,UAAIA,YAAY,CAACpE,QAAb,KAA0BA,QAA9B,EAAwCoE,YAAY,CAAC1C,wBAAb;AACzC,KAFD;AAGD,GAND;AAOD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASsB,uCAAT,CAAiD/C,MAAjD,EAAyD2D,QAAzD,EAAmE;AACjE,OAAK,IAAI7C,IAAI,GAAGd,MAAhB,EAAwBc,IAAxB,EAA8BA,IAAI,GAAGA,IAAI,CAACmE,UAA1C,EAAsD;AACpD,QAAItD,aAAa,GAAG/B,kBAAkB,CAACgC,GAAnB,CAAuBd,IAAvB,CAApB;;AAEA,QAAIa,aAAJ,EAAmB;AACjB,WAAK,IAAIuD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGvD,aAAa,CAACpB,MAAlC,EAA0C2E,CAAC,EAA3C,EAA+C;AAC7C,YAAIf,YAAY,GAAGxC,aAAa,CAACuD,CAAD,CAAhC;AACA,YAAIjF,OAAO,GAAGkE,YAAY,CAAClE,OAA3B,CAF6C,CAET;;AAEpC,YAAIa,IAAI,KAAKd,MAAT,IAAmB,CAACC,OAAO,CAACmB,OAAhC,EAAyC;AACzC,YAAIf,MAAM,GAAGsD,QAAQ,CAAC1D,OAAD,CAArB;AACA,YAAII,MAAJ,EAAY8D,YAAY,CAAC/D,OAAb,CAAqBC,MAArB;AACb;AACF;AACF;AACF,C,CAAC;;;AAGF,IAAI8E,WAAW,GAAG,KAAlB,C,CAAyB;;AAEzB,IAAIC,kBAAkB,GAAG,EAAzB;AACA;AACA;AACA;;AAEA,SAASzE,gBAAT,CAA0BZ,QAA1B,EAAoC;AAClCqF,EAAAA,kBAAkB,CAAChB,IAAnB,CAAwBrE,QAAxB;;AAEA,MAAI,CAACoF,WAAL,EAAkB;AAChBA,IAAAA,WAAW,GAAG,IAAd,CADgB,CACI;;AAEpB,QAAI,OAAOE,UAAP,KAAsB,WAA1B,EAAuC;AACrCA,MAAAA,UAAU,CAACC,UAAX,CAAsBC,iBAAtB;AACD,KAFD,MAEO;AACLA,MAAAA,iBAAiB;AAClB;AACF;AACF;;AAED,SAASA,iBAAT,GAA6B;AAC3B;AACAJ,EAAAA,WAAW,GAAG,KAAd,CAF2B,CAEN;;AAErB,MAAIK,SAAS,GAAGJ,kBAAhB;AACAA,EAAAA,kBAAkB,GAAG,EAArB,CAL2B,CAKF;;AAEzBI,EAAAA,SAAS,CAACC,IAAV,CAAe,UAAUC,EAAV,EAAcC,EAAd,EAAkB;AAC/B,WAAOD,EAAE,CAAC7B,GAAH,GAAS8B,EAAE,CAAC9B,GAAnB;AACD,GAFD;AAGA,MAAI+B,WAAW,GAAG,KAAlB;AACAJ,EAAAA,SAAS,CAAC9D,OAAV,CAAkB,UAAU3B,QAAV,EAAoB;AACpC;AACA,QAAI8F,KAAK,GAAG9F,QAAQ,CAACwE,WAAT,EAAZ,CAFoC,CAEA;;AAEpCS,IAAAA,2BAA2B,CAACjF,QAAD,CAA3B,CAJoC,CAIG;;AAEvC,QAAI8F,KAAK,CAACtF,MAAV,EAAkB;AAChB;AACAR,MAAAA,QAAQ,CAAC4D,QAAT,CAAkBkC,KAAlB,EAAyB9F,QAAzB;AACA6F,MAAAA,WAAW,GAAG,IAAd;AACD;AACF,GAXD,EAX2B,CAsBvB;;AAEJ,MAAIA,WAAJ,EAAiBL,iBAAiB;AACnC","sourcesContent":["import { ElementEvent } from './interfaces';\nimport { MutationEvent } from './MutationEvent';\nimport { MutationRecord } from './MutationRecord';\nvar uidCounter = 0;\nvar registrationsTable = new WeakMap();\n\nvar Registration =\n/** @class */\nfunction () {\n  function Registration(observer, target, options) {\n    this.observer = observer;\n    this.target = target;\n    this.options = options;\n    this.transientObservedNodes = [];\n  }\n\n  Registration.prototype.enqueue = function (record) {\n    var records = this.observer.records;\n    var length = records.length; // There are cases where we replace the last record with the new record.\n    // For example if the record represents the same mutation we need to use\n    // the one with the oldValue. If we get same record (this can happen as we\n    // walk up the tree) we ignore the new record.\n\n    if (records.length > 0) {\n      var lastRecord = records[length - 1];\n      var recordToReplaceLast = selectRecord(lastRecord, record);\n\n      if (recordToReplaceLast) {\n        records[length - 1] = recordToReplaceLast;\n        return;\n      }\n    } else {\n      scheduleCallback(this.observer);\n    }\n\n    records[length] = record;\n  };\n\n  Registration.prototype.addListeners = function () {\n    this.addListeners_(this.target);\n  };\n\n  Registration.prototype.addListeners_ = function (node) {\n    var options = this.options;\n    if (options.attributes) node.addEventListener(ElementEvent.ATTR_MODIFIED, this, true); // if (options.characterData) node.addEventListener('DOMCharacterDataModified', this, true);\n\n    if (options.childList) node.addEventListener(ElementEvent.INSERTED, this, true);\n    if (options.childList || options.subtree) node.addEventListener(ElementEvent.REMOVED, this, true);\n  };\n\n  Registration.prototype.removeListeners = function () {\n    this.removeListeners_(this.target);\n  };\n\n  Registration.prototype.removeListeners_ = function (node) {\n    var options = this.options;\n    if (options.attributes) node.removeEventListener(ElementEvent.ATTR_MODIFIED, this, true); // if (options.characterData) node.removeEventListener('DOMCharacterDataModified', this, true);\n\n    if (options.childList) node.removeEventListener(ElementEvent.INSERTED, this, true);\n    if (options.childList || options.subtree) node.removeEventListener(ElementEvent.REMOVED, this, true);\n  };\n  /**\n   * Adds a transient observer on node. The transient observer gets removed\n   * next time we deliver the change records.\n   */\n  // addTransientObserver(node: IElement) {\n  //   // Don't add transient observers on the target itself. We already have all\n  //   // the required listeners set up on the target.\n  //   if (node === this.target) return;\n  //   this.addListeners_(node);\n  //   this.transientObservedNodes.push(node);\n  //   let registrations = registrationsTable.get(node);\n  //   if (!registrations) registrationsTable.set(node, (registrations = []));\n  //   // We know that registrations does not contain this because we already\n  //   // checked if node === this.target.\n  //   registrations.push(this);\n  // }\n\n\n  Registration.prototype.removeTransientObservers = function () {\n    var transientObservedNodes = this.transientObservedNodes;\n    this.transientObservedNodes = [];\n    transientObservedNodes.forEach(function (node) {\n      // Transient observers are never added to the target.\n      this.removeListeners_(node);\n      var registrations = registrationsTable.get(node);\n\n      for (var i = 0; i < registrations.length; i++) {\n        if (registrations[i] === this) {\n          registrations.splice(i, 1); // Each node can only have one registered observer associated with\n          // this observer.\n\n          break;\n        }\n      }\n    }, this);\n  };\n\n  Registration.prototype.handleEvent = function (e) {\n    // Stop propagation since we are managing the propagation manually.\n    // This means that other mutation events on the page will not work\n    // correctly but that is by design.\n    e.stopImmediatePropagation();\n    var record;\n    var target;\n\n    switch (e.type) {\n      case ElementEvent.ATTR_MODIFIED:\n        // http://dom.spec.whatwg.org/#concept-mo-queue-attributes\n        var name_1 = e.attrName; // @ts-ignore\n\n        var namespace_1 = e.relatedNode.namespaceURI;\n        target = e.target; // 1.\n\n        record = getRecord('attributes', target);\n        record.attributeName = name_1;\n        record.attributeNamespace = namespace_1; // 2.\n\n        var oldValue_1 = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;\n        forEachAncestorAndObserverEnqueueRecord(target, function (options) {\n          // 3.1, 4.2\n          if (!options.attributes) return; // 3.2, 4.3\n\n          if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name_1) === -1 && options.attributeFilter.indexOf(namespace_1) === -1) {\n            return;\n          } // 3.3, 4.4\n\n\n          if (options.attributeOldValue) return getRecordWithOldValue(oldValue_1); // 3.4, 4.5\n\n          return record;\n        });\n        break;\n      // case 'DOMCharacterDataModified':\n      //   // http://dom.spec.whatwg.org/#concept-mo-queue-characterdata\n      //   var target = e.target;\n      //   // 1.\n      //   var record = getRecord('characterData', target);\n      //   // 2.\n      //   var oldValue = e.prevValue;\n      //   forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n      //     // 3.1, 4.2\n      //     if (!options.characterData)\n      //       return;\n      //     // 3.2, 4.3\n      //     if (options.characterDataOldValue)\n      //       return getRecordWithOldValue(oldValue);\n      //     // 3.3, 4.4\n      //     return record;\n      //   });\n      //   break;\n\n      case ElementEvent.REMOVED: // this.addTransientObserver(e.target as IElement);\n      // Fall through.\n\n      case ElementEvent.INSERTED:\n        // http://dom.spec.whatwg.org/#concept-mo-queue-childlist\n        target = e.relatedNode;\n        var changedNode = e.target;\n        var addedNodes = void 0;\n        var removedNodes = void 0;\n\n        if (e.type === ElementEvent.INSERTED) {\n          addedNodes = [changedNode];\n          removedNodes = [];\n        } else {\n          addedNodes = [];\n          removedNodes = [changedNode];\n        }\n\n        var previousSibling = changedNode.previousSibling;\n        var nextSibling = changedNode.nextSibling; // 1.\n\n        record = getRecord('childList', target);\n        record.addedNodes = addedNodes;\n        record.removedNodes = removedNodes;\n        record.previousSibling = previousSibling;\n        record.nextSibling = nextSibling;\n        forEachAncestorAndObserverEnqueueRecord(target, function (options) {\n          // 2.1, 3.2\n          if (!options.childList) return; // 2.2, 3.3\n\n          return record;\n        });\n    }\n\n    clearRecords();\n  };\n\n  return Registration;\n}();\n\nexport { Registration };\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver\n * @see https://github.com/googlearchive/MutationObservers/blob/master/MutationObserver.js\n */\n\nvar MutationObserver =\n/** @class */\nfunction () {\n  function MutationObserver(callback) {\n    this.callback = callback;\n    this.nodes = [];\n    this.records = [];\n    this.uid = uidCounter++;\n  }\n\n  MutationObserver.prototype.observe = function (target, options) {\n    // 1.1\n    if (!options.childList && !options.attributes && !options.characterData || // 1.2\n    options.attributeOldValue && !options.attributes || // 1.3\n    options.attributeFilter && options.attributeFilter.length && !options.attributes || // 1.4\n    options.characterDataOldValue && !options.characterData) {\n      throw new SyntaxError();\n    }\n\n    var registrations = registrationsTable.get(target);\n    if (!registrations) registrationsTable.set(target, registrations = []); // 2\n    // If target's list of registered observers already includes a registered\n    // observer associated with the context object, replace that registered\n    // observer's options with options.\n\n    var registration;\n\n    for (var i = 0; i < registrations.length; i++) {\n      if (registrations[i].observer === this) {\n        registration = registrations[i];\n        registration.removeListeners();\n        registration.options = options;\n        break;\n      }\n    } // 3.\n    // Otherwise, add a new registered observer to target's list of registered\n    // observers with the context object as the observer and options as the\n    // options, and add target to context object's list of nodes on which it\n    // is registered.\n\n\n    if (!registration) {\n      registration = new Registration(this, target, options);\n      registrations.push(registration);\n      this.nodes.push(target);\n    }\n\n    registration.addListeners();\n  };\n\n  MutationObserver.prototype.disconnect = function () {\n    var _this = this;\n\n    this.nodes.forEach(function (node) {\n      var registrations = registrationsTable.get(node);\n\n      for (var i = 0; i < registrations.length; i++) {\n        var registration = registrations[i];\n\n        if (registration.observer === _this) {\n          registration.removeListeners();\n          registrations.splice(i, 1); // Each node can only have one registered observer associated with\n          // this observer.\n\n          break;\n        }\n      }\n    }, this);\n    this.records = [];\n  };\n\n  MutationObserver.prototype.takeRecords = function () {\n    var copyOfRecords = this.records;\n    this.records = [];\n    return copyOfRecords;\n  };\n\n  return MutationObserver;\n}();\n\nexport { MutationObserver }; // We keep track of the two (possibly one) records used in a single mutation.\n\nvar currentRecord;\nvar recordWithOldValue;\n/**\n * Creates a record without |oldValue| and caches it as |currentRecord| for\n * later use.\n */\n\nfunction getRecord(type, target) {\n  return currentRecord = new MutationRecord(type, target);\n}\n/**\n * Gets or creates a record with |oldValue| based in the |currentRecord|\n */\n\n\nfunction getRecordWithOldValue(oldValue) {\n  if (recordWithOldValue) return recordWithOldValue;\n  recordWithOldValue = MutationRecord.copy(currentRecord);\n  recordWithOldValue.oldValue = oldValue;\n  return recordWithOldValue;\n}\n\nfunction clearRecords() {\n  currentRecord = recordWithOldValue = undefined;\n}\n/**\n * Whether the record represents a record from the current\n * mutation event.\n */\n\n\nfunction recordRepresentsCurrentMutation(record) {\n  return record === recordWithOldValue || record === currentRecord;\n}\n/**\n * Selects which record, if any, to replace the last record in the queue.\n * This returns |null| if no record should be replaced.\n */\n\n\nfunction selectRecord(lastRecord, newRecord) {\n  if (lastRecord === newRecord) return lastRecord; // Check if the the record we are adding represents the same record. If\n  // so, we keep the one with the oldValue in it.\n\n  if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;\n  return null;\n}\n\nfunction removeTransientObserversFor(observer) {\n  observer.nodes.forEach(function (node) {\n    var registrations = registrationsTable.get(node);\n    if (!registrations) return;\n    registrations.forEach(function (registration) {\n      if (registration.observer === observer) registration.removeTransientObservers();\n    });\n  });\n}\n/**\n * This function is used for the \"For each registered observer observer (with\n * observer's options as options) in target's list of registered observers,\n * run these substeps:\" and the \"For each ancestor ancestor of target, and for\n * each registered observer observer (with options options) in ancestor's list\n * of registered observers, run these substeps:\" part of the algorithms. The\n * |options.subtree| is checked to ensure that the callback is called\n * correctly.\n *\n * @param {Node} target\n * @param {function(MutationObserverInit):MutationRecord} callback\n */\n\n\nfunction forEachAncestorAndObserverEnqueueRecord(target, callback) {\n  for (var node = target; node; node = node.parentNode) {\n    var registrations = registrationsTable.get(node);\n\n    if (registrations) {\n      for (var j = 0; j < registrations.length; j++) {\n        var registration = registrations[j];\n        var options = registration.options; // Only target ignores subtree.\n\n        if (node !== target && !options.subtree) continue;\n        var record = callback(options);\n        if (record) registration.enqueue(record);\n      }\n    }\n  }\n} // This is used to ensure that we never schedule 2 callas to setImmediate\n\n\nvar isScheduled = false; // Keep track of observers that needs to be notified next time.\n\nvar scheduledObservers = [];\n/**\n * Schedules |dispatchCallback| to be called in the future.\n */\n\nfunction scheduleCallback(observer) {\n  scheduledObservers.push(observer);\n\n  if (!isScheduled) {\n    isScheduled = true; // setImmediate(dispatchCallbacks);\n\n    if (typeof globalThis !== 'undefined') {\n      globalThis.setTimeout(dispatchCallbacks);\n    } else {\n      dispatchCallbacks();\n    }\n  }\n}\n\nfunction dispatchCallbacks() {\n  // http://dom.spec.whatwg.org/#mutation-observers\n  isScheduled = false; // Used to allow a new setImmediate call above.\n\n  var observers = scheduledObservers;\n  scheduledObservers = []; // Sort observers based on their creation UID (incremental).\n\n  observers.sort(function (o1, o2) {\n    return o1.uid - o2.uid;\n  });\n  var anyNonEmpty = false;\n  observers.forEach(function (observer) {\n    // 2.1, 2.2\n    var queue = observer.takeRecords(); // 2.3. Remove all transient registered observers whose observer is mo.\n\n    removeTransientObserversFor(observer); // 2.4\n\n    if (queue.length) {\n      // @ts-ignore\n      observer.callback(queue, observer);\n      anyNonEmpty = true;\n    }\n  }); // 3.\n\n  if (anyNonEmpty) dispatchCallbacks();\n}"]},"metadata":{},"sourceType":"module"}