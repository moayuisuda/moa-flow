{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { CSSMathValue } from './CSSMathValue';\nimport { CSSNumericValueType, CSSStyleValueType, Nested, ParenLess } from '.';\n\nvar CSSMathInvert =\n/** @class */\nfunction (_super) {\n  __extends(CSSMathInvert, _super);\n\n  function CSSMathInvert(value, type) {\n    var _this = _super.call(this, type) || this;\n\n    _this.value = value;\n    _this.operator = 'invert';\n    return _this;\n  }\n\n  CSSMathInvert.create = function (value) {\n    var type = CSSNumericValueType.negateExponents(value.type_);\n    return new CSSMathInvert(value, type);\n  };\n\n  CSSMathInvert.prototype.clone = function () {\n    return new CSSMathInvert(this.value, this.type_);\n  };\n\n  CSSMathInvert.prototype.getType = function () {\n    return CSSStyleValueType.kInvertType;\n  };\n\n  CSSMathInvert.prototype.equals = function (other) {\n    if (other.getType() !== CSSStyleValueType.kInvertType) {\n      return false;\n    } // We can safely cast here as we know 'other' has the same type as us.\n\n\n    var other_invert = other;\n    return this.value.equals(other_invert.value);\n  };\n\n  CSSMathInvert.prototype.sumValue = function () {\n    var sum = this.value.sumValue();\n\n    if (sum.length === 0 || sum.length !== 1 || sum[0].value === 0) {\n      return null;\n    }\n\n    Object.keys(sum[0].units).forEach(function (key) {\n      sum[0].units[key] *= -1;\n    });\n    sum[0].value = 1.0 / sum[0].value;\n    return sum;\n  }; // toCalcExpressionNode(): CSSMathExpressionNode {\n  //   const right_side = this.value.toCalcExpressionNode();\n  //   if (!right_side) {\n  //     return null;\n  //   }\n  //   // return CSSMathExpressionOperation::CreateArithmeticOperation(\n  //   //   CSSMathExpressionNumericLiteral::Create(\n  //   //       1, UnitType.kNumber),\n  //   //   right_side, CSSMathOperator.kDivide);\n  //   return null;\n  // }\n\n\n  CSSMathInvert.prototype.buildCSSText = function (nested, paren_less, result) {\n    if (paren_less == ParenLess.kNo) {\n      result += nested === Nested.kYes ? '(' : 'calc(';\n    }\n\n    result += '1 / ';\n    result = this.value.buildCSSText(Nested.kYes, ParenLess.kNo, result);\n\n    if (paren_less === ParenLess.kNo) {\n      result += ')';\n    }\n\n    return result;\n  };\n\n  return CSSMathInvert;\n}(CSSMathValue);\n\nexport { CSSMathInvert };","map":{"version":3,"sources":["/Users/dennis.zhang/Desktop/其它代码库/moa-flow/node_modules/@antv/g/es/css/cssom/CSSMathInvert.js"],"names":["__extends","CSSMathValue","CSSNumericValueType","CSSStyleValueType","Nested","ParenLess","CSSMathInvert","_super","value","type","_this","call","operator","create","negateExponents","type_","prototype","clone","getType","kInvertType","equals","other","other_invert","sumValue","sum","length","Object","keys","units","forEach","key","buildCSSText","nested","paren_less","result","kNo","kYes"],"mappings":"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","sourcesContent":["import { __extends } from \"tslib\";\nimport { CSSMathValue } from './CSSMathValue';\nimport { CSSNumericValueType, CSSStyleValueType, Nested, ParenLess } from '.';\n\nvar CSSMathInvert =\n/** @class */\nfunction (_super) {\n  __extends(CSSMathInvert, _super);\n\n  function CSSMathInvert(value, type) {\n    var _this = _super.call(this, type) || this;\n\n    _this.value = value;\n    _this.operator = 'invert';\n    return _this;\n  }\n\n  CSSMathInvert.create = function (value) {\n    var type = CSSNumericValueType.negateExponents(value.type_);\n    return new CSSMathInvert(value, type);\n  };\n\n  CSSMathInvert.prototype.clone = function () {\n    return new CSSMathInvert(this.value, this.type_);\n  };\n\n  CSSMathInvert.prototype.getType = function () {\n    return CSSStyleValueType.kInvertType;\n  };\n\n  CSSMathInvert.prototype.equals = function (other) {\n    if (other.getType() !== CSSStyleValueType.kInvertType) {\n      return false;\n    } // We can safely cast here as we know 'other' has the same type as us.\n\n\n    var other_invert = other;\n    return this.value.equals(other_invert.value);\n  };\n\n  CSSMathInvert.prototype.sumValue = function () {\n    var sum = this.value.sumValue();\n\n    if (sum.length === 0 || sum.length !== 1 || sum[0].value === 0) {\n      return null;\n    }\n\n    Object.keys(sum[0].units).forEach(function (key) {\n      sum[0].units[key] *= -1;\n    });\n    sum[0].value = 1.0 / sum[0].value;\n    return sum;\n  }; // toCalcExpressionNode(): CSSMathExpressionNode {\n  //   const right_side = this.value.toCalcExpressionNode();\n  //   if (!right_side) {\n  //     return null;\n  //   }\n  //   // return CSSMathExpressionOperation::CreateArithmeticOperation(\n  //   //   CSSMathExpressionNumericLiteral::Create(\n  //   //       1, UnitType.kNumber),\n  //   //   right_side, CSSMathOperator.kDivide);\n  //   return null;\n  // }\n\n\n  CSSMathInvert.prototype.buildCSSText = function (nested, paren_less, result) {\n    if (paren_less == ParenLess.kNo) {\n      result += nested === Nested.kYes ? '(' : 'calc(';\n    }\n\n    result += '1 / ';\n    result = this.value.buildCSSText(Nested.kYes, ParenLess.kNo, result);\n\n    if (paren_less === ParenLess.kNo) {\n      result += ')';\n    }\n\n    return result;\n  };\n\n  return CSSMathInvert;\n}(CSSMathValue);\n\nexport { CSSMathInvert };"]},"metadata":{},"sourceType":"module"}