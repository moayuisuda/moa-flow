{"ast":null,"code":"import getArcParams from './get-arc-params';\nimport { isSamePoint } from './get-arc-params';\nimport parsePath from './parse-path'; // 点对称\n\nfunction toSymmetry(point, center) {\n  return [center[0] + (center[0] - point[0]), center[1] + (center[1] - point[1])];\n}\n\nexport default function getSegments(path) {\n  path = parsePath(path);\n  var segments = [];\n  var currentPoint = null; // 当前图形\n\n  var nextParams = null; // 下一节点的 path 参数\n\n  var startMovePoint = null; // 开始 M 的点，可能会有多个\n\n  var lastStartMovePointIndex = 0; // 最近一个开始点 M 的索引\n\n  var count = path.length;\n\n  for (var i = 0; i < count; i++) {\n    var params = path[i];\n    nextParams = path[i + 1];\n    var command = params[0]; // 数学定义上的参数，便于后面的计算\n\n    var segment = {\n      command: command,\n      prePoint: currentPoint,\n      params: params,\n      startTangent: null,\n      endTangent: null\n    };\n\n    switch (command) {\n      case 'M':\n        startMovePoint = [params[1], params[2]];\n        lastStartMovePointIndex = i;\n        break;\n\n      case 'A':\n        var arcParams = getArcParams(currentPoint, params);\n        segment['arcParams'] = arcParams;\n        break;\n\n      default:\n        break;\n    }\n\n    if (command === 'Z') {\n      // 有了 Z 后，当前节点从开始 M 的点开始\n      currentPoint = startMovePoint; // 如果当前点的命令为 Z，相当于当前点为最近一个 M 点，则下一个点直接指向最近一个 M 点的下一个点\n\n      nextParams = path[lastStartMovePointIndex + 1];\n    } else {\n      var len = params.length;\n      currentPoint = [params[len - 2], params[len - 1]];\n    }\n\n    if (nextParams && nextParams[0] === 'Z') {\n      // 如果下一个点的命令为 Z，则下一个点直接指向最近一个 M 点\n      nextParams = path[lastStartMovePointIndex];\n\n      if (segments[lastStartMovePointIndex]) {\n        // 如果下一个点的命令为 Z，则最近一个 M 点的前一个点为当前点\n        segments[lastStartMovePointIndex].prePoint = currentPoint;\n      }\n    }\n\n    segment['currentPoint'] = currentPoint; // 如果当前点与最近一个 M 点相同，则最近一个 M 点的前一个点为当前点的前一个点\n\n    if (segments[lastStartMovePointIndex] && isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {\n      segments[lastStartMovePointIndex].prePoint = segment.prePoint;\n    }\n\n    var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;\n    segment['nextPoint'] = nextPoint; // Add startTangent and endTangent\n\n    var prePoint = segment.prePoint;\n\n    if (['L', 'H', 'V'].includes(command)) {\n      segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];\n      segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];\n    } else if (command === 'Q') {\n      // 二次贝塞尔曲线只有一个控制点\n      var cp = [params[1], params[2]]; // 二次贝塞尔曲线的终点为 currentPoint\n\n      segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];\n      segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];\n    } else if (command === 'T') {\n      var preSegment = segments[i - 1];\n      var cp = toSymmetry(preSegment.currentPoint, prePoint);\n\n      if (preSegment.command === 'Q') {\n        segment.command = 'Q';\n        segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];\n        segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];\n      } else {\n        segment.command = 'TL';\n        segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];\n        segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];\n      }\n    } else if (command === 'C') {\n      // 三次贝塞尔曲线有两个控制点\n      var cp1 = [params[1], params[2]];\n      var cp2 = [params[3], params[4]];\n      segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];\n      segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]]; // horizontal line, eg. ['C', 100, 100, 100, 100, 200, 200]\n\n      if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {\n        segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];\n      }\n\n      if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {\n        segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];\n      }\n    } else if (command === 'S') {\n      var preSegment = segments[i - 1];\n      var cp1 = toSymmetry(preSegment.currentPoint, prePoint);\n      var cp2 = [params[1], params[2]];\n\n      if (preSegment.command === 'C') {\n        segment.command = 'C'; // 将 S 命令变换为 C 命令\n\n        segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];\n        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];\n      } else {\n        segment.command = 'SQ'; // 将 S 命令变换为 SQ 命令\n\n        segment.startTangent = [prePoint[0] - cp2[0], prePoint[1] - cp2[1]];\n        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];\n      }\n    } else if (command === 'A') {\n      var d = 0.001;\n\n      var _a = segment['arcParams'] || {},\n          _b = _a.cx,\n          cx = _b === void 0 ? 0 : _b,\n          _c = _a.cy,\n          cy = _c === void 0 ? 0 : _c,\n          _d = _a.rx,\n          rx = _d === void 0 ? 0 : _d,\n          _e = _a.ry,\n          ry = _e === void 0 ? 0 : _e,\n          _f = _a.sweepFlag,\n          sweepFlag = _f === void 0 ? 0 : _f,\n          _g = _a.startAngle,\n          startAngle = _g === void 0 ? 0 : _g,\n          _h = _a.endAngle,\n          endAngle = _h === void 0 ? 0 : _h;\n\n      if (sweepFlag === 0) {\n        d *= -1;\n      }\n\n      var dx1 = rx * Math.cos(startAngle - d) + cx;\n      var dy1 = ry * Math.sin(startAngle - d) + cy;\n      segment.startTangent = [dx1 - startMovePoint[0], dy1 - startMovePoint[1]];\n      var dx2 = rx * Math.cos(startAngle + endAngle + d) + cx;\n      var dy2 = ry * Math.sin(startAngle + endAngle - d) + cy;\n      segment.endTangent = [prePoint[0] - dx2, prePoint[1] - dy2];\n    }\n\n    segments.push(segment);\n  }\n\n  return segments;\n}","map":{"version":3,"mappings":"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","names":["getArcParams","isSamePoint","parsePath","toSymmetry","point","center","getSegments","path","segments","currentPoint","nextParams","startMovePoint","lastStartMovePointIndex","count","length","i","params","command","segment","prePoint","startTangent","endTangent","arcParams","len","nextPoint","includes","cp","preSegment","cp1","cp2","d","_b","cx","_c","cy","_d","rx","_e","ry","_f","sweepFlag","_g","startAngle","_h","endAngle","dx1","Math","cos","dy1","sin","dx2","dy2","push"],"sources":["/Users/dennis.zhang/Desktop/其它代码库/moa-flow/node_modules/@antv/path-util/src/path-2-segments.ts"],"sourcesContent":["import getArcParams from './get-arc-params';\nimport { isSamePoint } from './get-arc-params';\nimport parsePath from './parse-path';\n\n// 点对称\nfunction toSymmetry(point, center) {\n  return [ center[0] + (center[0] - point[0]), center[1] + (center[1] - point[1]) ];\n}\n\nexport default function getSegments(path) {\n  path = parsePath(path);\n  const segments = [];\n  let currentPoint = null; // 当前图形\n  let nextParams = null; // 下一节点的 path 参数\n  let startMovePoint = null; // 开始 M 的点，可能会有多个\n  let lastStartMovePointIndex = 0; // 最近一个开始点 M 的索引\n  const count = path.length;\n  for (let i = 0; i < count; i++) {\n    const params = path[i];\n    nextParams = path[i + 1];\n    const command = params[0];\n    // 数学定义上的参数，便于后面的计算\n    const segment = {\n      command,\n      prePoint: currentPoint,\n      params,\n      startTangent: null,\n      endTangent: null,\n    };\n    switch (command) {\n      case 'M':\n        startMovePoint = [ params[1], params[2] ];\n        lastStartMovePointIndex = i;\n        break;\n      case 'A':\n        const arcParams = getArcParams(currentPoint, params);\n        segment['arcParams'] = arcParams;\n        break;\n      default:\n        break;\n    }\n    if (command === 'Z') {\n      // 有了 Z 后，当前节点从开始 M 的点开始\n      currentPoint = startMovePoint;\n      // 如果当前点的命令为 Z，相当于当前点为最近一个 M 点，则下一个点直接指向最近一个 M 点的下一个点\n      nextParams = path[lastStartMovePointIndex + 1];\n    } else {\n      const len = params.length;\n      currentPoint = [ params[len - 2], params[len - 1] ];\n    }\n    if (nextParams && nextParams[0] === 'Z') {\n      // 如果下一个点的命令为 Z，则下一个点直接指向最近一个 M 点\n      nextParams = path[lastStartMovePointIndex];\n      if (segments[lastStartMovePointIndex]) {\n        // 如果下一个点的命令为 Z，则最近一个 M 点的前一个点为当前点\n        segments[lastStartMovePointIndex].prePoint = currentPoint;\n      }\n    }\n    segment['currentPoint'] = currentPoint;\n    // 如果当前点与最近一个 M 点相同，则最近一个 M 点的前一个点为当前点的前一个点\n    if (\n      segments[lastStartMovePointIndex] &&\n      isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)\n    ) {\n      segments[lastStartMovePointIndex].prePoint = segment.prePoint;\n    }\n    const nextPoint = nextParams ? [ nextParams[nextParams.length - 2], nextParams[nextParams.length - 1] ] : null;\n    segment['nextPoint'] = nextPoint;\n    // Add startTangent and endTangent\n    const { prePoint } = segment;\n    if ([ 'L', 'H', 'V' ].includes(command)) {\n      segment.startTangent = [ prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1] ];\n      segment.endTangent = [ currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1] ];\n    } else if (command === 'Q') {\n      // 二次贝塞尔曲线只有一个控制点\n      const cp = [ params[1], params[2] ];\n      // 二次贝塞尔曲线的终点为 currentPoint\n      segment.startTangent = [ prePoint[0] - cp[0], prePoint[1] - cp[1] ];\n      segment.endTangent = [ currentPoint[0] - cp[0], currentPoint[1] - cp[1] ];\n    } else if (command === 'T') {\n      const preSegment = segments[i - 1];\n      const cp = toSymmetry(preSegment.currentPoint, prePoint);\n      if (preSegment.command === 'Q') {\n        segment.command = 'Q';\n        segment.startTangent = [ prePoint[0] - cp[0], prePoint[1] - cp[1] ];\n        segment.endTangent = [ currentPoint[0] - cp[0], currentPoint[1] - cp[1] ];\n      } else {\n        segment.command = 'TL';\n        segment.startTangent = [ prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1] ];\n        segment.endTangent = [ currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1] ];\n      }\n    } else if (command === 'C') {\n      // 三次贝塞尔曲线有两个控制点\n      const cp1 = [ params[1], params[2] ];\n      const cp2 = [ params[3], params[4] ];\n      segment.startTangent = [ prePoint[0] - cp1[0], prePoint[1] - cp1[1] ];\n      segment.endTangent = [ currentPoint[0] - cp2[0], currentPoint[1] - cp2[1] ];\n\n      // horizontal line, eg. ['C', 100, 100, 100, 100, 200, 200]\n      if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {\n        segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];\n      }\n      if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {\n        segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];\n      }\n    } else if (command === 'S') {\n      const preSegment = segments[i - 1];\n      const cp1 = toSymmetry(preSegment.currentPoint, prePoint);\n      const cp2 = [ params[1], params[2] ];\n      if (preSegment.command === 'C') {\n        segment.command = 'C'; // 将 S 命令变换为 C 命令\n        segment.startTangent = [ prePoint[0] - cp1[0], prePoint[1] - cp1[1] ];\n        segment.endTangent = [ currentPoint[0] - cp2[0], currentPoint[1] - cp2[1] ];\n      } else {\n        segment.command = 'SQ'; // 将 S 命令变换为 SQ 命令\n        segment.startTangent = [ prePoint[0] - cp2[0], prePoint[1] - cp2[1] ];\n        segment.endTangent = [ currentPoint[0] - cp2[0], currentPoint[1] - cp2[1] ];\n      }\n    } else if (command === 'A') {\n      let d = 0.001;\n      const {\n        cx = 0,\n        cy = 0,\n        rx = 0,\n        ry = 0,\n        sweepFlag = 0,\n        startAngle = 0,\n        endAngle = 0,\n      } = segment['arcParams'] || {};\n      if (sweepFlag === 0) {\n        d *= -1;\n      }\n      const dx1 = rx * Math.cos(startAngle - d) + cx;\n      const dy1 = ry * Math.sin(startAngle - d) + cy;\n      segment.startTangent = [ dx1 - startMovePoint[0], dy1 - startMovePoint[1] ];\n      const dx2 = rx * Math.cos(startAngle + endAngle + d) + cx;\n      const dy2 = ry * Math.sin(startAngle + endAngle - d) + cy;\n      segment.endTangent = [ prePoint[0] - dx2, prePoint[1] - dy2 ];\n    }\n    segments.push(segment);\n  }\n  return segments;\n}\n"]},"metadata":{},"sourceType":"module"}