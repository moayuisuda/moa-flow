{"ast":null,"code":"import { ARRAY_TYPE } from './common.js';\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\n\nfunction create() {\n  var out = new ARRAY_TYPE(3);\n\n  if (ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\n\n\nfunction fromValues(x, y, z) {\n  var out = new ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\n\n(function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n})();\n\nexport { create, fromValues };","map":{"version":3,"sources":["/Users/dennis.zhang/Desktop/其它代码库/moa-flow/packages/flow/lib/node_modules/gl-matrix/esm/vec3.js"],"names":["ARRAY_TYPE","create","out","Float32Array","fromValues","x","y","z","vec","a","stride","offset","count","fn","arg","i","l","Math","min","length"],"mappings":"AAAA,SAASA,UAAT,QAA2B,aAA3B;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,SAASC,MAAT,GAAkB;AAChB,MAAIC,GAAG,GAAG,IAAIF,UAAJ,CAAe,CAAf,CAAV;;AAEA,MAAIA,UAAU,IAAIG,YAAlB,EAAgC;AAC9BD,IAAAA,GAAG,CAAC,CAAD,CAAH,GAAS,CAAT;AACAA,IAAAA,GAAG,CAAC,CAAD,CAAH,GAAS,CAAT;AACAA,IAAAA,GAAG,CAAC,CAAD,CAAH,GAAS,CAAT;AACD;;AAED,SAAOA,GAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASE,UAAT,CAAoBC,CAApB,EAAuBC,CAAvB,EAA0BC,CAA1B,EAA6B;AAC3B,MAAIL,GAAG,GAAG,IAAIF,UAAJ,CAAe,CAAf,CAAV;AACAE,EAAAA,GAAG,CAAC,CAAD,CAAH,GAASG,CAAT;AACAH,EAAAA,GAAG,CAAC,CAAD,CAAH,GAASI,CAAT;AACAJ,EAAAA,GAAG,CAAC,CAAD,CAAH,GAASK,CAAT;AACA,SAAOL,GAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,CAAC,YAAY;AACX,MAAIM,GAAG,GAAGP,MAAM,EAAhB;AACA,SAAO,UAAUQ,CAAV,EAAaC,MAAb,EAAqBC,MAArB,EAA6BC,KAA7B,EAAoCC,EAApC,EAAwCC,GAAxC,EAA6C;AAClD,QAAIC,CAAJ,EAAOC,CAAP;;AAEA,QAAI,CAACN,MAAL,EAAa;AACXA,MAAAA,MAAM,GAAG,CAAT;AACD;;AAED,QAAI,CAACC,MAAL,EAAa;AACXA,MAAAA,MAAM,GAAG,CAAT;AACD;;AAED,QAAIC,KAAJ,EAAW;AACTI,MAAAA,CAAC,GAAGC,IAAI,CAACC,GAAL,CAASN,KAAK,GAAGF,MAAR,GAAiBC,MAA1B,EAAkCF,CAAC,CAACU,MAApC,CAAJ;AACD,KAFD,MAEO;AACLH,MAAAA,CAAC,GAAGP,CAAC,CAACU,MAAN;AACD;;AAED,SAAKJ,CAAC,GAAGJ,MAAT,EAAiBI,CAAC,GAAGC,CAArB,EAAwBD,CAAC,IAAIL,MAA7B,EAAqC;AACnCF,MAAAA,GAAG,CAAC,CAAD,CAAH,GAASC,CAAC,CAACM,CAAD,CAAV;AACAP,MAAAA,GAAG,CAAC,CAAD,CAAH,GAASC,CAAC,CAACM,CAAC,GAAG,CAAL,CAAV;AACAP,MAAAA,GAAG,CAAC,CAAD,CAAH,GAASC,CAAC,CAACM,CAAC,GAAG,CAAL,CAAV;AACAF,MAAAA,EAAE,CAACL,GAAD,EAAMA,GAAN,EAAWM,GAAX,CAAF;AACAL,MAAAA,CAAC,CAACM,CAAD,CAAD,GAAOP,GAAG,CAAC,CAAD,CAAV;AACAC,MAAAA,CAAC,CAACM,CAAC,GAAG,CAAL,CAAD,GAAWP,GAAG,CAAC,CAAD,CAAd;AACAC,MAAAA,CAAC,CAACM,CAAC,GAAG,CAAL,CAAD,GAAWP,GAAG,CAAC,CAAD,CAAd;AACD;;AAED,WAAOC,CAAP;AACD,GA5BD;AA6BD,CA/BD;;AAiCA,SAASR,MAAT,EAAiBG,UAAjB","sourcesContent":["import { ARRAY_TYPE } from './common.js';\n\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\n\nfunction create() {\n  var out = new ARRAY_TYPE(3);\n\n  if (ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\n\nfunction fromValues(x, y, z) {\n  var out = new ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\n(function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n})();\n\nexport { create, fromValues };\n"]},"metadata":{},"sourceType":"module"}