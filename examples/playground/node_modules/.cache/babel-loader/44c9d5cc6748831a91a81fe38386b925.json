{"ast":null,"code":"import { __awaiter, __decorate, __generator, __metadata } from \"tslib\";\nimport { inject, singleton, contrib, Syringe, Contribution } from 'mana-syringe';\nimport { SyncHook, SyncWaterfallHook, AsyncParallelHook, AsyncSeriesWaterfallHook } from 'tapable';\nimport { StyleValueRegistry } from '../css';\nimport { ElementEvent } from '../dom';\nimport { RenderingContext, RenderReason } from './RenderingContext';\nimport { SceneGraphService, sortByZIndex } from './SceneGraphService';\nexport var RenderingPluginContribution = Syringe.defineToken('RenderingPluginContribution');\n/**\n * Use frame renderer implemented by `g-canvas/svg/webgl`, in every frame we do followings:\n * * update & merge dirty rectangles\n * * begin frame\n * * filter by visible\n * * sort by z-index in scene graph\n * * culling with strategies registered in `g-canvas/webgl`\n * * end frame\n */\n\nvar RenderingService =\n/** @class */\nfunction () {\n  function RenderingService() {\n    this.inited = false;\n    this.stats = {\n      /**\n       * total display objects in scenegraph\n       */\n      total: 0,\n\n      /**\n       * number of display objects need to render in current frame\n       */\n      rendered: 0,\n\n      /**\n       * number of display objects displayed on screen\n       */\n      renderedOnscreen: 0\n    };\n    this.zIndexCounter = 0;\n    this.hooks = {\n      /**\n       * called before any frame rendered\n       */\n      init: new AsyncParallelHook(),\n\n      /**\n       * only dirty object which has sth changed will be rendered\n       */\n      dirtycheck: new SyncWaterfallHook(['object']),\n\n      /**\n       * do culling\n       */\n      cull: new SyncWaterfallHook(['object']),\n\n      /**\n       * called at beginning of each frame, won't get called if nothing to re-render\n       */\n      beginFrame: new SyncHook([]),\n\n      /**\n       * called before every dirty object get rendered\n       */\n      beforeRender: new SyncHook(['objectToRender']),\n\n      /**\n       * called when every dirty object rendering even it's culled\n       */\n      render: new SyncHook(['objectToRender']),\n\n      /**\n       * called after every dirty object get rendered\n       */\n      afterRender: new SyncHook(['objectToRender']),\n      endFrame: new SyncHook([]),\n      destroy: new SyncHook([]),\n\n      /**\n       * use async but faster method such as GPU-based picking in `g-plugin-webgl-renderer`\n       */\n      pick: new AsyncSeriesWaterfallHook(['result']),\n\n      /**\n       * used in event system\n       */\n      pointerDown: new SyncHook(['event']),\n      pointerUp: new SyncHook(['event']),\n      pointerMove: new SyncHook(['event']),\n      pointerOut: new SyncHook(['event']),\n      pointerOver: new SyncHook(['event']),\n      pointerWheel: new SyncHook(['event'])\n    };\n  }\n\n  RenderingService.prototype.init = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // register rendering plugins\n            this.renderingPluginProvider.getContributions({\n              cache: false\n            }).forEach(function (plugin) {\n              plugin.apply(_this);\n            });\n            return [4\n            /*yield*/\n            , this.hooks.init.promise()];\n\n          case 1:\n            _a.sent();\n\n            this.inited = true;\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  RenderingService.prototype.getStats = function () {\n    return this.stats;\n  };\n\n  RenderingService.prototype.render = function (canvasConfig) {\n    this.stats.total = 0;\n    this.stats.rendered = 0;\n    this.zIndexCounter = 0;\n    this.sceneGraphService.syncHierarchy(this.renderingContext.root);\n\n    if (this.renderingContext.renderReasons.size && this.inited) {\n      this.renderDisplayObject(this.renderingContext.root);\n\n      if (this.renderingContext.dirty || canvasConfig.renderer.getConfig().enableDirtyRectangleRendering && this.stats.total === 1) {\n        if (!this.renderingContext.dirty) {\n          this.hooks.beginFrame.call();\n        }\n\n        this.stats.renderedOnscreen = this.stats.rendered;\n        this.hooks.endFrame.call();\n        this.renderingContext.dirty = false;\n      }\n\n      this.renderingContext.renderReasons.clear();\n    } // console.log('stats', this.stats);\n\n  };\n\n  RenderingService.prototype.renderDisplayObject = function (displayObject) {\n    var _this = this; // recalc style values\n\n\n    this.styleValueRegistry.recalc(displayObject); // TODO: relayout\n    // dirtycheck first\n\n    var objectChanged = this.hooks.dirtycheck.call(displayObject);\n\n    if (objectChanged) {\n      // const objectToRender = this.hooks.cull.call(objectChanged);\n      this.hooks.cull.call(objectChanged); // if (objectToRender) {\n\n      this.stats.rendered++;\n\n      if (!this.renderingContext.dirty) {\n        this.renderingContext.dirty = true;\n        this.hooks.beginFrame.call();\n      }\n\n      this.hooks.beforeRender.call(objectChanged);\n      this.hooks.render.call(objectChanged);\n      this.hooks.afterRender.call(objectChanged);\n      displayObject.renderable.dirty = false; // }\n    }\n\n    displayObject.sortable.renderOrder = this.zIndexCounter++;\n    this.stats.total++; // sort is very expensive, use cached result if posible\n\n    var sortable = displayObject.sortable;\n    var renderOrderChanged = false;\n\n    if (sortable.dirty) {\n      sortable.sorted = displayObject.childNodes.slice().sort(sortByZIndex);\n      renderOrderChanged = true;\n      sortable.dirty = false;\n    } // recursive rendering its children\n\n\n    (sortable.sorted || displayObject.childNodes).forEach(function (child) {\n      _this.renderDisplayObject(child);\n    });\n\n    if (renderOrderChanged) {\n      displayObject.forEach(function (child) {\n        child.emit(ElementEvent.RENDER_ORDER_CHANGED, {\n          renderOrder: child.sortable.renderOrder\n        });\n      });\n    }\n  };\n\n  RenderingService.prototype.destroy = function () {\n    this.inited = false;\n    this.hooks.destroy.call();\n  };\n\n  RenderingService.prototype.dirtify = function () {\n    // need re-render\n    this.renderingContext.renderReasons.add(RenderReason.DISPLAY_OBJECT_CHANGED);\n  };\n\n  __decorate([contrib(RenderingPluginContribution), __metadata(\"design:type\", Object)], RenderingService.prototype, \"renderingPluginProvider\", void 0);\n\n  __decorate([inject(RenderingContext), __metadata(\"design:type\", Object)], RenderingService.prototype, \"renderingContext\", void 0);\n\n  __decorate([inject(SceneGraphService), __metadata(\"design:type\", Object)], RenderingService.prototype, \"sceneGraphService\", void 0);\n\n  __decorate([inject(StyleValueRegistry), __metadata(\"design:type\", StyleValueRegistry)], RenderingService.prototype, \"styleValueRegistry\", void 0);\n\n  RenderingService = __decorate([singleton()], RenderingService);\n  return RenderingService;\n}();\n\nexport { RenderingService };","map":{"version":3,"sources":["/Users/dennis.zhang/Desktop/其它代码库/moa-flow/node_modules/@antv/g/es/services/RenderingService.js"],"names":["__awaiter","__decorate","__generator","__metadata","inject","singleton","contrib","Syringe","Contribution","SyncHook","SyncWaterfallHook","AsyncParallelHook","AsyncSeriesWaterfallHook","StyleValueRegistry","ElementEvent","RenderingContext","RenderReason","SceneGraphService","sortByZIndex","RenderingPluginContribution","defineToken","RenderingService","inited","stats","total","rendered","renderedOnscreen","zIndexCounter","hooks","init","dirtycheck","cull","beginFrame","beforeRender","render","afterRender","endFrame","destroy","pick","pointerDown","pointerUp","pointerMove","pointerOut","pointerOver","pointerWheel","prototype","_this","_a","label","renderingPluginProvider","getContributions","cache","forEach","plugin","apply","promise","sent","getStats","canvasConfig","sceneGraphService","syncHierarchy","renderingContext","root","renderReasons","size","renderDisplayObject","dirty","renderer","getConfig","enableDirtyRectangleRendering","call","clear","displayObject","styleValueRegistry","recalc","objectChanged","renderable","sortable","renderOrder","renderOrderChanged","sorted","childNodes","slice","sort","child","emit","RENDER_ORDER_CHANGED","dirtify","add","DISPLAY_OBJECT_CHANGED","Object"],"mappings":"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","sourcesContent":["import { __awaiter, __decorate, __generator, __metadata } from \"tslib\";\nimport { inject, singleton, contrib, Syringe, Contribution } from 'mana-syringe';\nimport { SyncHook, SyncWaterfallHook, AsyncParallelHook, AsyncSeriesWaterfallHook } from 'tapable';\nimport { StyleValueRegistry } from '../css';\nimport { ElementEvent } from '../dom';\nimport { RenderingContext, RenderReason } from './RenderingContext';\nimport { SceneGraphService, sortByZIndex } from './SceneGraphService';\nexport var RenderingPluginContribution = Syringe.defineToken('RenderingPluginContribution');\n/**\n * Use frame renderer implemented by `g-canvas/svg/webgl`, in every frame we do followings:\n * * update & merge dirty rectangles\n * * begin frame\n * * filter by visible\n * * sort by z-index in scene graph\n * * culling with strategies registered in `g-canvas/webgl`\n * * end frame\n */\n\nvar RenderingService =\n/** @class */\nfunction () {\n  function RenderingService() {\n    this.inited = false;\n    this.stats = {\n      /**\n       * total display objects in scenegraph\n       */\n      total: 0,\n\n      /**\n       * number of display objects need to render in current frame\n       */\n      rendered: 0,\n\n      /**\n       * number of display objects displayed on screen\n       */\n      renderedOnscreen: 0\n    };\n    this.zIndexCounter = 0;\n    this.hooks = {\n      /**\n       * called before any frame rendered\n       */\n      init: new AsyncParallelHook(),\n\n      /**\n       * only dirty object which has sth changed will be rendered\n       */\n      dirtycheck: new SyncWaterfallHook(['object']),\n\n      /**\n       * do culling\n       */\n      cull: new SyncWaterfallHook(['object']),\n\n      /**\n       * called at beginning of each frame, won't get called if nothing to re-render\n       */\n      beginFrame: new SyncHook([]),\n\n      /**\n       * called before every dirty object get rendered\n       */\n      beforeRender: new SyncHook(['objectToRender']),\n\n      /**\n       * called when every dirty object rendering even it's culled\n       */\n      render: new SyncHook(['objectToRender']),\n\n      /**\n       * called after every dirty object get rendered\n       */\n      afterRender: new SyncHook(['objectToRender']),\n      endFrame: new SyncHook([]),\n      destroy: new SyncHook([]),\n\n      /**\n       * use async but faster method such as GPU-based picking in `g-plugin-webgl-renderer`\n       */\n      pick: new AsyncSeriesWaterfallHook(['result']),\n\n      /**\n       * used in event system\n       */\n      pointerDown: new SyncHook(['event']),\n      pointerUp: new SyncHook(['event']),\n      pointerMove: new SyncHook(['event']),\n      pointerOut: new SyncHook(['event']),\n      pointerOver: new SyncHook(['event']),\n      pointerWheel: new SyncHook(['event'])\n    };\n  }\n\n  RenderingService.prototype.init = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // register rendering plugins\n            this.renderingPluginProvider.getContributions({\n              cache: false\n            }).forEach(function (plugin) {\n              plugin.apply(_this);\n            });\n            return [4\n            /*yield*/\n            , this.hooks.init.promise()];\n\n          case 1:\n            _a.sent();\n\n            this.inited = true;\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  RenderingService.prototype.getStats = function () {\n    return this.stats;\n  };\n\n  RenderingService.prototype.render = function (canvasConfig) {\n    this.stats.total = 0;\n    this.stats.rendered = 0;\n    this.zIndexCounter = 0;\n    this.sceneGraphService.syncHierarchy(this.renderingContext.root);\n\n    if (this.renderingContext.renderReasons.size && this.inited) {\n      this.renderDisplayObject(this.renderingContext.root);\n\n      if (this.renderingContext.dirty || canvasConfig.renderer.getConfig().enableDirtyRectangleRendering && this.stats.total === 1) {\n        if (!this.renderingContext.dirty) {\n          this.hooks.beginFrame.call();\n        }\n\n        this.stats.renderedOnscreen = this.stats.rendered;\n        this.hooks.endFrame.call();\n        this.renderingContext.dirty = false;\n      }\n\n      this.renderingContext.renderReasons.clear();\n    } // console.log('stats', this.stats);\n\n  };\n\n  RenderingService.prototype.renderDisplayObject = function (displayObject) {\n    var _this = this; // recalc style values\n\n\n    this.styleValueRegistry.recalc(displayObject); // TODO: relayout\n    // dirtycheck first\n\n    var objectChanged = this.hooks.dirtycheck.call(displayObject);\n\n    if (objectChanged) {\n      // const objectToRender = this.hooks.cull.call(objectChanged);\n      this.hooks.cull.call(objectChanged); // if (objectToRender) {\n\n      this.stats.rendered++;\n\n      if (!this.renderingContext.dirty) {\n        this.renderingContext.dirty = true;\n        this.hooks.beginFrame.call();\n      }\n\n      this.hooks.beforeRender.call(objectChanged);\n      this.hooks.render.call(objectChanged);\n      this.hooks.afterRender.call(objectChanged);\n      displayObject.renderable.dirty = false; // }\n    }\n\n    displayObject.sortable.renderOrder = this.zIndexCounter++;\n    this.stats.total++; // sort is very expensive, use cached result if posible\n\n    var sortable = displayObject.sortable;\n    var renderOrderChanged = false;\n\n    if (sortable.dirty) {\n      sortable.sorted = displayObject.childNodes.slice().sort(sortByZIndex);\n      renderOrderChanged = true;\n      sortable.dirty = false;\n    } // recursive rendering its children\n\n\n    (sortable.sorted || displayObject.childNodes).forEach(function (child) {\n      _this.renderDisplayObject(child);\n    });\n\n    if (renderOrderChanged) {\n      displayObject.forEach(function (child) {\n        child.emit(ElementEvent.RENDER_ORDER_CHANGED, {\n          renderOrder: child.sortable.renderOrder\n        });\n      });\n    }\n  };\n\n  RenderingService.prototype.destroy = function () {\n    this.inited = false;\n    this.hooks.destroy.call();\n  };\n\n  RenderingService.prototype.dirtify = function () {\n    // need re-render\n    this.renderingContext.renderReasons.add(RenderReason.DISPLAY_OBJECT_CHANGED);\n  };\n\n  __decorate([contrib(RenderingPluginContribution), __metadata(\"design:type\", Object)], RenderingService.prototype, \"renderingPluginProvider\", void 0);\n\n  __decorate([inject(RenderingContext), __metadata(\"design:type\", Object)], RenderingService.prototype, \"renderingContext\", void 0);\n\n  __decorate([inject(SceneGraphService), __metadata(\"design:type\", Object)], RenderingService.prototype, \"sceneGraphService\", void 0);\n\n  __decorate([inject(StyleValueRegistry), __metadata(\"design:type\", StyleValueRegistry)], RenderingService.prototype, \"styleValueRegistry\", void 0);\n\n  RenderingService = __decorate([singleton()], RenderingService);\n  return RenderingService;\n}();\n\nexport { RenderingService };"]},"metadata":{},"sourceType":"module"}