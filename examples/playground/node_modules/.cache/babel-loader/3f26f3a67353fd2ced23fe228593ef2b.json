{"ast":null,"code":"import { mat3, vec2 } from 'gl-matrix';\nimport { Quad as QuadUtil, Cubic as CubicUtil } from '@antv/g-math';\nimport { inArc, inBox, inLine, inPolygons } from './utils/math';\n\nfunction isPointInStroke(segments, lineWidth, px, py, length, x, y) {\n  var isHit = false;\n  var halfWidth = lineWidth / 2;\n\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    var currentPoint = segment.currentPoint,\n        params = segment.params,\n        prePoint = segment.prePoint,\n        box = segment.box; // 如果在前面已经生成过包围盒，直接按照包围盒计算\n\n    if (box && !inBox(box.x - halfWidth, box.y - halfWidth, box.width + lineWidth, box.height + lineWidth, px, py)) {\n      continue;\n    }\n\n    switch (segment.command) {\n      // L 和 Z 都是直线， M 不进行拾取\n      case 'L':\n      case 'Z':\n        isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, px, py);\n        break;\n\n      case 'Q':\n        var qDistance = QuadUtil.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], px, py);\n        isHit = qDistance <= lineWidth / 2;\n        break;\n\n      case 'C':\n        var cDistance = CubicUtil.pointDistance(prePoint[0], // 上一段结束位置, 即 C 的起始点\n        prePoint[1], params[1], // 'C' 的参数，1、2 为第一个控制点，3、4 为第二个控制点，5、6 为结束点\n        params[2], params[3], params[4], params[5], params[6], px, py, length);\n        isHit = cDistance <= lineWidth / 2;\n        break;\n\n      case 'A':\n        // 计算点到椭圆圆弧的距离，暂时使用近似算法，后面可以改成切割法求最近距离\n        var arcParams = segment.arcParams;\n        var cx = arcParams.cx,\n            cy = arcParams.cy,\n            rx = arcParams.rx,\n            ry = arcParams.ry,\n            startAngle = arcParams.startAngle,\n            endAngle = arcParams.endAngle,\n            xRotation = arcParams.xRotation;\n        var r = rx > ry ? rx : ry;\n        var scaleX = rx > ry ? 1 : rx / ry;\n        var scaleY = rx > ry ? ry / rx : 1; // const m = transform(null, [\n        //   ['t', -cx, -cy],\n        //   ['r', -xRotation],\n        //   ['s', 1 / scaleX, 1 / scaleY],\n        // ]);\n        // FIXME\n\n        var m = mat3.fromTranslation(mat3.create(), [-cx, -cy]);\n        mat3.multiply(m, mat3.fromRotation(mat3.create(), -xRotation), m);\n        mat3.multiply(m, mat3.fromScaling(mat3.create(), [1 / scaleX, 1 / scaleY]), m);\n        var p = vec2.fromValues(px, py);\n        p = vec2.transformMat3(p, p, m); // isHit = inArc(cx, cy, r, startAngle, endAngle, lineWidth, px, py);\n        // console.log(m, p[0], px - cx);\n        // isHit = inArc(cx, cy, r, startAngle, endAngle, lineWidth, px, py);\n\n        isHit = inArc(0, 0, r, startAngle, endAngle, lineWidth, p[0], p[1]);\n        break;\n\n      default:\n        break;\n    }\n\n    if (isHit) {\n      break;\n    }\n  }\n\n  return isHit;\n}\n\nexport function isPointInPath(displayObject, position, isPointInPath) {\n  var _a = displayObject.parsedStyle,\n      lineWidth = _a.lineWidth,\n      stroke = _a.stroke,\n      fill = _a.fill,\n      _b = _a.defX,\n      x = _b === void 0 ? 0 : _b,\n      _c = _a.defY,\n      y = _c === void 0 ? 0 : _c,\n      clipPathTargets = _a.clipPathTargets,\n      path = _a.path;\n  var hasFill = fill && !fill.isNone;\n  var hasStroke = stroke && !stroke.isNone;\n  var segments = path.segments,\n      hasArc = path.hasArc,\n      polylines = path.polylines,\n      polygons = path.polygons,\n      totalLength = path.totalLength;\n  var isClipPath = !!(clipPathTargets === null || clipPathTargets === void 0 ? void 0 : clipPathTargets.length);\n  var isHit = false;\n\n  if (hasStroke || isClipPath) {\n    isHit = isPointInStroke(segments, lineWidth.value, position.x + x, position.y + y, totalLength, x, y);\n  }\n\n  if (!isHit && (hasFill || isClipPath)) {\n    if (hasArc) {\n      // 存在曲线时，暂时使用 canvas 的 api 计算，后续可以进行多边形切割\n      isHit = isPointInPath(displayObject, position);\n    } else {\n      // 提取出来的多边形包含闭合的和非闭合的，在这里统一按照多边形处理\n      isHit = inPolygons(polygons, position.x + x, position.y + y) || inPolygons(polylines, position.x + x, position.y + y);\n    }\n  }\n\n  return isHit;\n}","map":{"version":3,"sources":["/Users/dennis.zhang/Desktop/其它代码库/moa-flow/node_modules/@antv/g-plugin-canvas-picker/es/Path.js"],"names":["mat3","vec2","Quad","QuadUtil","Cubic","CubicUtil","inArc","inBox","inLine","inPolygons","isPointInStroke","segments","lineWidth","px","py","length","x","y","isHit","halfWidth","i","segment","currentPoint","params","prePoint","box","width","height","command","qDistance","pointDistance","cDistance","arcParams","cx","cy","rx","ry","startAngle","endAngle","xRotation","r","scaleX","scaleY","m","fromTranslation","create","multiply","fromRotation","fromScaling","p","fromValues","transformMat3","isPointInPath","displayObject","position","_a","parsedStyle","stroke","fill","_b","defX","_c","defY","clipPathTargets","path","hasFill","isNone","hasStroke","hasArc","polylines","polygons","totalLength","isClipPath","value"],"mappings":"AAAA,SAASA,IAAT,EAAeC,IAAf,QAA2B,WAA3B;AACA,SAASC,IAAI,IAAIC,QAAjB,EAA2BC,KAAK,IAAIC,SAApC,QAAqD,cAArD;AACA,SAASC,KAAT,EAAgBC,KAAhB,EAAuBC,MAAvB,EAA+BC,UAA/B,QAAiD,cAAjD;;AAEA,SAASC,eAAT,CAAyBC,QAAzB,EAAmCC,SAAnC,EAA8CC,EAA9C,EAAkDC,EAAlD,EAAsDC,MAAtD,EAA8DC,CAA9D,EAAiEC,CAAjE,EAAoE;AAClE,MAAIC,KAAK,GAAG,KAAZ;AACA,MAAIC,SAAS,GAAGP,SAAS,GAAG,CAA5B;;AAEA,OAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,QAAQ,CAACI,MAA7B,EAAqCK,CAAC,EAAtC,EAA0C;AACxC,QAAIC,OAAO,GAAGV,QAAQ,CAACS,CAAD,CAAtB;AACA,QAAIE,YAAY,GAAGD,OAAO,CAACC,YAA3B;AAAA,QACIC,MAAM,GAAGF,OAAO,CAACE,MADrB;AAAA,QAEIC,QAAQ,GAAGH,OAAO,CAACG,QAFvB;AAAA,QAGIC,GAAG,GAAGJ,OAAO,CAACI,GAHlB,CAFwC,CAKjB;;AAEvB,QAAIA,GAAG,IAAI,CAAClB,KAAK,CAACkB,GAAG,CAACT,CAAJ,GAAQG,SAAT,EAAoBM,GAAG,CAACR,CAAJ,GAAQE,SAA5B,EAAuCM,GAAG,CAACC,KAAJ,GAAYd,SAAnD,EAA8Da,GAAG,CAACE,MAAJ,GAAaf,SAA3E,EAAsFC,EAAtF,EAA0FC,EAA1F,CAAjB,EAAgH;AAC9G;AACD;;AAED,YAAQO,OAAO,CAACO,OAAhB;AACE;AACA,WAAK,GAAL;AACA,WAAK,GAAL;AACEV,QAAAA,KAAK,GAAGV,MAAM,CAACgB,QAAQ,CAAC,CAAD,CAAT,EAAcA,QAAQ,CAAC,CAAD,CAAtB,EAA2BF,YAAY,CAAC,CAAD,CAAvC,EAA4CA,YAAY,CAAC,CAAD,CAAxD,EAA6DV,SAA7D,EAAwEC,EAAxE,EAA4EC,EAA5E,CAAd;AACA;;AAEF,WAAK,GAAL;AACE,YAAIe,SAAS,GAAG1B,QAAQ,CAAC2B,aAAT,CAAuBN,QAAQ,CAAC,CAAD,CAA/B,EAAoCA,QAAQ,CAAC,CAAD,CAA5C,EAAiDD,MAAM,CAAC,CAAD,CAAvD,EAA4DA,MAAM,CAAC,CAAD,CAAlE,EAAuEA,MAAM,CAAC,CAAD,CAA7E,EAAkFA,MAAM,CAAC,CAAD,CAAxF,EAA6FV,EAA7F,EAAiGC,EAAjG,CAAhB;AACAI,QAAAA,KAAK,GAAGW,SAAS,IAAIjB,SAAS,GAAG,CAAjC;AACA;;AAEF,WAAK,GAAL;AACE,YAAImB,SAAS,GAAG1B,SAAS,CAACyB,aAAV,CAAwBN,QAAQ,CAAC,CAAD,CAAhC,EAAqC;AACrDA,QAAAA,QAAQ,CAAC,CAAD,CADQ,EACHD,MAAM,CAAC,CAAD,CADH,EACQ;AACxBA,QAAAA,MAAM,CAAC,CAAD,CAFU,EAELA,MAAM,CAAC,CAAD,CAFD,EAEMA,MAAM,CAAC,CAAD,CAFZ,EAEiBA,MAAM,CAAC,CAAD,CAFvB,EAE4BA,MAAM,CAAC,CAAD,CAFlC,EAEuCV,EAFvC,EAE2CC,EAF3C,EAE+CC,MAF/C,CAAhB;AAGAG,QAAAA,KAAK,GAAGa,SAAS,IAAInB,SAAS,GAAG,CAAjC;AACA;;AAEF,WAAK,GAAL;AACE;AACA,YAAIoB,SAAS,GAAGX,OAAO,CAACW,SAAxB;AACA,YAAIC,EAAE,GAAGD,SAAS,CAACC,EAAnB;AAAA,YACIC,EAAE,GAAGF,SAAS,CAACE,EADnB;AAAA,YAEIC,EAAE,GAAGH,SAAS,CAACG,EAFnB;AAAA,YAGIC,EAAE,GAAGJ,SAAS,CAACI,EAHnB;AAAA,YAIIC,UAAU,GAAGL,SAAS,CAACK,UAJ3B;AAAA,YAKIC,QAAQ,GAAGN,SAAS,CAACM,QALzB;AAAA,YAMIC,SAAS,GAAGP,SAAS,CAACO,SAN1B;AAOA,YAAIC,CAAC,GAAGL,EAAE,GAAGC,EAAL,GAAUD,EAAV,GAAeC,EAAvB;AACA,YAAIK,MAAM,GAAGN,EAAE,GAAGC,EAAL,GAAU,CAAV,GAAcD,EAAE,GAAGC,EAAhC;AACA,YAAIM,MAAM,GAAGP,EAAE,GAAGC,EAAL,GAAUA,EAAE,GAAGD,EAAf,GAAoB,CAAjC,CAZF,CAYsC;AACpC;AACA;AACA;AACA;AACA;;AAEA,YAAIQ,CAAC,GAAG3C,IAAI,CAAC4C,eAAL,CAAqB5C,IAAI,CAAC6C,MAAL,EAArB,EAAoC,CAAC,CAACZ,EAAF,EAAM,CAACC,EAAP,CAApC,CAAR;AACAlC,QAAAA,IAAI,CAAC8C,QAAL,CAAcH,CAAd,EAAiB3C,IAAI,CAAC+C,YAAL,CAAkB/C,IAAI,CAAC6C,MAAL,EAAlB,EAAiC,CAACN,SAAlC,CAAjB,EAA+DI,CAA/D;AACA3C,QAAAA,IAAI,CAAC8C,QAAL,CAAcH,CAAd,EAAiB3C,IAAI,CAACgD,WAAL,CAAiBhD,IAAI,CAAC6C,MAAL,EAAjB,EAAgC,CAAC,IAAIJ,MAAL,EAAa,IAAIC,MAAjB,CAAhC,CAAjB,EAA4EC,CAA5E;AACA,YAAIM,CAAC,GAAGhD,IAAI,CAACiD,UAAL,CAAgBrC,EAAhB,EAAoBC,EAApB,CAAR;AACAmC,QAAAA,CAAC,GAAGhD,IAAI,CAACkD,aAAL,CAAmBF,CAAnB,EAAsBA,CAAtB,EAAyBN,CAAzB,CAAJ,CAvBF,CAuBmC;AACjC;AACA;;AAEAzB,QAAAA,KAAK,GAAGZ,KAAK,CAAC,CAAD,EAAI,CAAJ,EAAOkC,CAAP,EAAUH,UAAV,EAAsBC,QAAtB,EAAgC1B,SAAhC,EAA2CqC,CAAC,CAAC,CAAD,CAA5C,EAAiDA,CAAC,CAAC,CAAD,CAAlD,CAAb;AACA;;AAEF;AACE;AAlDJ;;AAqDA,QAAI/B,KAAJ,EAAW;AACT;AACD;AACF;;AAED,SAAOA,KAAP;AACD;;AAED,OAAO,SAASkC,aAAT,CAAuBC,aAAvB,EAAsCC,QAAtC,EAAgDF,aAAhD,EAA+D;AACpE,MAAIG,EAAE,GAAGF,aAAa,CAACG,WAAvB;AAAA,MACI5C,SAAS,GAAG2C,EAAE,CAAC3C,SADnB;AAAA,MAEI6C,MAAM,GAAGF,EAAE,CAACE,MAFhB;AAAA,MAGIC,IAAI,GAAGH,EAAE,CAACG,IAHd;AAAA,MAIIC,EAAE,GAAGJ,EAAE,CAACK,IAJZ;AAAA,MAKI5C,CAAC,GAAG2C,EAAE,KAAK,KAAK,CAAZ,GAAgB,CAAhB,GAAoBA,EAL5B;AAAA,MAMIE,EAAE,GAAGN,EAAE,CAACO,IANZ;AAAA,MAOI7C,CAAC,GAAG4C,EAAE,KAAK,KAAK,CAAZ,GAAgB,CAAhB,GAAoBA,EAP5B;AAAA,MAQIE,eAAe,GAAGR,EAAE,CAACQ,eARzB;AAAA,MASIC,IAAI,GAAGT,EAAE,CAACS,IATd;AAUA,MAAIC,OAAO,GAAGP,IAAI,IAAI,CAACA,IAAI,CAACQ,MAA5B;AACA,MAAIC,SAAS,GAAGV,MAAM,IAAI,CAACA,MAAM,CAACS,MAAlC;AACA,MAAIvD,QAAQ,GAAGqD,IAAI,CAACrD,QAApB;AAAA,MACIyD,MAAM,GAAGJ,IAAI,CAACI,MADlB;AAAA,MAEIC,SAAS,GAAGL,IAAI,CAACK,SAFrB;AAAA,MAGIC,QAAQ,GAAGN,IAAI,CAACM,QAHpB;AAAA,MAIIC,WAAW,GAAGP,IAAI,CAACO,WAJvB;AAKA,MAAIC,UAAU,GAAG,CAAC,EAAET,eAAe,KAAK,IAApB,IAA4BA,eAAe,KAAK,KAAK,CAArD,GAAyD,KAAK,CAA9D,GAAkEA,eAAe,CAAChD,MAApF,CAAlB;AACA,MAAIG,KAAK,GAAG,KAAZ;;AAEA,MAAIiD,SAAS,IAAIK,UAAjB,EAA6B;AAC3BtD,IAAAA,KAAK,GAAGR,eAAe,CAACC,QAAD,EAAWC,SAAS,CAAC6D,KAArB,EAA4BnB,QAAQ,CAACtC,CAAT,GAAaA,CAAzC,EAA4CsC,QAAQ,CAACrC,CAAT,GAAaA,CAAzD,EAA4DsD,WAA5D,EAAyEvD,CAAzE,EAA4EC,CAA5E,CAAvB;AACD;;AAED,MAAI,CAACC,KAAD,KAAW+C,OAAO,IAAIO,UAAtB,CAAJ,EAAuC;AACrC,QAAIJ,MAAJ,EAAY;AACV;AACAlD,MAAAA,KAAK,GAAGkC,aAAa,CAACC,aAAD,EAAgBC,QAAhB,CAArB;AACD,KAHD,MAGO;AACL;AACApC,MAAAA,KAAK,GAAGT,UAAU,CAAC6D,QAAD,EAAWhB,QAAQ,CAACtC,CAAT,GAAaA,CAAxB,EAA2BsC,QAAQ,CAACrC,CAAT,GAAaA,CAAxC,CAAV,IAAwDR,UAAU,CAAC4D,SAAD,EAAYf,QAAQ,CAACtC,CAAT,GAAaA,CAAzB,EAA4BsC,QAAQ,CAACrC,CAAT,GAAaA,CAAzC,CAA1E;AACD;AACF;;AAED,SAAOC,KAAP;AACD","sourcesContent":["import { mat3, vec2 } from 'gl-matrix';\nimport { Quad as QuadUtil, Cubic as CubicUtil } from '@antv/g-math';\nimport { inArc, inBox, inLine, inPolygons } from './utils/math';\n\nfunction isPointInStroke(segments, lineWidth, px, py, length, x, y) {\n  var isHit = false;\n  var halfWidth = lineWidth / 2;\n\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    var currentPoint = segment.currentPoint,\n        params = segment.params,\n        prePoint = segment.prePoint,\n        box = segment.box; // 如果在前面已经生成过包围盒，直接按照包围盒计算\n\n    if (box && !inBox(box.x - halfWidth, box.y - halfWidth, box.width + lineWidth, box.height + lineWidth, px, py)) {\n      continue;\n    }\n\n    switch (segment.command) {\n      // L 和 Z 都是直线， M 不进行拾取\n      case 'L':\n      case 'Z':\n        isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, px, py);\n        break;\n\n      case 'Q':\n        var qDistance = QuadUtil.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], px, py);\n        isHit = qDistance <= lineWidth / 2;\n        break;\n\n      case 'C':\n        var cDistance = CubicUtil.pointDistance(prePoint[0], // 上一段结束位置, 即 C 的起始点\n        prePoint[1], params[1], // 'C' 的参数，1、2 为第一个控制点，3、4 为第二个控制点，5、6 为结束点\n        params[2], params[3], params[4], params[5], params[6], px, py, length);\n        isHit = cDistance <= lineWidth / 2;\n        break;\n\n      case 'A':\n        // 计算点到椭圆圆弧的距离，暂时使用近似算法，后面可以改成切割法求最近距离\n        var arcParams = segment.arcParams;\n        var cx = arcParams.cx,\n            cy = arcParams.cy,\n            rx = arcParams.rx,\n            ry = arcParams.ry,\n            startAngle = arcParams.startAngle,\n            endAngle = arcParams.endAngle,\n            xRotation = arcParams.xRotation;\n        var r = rx > ry ? rx : ry;\n        var scaleX = rx > ry ? 1 : rx / ry;\n        var scaleY = rx > ry ? ry / rx : 1; // const m = transform(null, [\n        //   ['t', -cx, -cy],\n        //   ['r', -xRotation],\n        //   ['s', 1 / scaleX, 1 / scaleY],\n        // ]);\n        // FIXME\n\n        var m = mat3.fromTranslation(mat3.create(), [-cx, -cy]);\n        mat3.multiply(m, mat3.fromRotation(mat3.create(), -xRotation), m);\n        mat3.multiply(m, mat3.fromScaling(mat3.create(), [1 / scaleX, 1 / scaleY]), m);\n        var p = vec2.fromValues(px, py);\n        p = vec2.transformMat3(p, p, m); // isHit = inArc(cx, cy, r, startAngle, endAngle, lineWidth, px, py);\n        // console.log(m, p[0], px - cx);\n        // isHit = inArc(cx, cy, r, startAngle, endAngle, lineWidth, px, py);\n\n        isHit = inArc(0, 0, r, startAngle, endAngle, lineWidth, p[0], p[1]);\n        break;\n\n      default:\n        break;\n    }\n\n    if (isHit) {\n      break;\n    }\n  }\n\n  return isHit;\n}\n\nexport function isPointInPath(displayObject, position, isPointInPath) {\n  var _a = displayObject.parsedStyle,\n      lineWidth = _a.lineWidth,\n      stroke = _a.stroke,\n      fill = _a.fill,\n      _b = _a.defX,\n      x = _b === void 0 ? 0 : _b,\n      _c = _a.defY,\n      y = _c === void 0 ? 0 : _c,\n      clipPathTargets = _a.clipPathTargets,\n      path = _a.path;\n  var hasFill = fill && !fill.isNone;\n  var hasStroke = stroke && !stroke.isNone;\n  var segments = path.segments,\n      hasArc = path.hasArc,\n      polylines = path.polylines,\n      polygons = path.polygons,\n      totalLength = path.totalLength;\n  var isClipPath = !!(clipPathTargets === null || clipPathTargets === void 0 ? void 0 : clipPathTargets.length);\n  var isHit = false;\n\n  if (hasStroke || isClipPath) {\n    isHit = isPointInStroke(segments, lineWidth.value, position.x + x, position.y + y, totalLength, x, y);\n  }\n\n  if (!isHit && (hasFill || isClipPath)) {\n    if (hasArc) {\n      // 存在曲线时，暂时使用 canvas 的 api 计算，后续可以进行多边形切割\n      isHit = isPointInPath(displayObject, position);\n    } else {\n      // 提取出来的多边形包含闭合的和非闭合的，在这里统一按照多边形处理\n      isHit = inPolygons(polygons, position.x + x, position.y + y) || inPolygons(polylines, position.x + x, position.y + y);\n    }\n  }\n\n  return isHit;\n}"]},"metadata":{},"sourceType":"module"}