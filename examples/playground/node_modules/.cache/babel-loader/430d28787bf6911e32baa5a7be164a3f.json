{"ast":null,"code":"/**\n * @fileoverview 判断点是否在多边形内\n * @author dxq613@gmail.com\n */\n// 多边形的射线检测，参考：https://blog.csdn.net/WilliamSun0122/article/details/77994526\nvar tolerance = 1e-6; // 三态函数，判断两个double在eps精度下的大小关系\n\nfunction dcmp(x) {\n  if (Math.abs(x) < tolerance) {\n    return 0;\n  }\n\n  return x < 0 ? -1 : 1;\n} // 判断点Q是否在p1和p2的线段上\n\n\nfunction onSegment(p1, p2, q) {\n  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {\n    return true;\n  }\n\n  return false;\n} // 判断点P在多边形内-射线法\n\n\nexport default function isInPolygon(points, x, y) {\n  var isHit = false;\n  var n = points.length;\n\n  if (n <= 2) {\n    // svg 中点小于 3 个时，不显示，也无法被拾取\n    return false;\n  }\n\n  for (var i = 0; i < n; i++) {\n    var p1 = points[i];\n    var p2 = points[(i + 1) % n];\n\n    if (onSegment(p1, p2, [x, y])) {\n      // 点在多边形一条边上\n      return true;\n    } // 前一个判断min(p1[1],p2[1])<P.y<=max(p1[1],p2[1])\n    // 后一个判断被测点 在 射线与边交点 的左边\n\n\n    if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 && dcmp(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {\n      isHit = !isHit;\n    }\n  }\n\n  return isHit;\n}","map":{"version":3,"mappings":"AAAA;;;;AAKA;AACA,IAAMA,SAAS,GAAG,IAAlB,C,CACA;;AACA,SAASC,IAAT,CAAcC,CAAd,EAAe;AACb,MAAIC,IAAI,CAACC,GAAL,CAASF,CAAT,IAAcF,SAAlB,EAA6B;AAC3B,WAAO,CAAP;AACD;;AAED,SAAOE,CAAC,GAAG,CAAJ,GAAQ,CAAC,CAAT,GAAa,CAApB;AACD,C,CAED;;;AACA,SAASG,SAAT,CAAmBC,EAAnB,EAAuBC,EAAvB,EAA2BC,CAA3B,EAA4B;AAC1B,MACE,CAACA,CAAC,CAAC,CAAD,CAAD,GAAOF,EAAE,CAAC,CAAD,CAAV,KAAkBC,EAAE,CAAC,CAAD,CAAF,GAAQD,EAAE,CAAC,CAAD,CAA5B,MAAqC,CAACC,EAAE,CAAC,CAAD,CAAF,GAAQD,EAAE,CAAC,CAAD,CAAX,KAAmBE,CAAC,CAAC,CAAD,CAAD,GAAOF,EAAE,CAAC,CAAD,CAA5B,CAArC,IACAH,IAAI,CAACM,GAAL,CAASH,EAAE,CAAC,CAAD,CAAX,EAAgBC,EAAE,CAAC,CAAD,CAAlB,KAA0BC,CAAC,CAAC,CAAD,CAD3B,IAEAA,CAAC,CAAC,CAAD,CAAD,IAAQL,IAAI,CAACO,GAAL,CAASJ,EAAE,CAAC,CAAD,CAAX,EAAgBC,EAAE,CAAC,CAAD,CAAlB,CAFR,IAGAJ,IAAI,CAACM,GAAL,CAASH,EAAE,CAAC,CAAD,CAAX,EAAgBC,EAAE,CAAC,CAAD,CAAlB,KAA0BC,CAAC,CAAC,CAAD,CAH3B,IAIAA,CAAC,CAAC,CAAD,CAAD,IAAQL,IAAI,CAACO,GAAL,CAASJ,EAAE,CAAC,CAAD,CAAX,EAAgBC,EAAE,CAAC,CAAD,CAAlB,CALV,EAME;AACA,WAAO,IAAP;AACD;;AACD,SAAO,KAAP;AACD,C,CAED;;;AACA,eAAc,SAAUI,WAAV,CAAsBC,MAAtB,EAA8BV,CAA9B,EAAiCW,CAAjC,EAAkC;AAC9C,MAAIC,KAAK,GAAG,KAAZ;AACA,MAAMC,CAAC,GAAGH,MAAM,CAACI,MAAjB;;AACA,MAAID,CAAC,IAAI,CAAT,EAAY;AACV;AACA,WAAO,KAAP;AACD;;AACD,OAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,CAApB,EAAuBE,CAAC,EAAxB,EAA4B;AAC1B,QAAMX,EAAE,GAAGM,MAAM,CAACK,CAAD,CAAjB;AACA,QAAMV,EAAE,GAAGK,MAAM,CAAC,CAACK,CAAC,GAAG,CAAL,IAAUF,CAAX,CAAjB;;AACA,QAAIV,SAAS,CAACC,EAAD,EAAKC,EAAL,EAAS,CAACL,CAAD,EAAIW,CAAJ,CAAT,CAAb,EAA+B;AAC7B;AACA,aAAO,IAAP;AACD,KANyB,CAO1B;AACA;;;AACA,QACEZ,IAAI,CAACK,EAAE,CAAC,CAAD,CAAF,GAAQO,CAAT,CAAJ,GAAkB,CAAlB,KAAwBZ,IAAI,CAACM,EAAE,CAAC,CAAD,CAAF,GAAQM,CAAT,CAAJ,GAAkB,CAA1C,IACAZ,IAAI,CAACC,CAAC,GAAI,CAACW,CAAC,GAAGP,EAAE,CAAC,CAAD,CAAP,KAAeA,EAAE,CAAC,CAAD,CAAF,GAAQC,EAAE,CAAC,CAAD,CAAzB,CAAD,IAAmCD,EAAE,CAAC,CAAD,CAAF,GAAQC,EAAE,CAAC,CAAD,CAA7C,CAAJ,GAAwDD,EAAE,CAAC,CAAD,CAA3D,CAAJ,GAAsE,CAFxE,EAGE;AACAQ,WAAK,GAAG,CAACA,KAAT;AACD;AACF;;AACD,SAAOA,KAAP;AACD","names":["tolerance","dcmp","x","Math","abs","onSegment","p1","p2","q","min","max","isInPolygon","points","y","isHit","n","length","i"],"sources":["/Users/dennis.zhang/Desktop/其它代码库/moa-flow/node_modules/@antv/path-util/src/point-in-polygon.ts"],"sourcesContent":["/**\n * @fileoverview 判断点是否在多边形内\n * @author dxq613@gmail.com\n */\n\n// 多边形的射线检测，参考：https://blog.csdn.net/WilliamSun0122/article/details/77994526\nconst tolerance = 1e-6;\n// 三态函数，判断两个double在eps精度下的大小关系\nfunction dcmp(x) {\n  if (Math.abs(x) < tolerance) {\n    return 0;\n  }\n\n  return x < 0 ? -1 : 1;\n}\n\n// 判断点Q是否在p1和p2的线段上\nfunction onSegment(p1, p2, q) {\n  if (\n    (q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) &&\n    Math.min(p1[0], p2[0]) <= q[0] &&\n    q[0] <= Math.max(p1[0], p2[0]) &&\n    Math.min(p1[1], p2[1]) <= q[1] &&\n    q[1] <= Math.max(p1[1], p2[1])\n  ) {\n    return true;\n  }\n  return false;\n}\n\n// 判断点P在多边形内-射线法\nexport default function isInPolygon(points, x, y) {\n  let isHit = false;\n  const n = points.length;\n  if (n <= 2) {\n    // svg 中点小于 3 个时，不显示，也无法被拾取\n    return false;\n  }\n  for (let i = 0; i < n; i++) {\n    const p1 = points[i];\n    const p2 = points[(i + 1) % n];\n    if (onSegment(p1, p2, [x, y])) {\n      // 点在多边形一条边上\n      return true;\n    }\n    // 前一个判断min(p1[1],p2[1])<P.y<=max(p1[1],p2[1])\n    // 后一个判断被测点 在 射线与边交点 的左边\n    if (\n      dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 &&\n      dcmp(x - ((y - p1[1]) * (p1[0] - p2[0])) / (p1[1] - p2[1]) - p1[0]) < 0\n    ) {\n      isHit = !isHit;\n    }\n  }\n  return isHit;\n}\n"]},"metadata":{},"sourceType":"module"}