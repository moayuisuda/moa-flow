{"ast":null,"code":"import isPointInPolygon from './point-in-polygon';\nimport getLineIntersect from './get-line-intersect';\nimport { each } from 'lodash-es';\n\nfunction parseToLines(points) {\n  var lines = [];\n  var count = points.length;\n\n  for (var i = 0; i < count - 1; i++) {\n    var point = points[i];\n    var next = points[i + 1];\n    lines.push({\n      from: {\n        x: point[0],\n        y: point[1]\n      },\n      to: {\n        x: next[0],\n        y: next[1]\n      }\n    });\n  }\n\n  if (lines.length > 1) {\n    var first = points[0];\n    var last = points[count - 1];\n    lines.push({\n      from: {\n        x: last[0],\n        y: last[1]\n      },\n      to: {\n        x: first[0],\n        y: first[1]\n      }\n    });\n  }\n\n  return lines;\n}\n\nfunction lineIntersectPolygon(lines, line) {\n  var isIntersect = false;\n  each(lines, function (l) {\n    if (getLineIntersect(l.from, l.to, line.from, line.to)) {\n      isIntersect = true;\n      return false;\n    }\n  });\n  return isIntersect;\n}\n\nfunction getBBox(points) {\n  var xArr = points.map(function (p) {\n    return p[0];\n  });\n  var yArr = points.map(function (p) {\n    return p[1];\n  });\n  return {\n    minX: Math.min.apply(null, xArr),\n    maxX: Math.max.apply(null, xArr),\n    minY: Math.min.apply(null, yArr),\n    maxY: Math.max.apply(null, yArr)\n  };\n}\n\nfunction intersectBBox(box1, box2) {\n  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);\n}\n\nexport default function isPolygonsIntersect(points1, points2) {\n  // 空数组，或者一个点返回 false\n  if (points1.length < 2 || points2.length < 2) {\n    return false;\n  }\n\n  var bbox1 = getBBox(points1);\n  var bbox2 = getBBox(points2); // 判定包围盒是否相交，比判定点是否在多边形内要快的多，可以筛选掉大多数情况\n\n  if (!intersectBBox(bbox1, bbox2)) {\n    return false;\n  }\n\n  var isIn = false; // 判定点是否在多边形内部，一旦有一个点在另一个多边形内，则返回\n\n  each(points2, function (point) {\n    if (isPointInPolygon(points1, point[0], point[1])) {\n      isIn = true;\n      return false;\n    }\n  });\n\n  if (isIn) {\n    return true;\n  } // 两个多边形都需要判定\n\n\n  each(points1, function (point) {\n    if (isPointInPolygon(points2, point[0], point[1])) {\n      isIn = true;\n      return false;\n    }\n  });\n\n  if (isIn) {\n    return true;\n  }\n\n  var lines1 = parseToLines(points1);\n  var lines2 = parseToLines(points2);\n  var isIntersect = false;\n  each(lines2, function (line) {\n    if (lineIntersectPolygon(lines1, line)) {\n      isIntersect = true;\n      return false;\n    }\n  });\n  return isIntersect;\n}","map":{"version":3,"mappings":"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","names":["isPointInPolygon","getLineIntersect","each","parseToLines","points","lines","count","length","i","point","next","push","from","x","y","to","first","last","lineIntersectPolygon","line","isIntersect","l","getBBox","xArr","map","p","yArr","minX","Math","min","apply","maxX","max","minY","maxY","intersectBBox","box1","box2","isPolygonsIntersect","points1","points2","bbox1","bbox2","isIn","lines1","lines2"],"sources":["/Users/dennis.zhang/Desktop/其它代码库/moa-flow/node_modules/@antv/path-util/src/is-polygons-intersect.ts"],"sourcesContent":["import isPointInPolygon from './point-in-polygon';\nimport getLineIntersect from './get-line-intersect';\nimport { each } from 'lodash-es';\n\nfunction parseToLines(points) {\n  const lines = [];\n  const count = points.length;\n  for (let i = 0; i < count - 1; i++) {\n    const point = points[i];\n    const next = points[i + 1];\n    lines.push({\n      from: {\n        x: point[0],\n        y: point[1],\n      },\n      to: {\n        x: next[0],\n        y: next[1],\n      },\n    });\n  }\n  if (lines.length > 1) {\n    const first = points[0];\n    const last = points[count - 1];\n    lines.push({\n      from: {\n        x: last[0],\n        y: last[1],\n      },\n      to: {\n        x: first[0],\n        y: first[1],\n      },\n    });\n  }\n  return lines;\n}\n\nfunction lineIntersectPolygon(lines, line) {\n  let isIntersect = false;\n  each(lines, (l) => {\n    if (getLineIntersect(l.from, l.to, line.from, line.to)) {\n      isIntersect = true;\n      return false;\n    }\n  });\n  return isIntersect;\n}\n\ntype BBox = {\n  minX: number;\n  minY: number;\n  maxX: number;\n  maxY: number;\n};\n\nfunction getBBox(points): BBox {\n  const xArr = points.map((p) => p[0]);\n  const yArr = points.map((p) => p[1]);\n  return {\n    minX: Math.min.apply(null, xArr),\n    maxX: Math.max.apply(null, xArr),\n    minY: Math.min.apply(null, yArr),\n    maxY: Math.max.apply(null, yArr),\n  };\n}\n\nfunction intersectBBox(box1: BBox, box2: BBox) {\n  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);\n}\n\nexport default function isPolygonsIntersect(points1, points2) {\n  // 空数组，或者一个点返回 false\n  if (points1.length < 2 || points2.length < 2) {\n    return false;\n  }\n\n  const bbox1 = getBBox(points1);\n  const bbox2 = getBBox(points2);\n  // 判定包围盒是否相交，比判定点是否在多边形内要快的多，可以筛选掉大多数情况\n  if (!intersectBBox(bbox1, bbox2)) {\n    return false;\n  }\n\n  let isIn = false;\n  // 判定点是否在多边形内部，一旦有一个点在另一个多边形内，则返回\n  each(points2, (point) => {\n    if (isPointInPolygon(points1, point[0], point[1])) {\n      isIn = true;\n      return false;\n    }\n  });\n  if (isIn) {\n    return true;\n  }\n  // 两个多边形都需要判定\n  each(points1, (point) => {\n    if (isPointInPolygon(points2, point[0], point[1])) {\n      isIn = true;\n      return false;\n    }\n  });\n  if (isIn) {\n    return true;\n  }\n\n  const lines1 = parseToLines(points1);\n  const lines2 = parseToLines(points2);\n  let isIntersect = false;\n  each(lines2, (line) => {\n    if (lineIntersectPolygon(lines1, line)) {\n      isIntersect = true;\n      return false;\n    }\n  });\n  return isIntersect;\n}\n"]},"metadata":{},"sourceType":"module"}