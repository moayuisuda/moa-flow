{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport * as React from 'react';\nexport default function useOffset(min, max, step, markList, allowCross, pushable) {\n  var formatRangeValue = React.useCallback(function (val) {\n    var formatNextValue = isFinite(val) ? val : min;\n    formatNextValue = Math.min(max, val);\n    formatNextValue = Math.max(min, formatNextValue);\n    return formatNextValue;\n  }, [min, max]);\n  var formatStepValue = React.useCallback(function (val) {\n    if (step !== null) {\n      var stepValue = min + Math.round((formatRangeValue(val) - min) / step) * step; // Cut number in case to be like 0.30000000000000004\n\n      var getDecimal = function getDecimal(num) {\n        return (String(num).split('.')[1] || '').length;\n      };\n\n      var maxDecimal = Math.max(getDecimal(step), getDecimal(max), getDecimal(min));\n      var fixedValue = Number(stepValue.toFixed(maxDecimal));\n      return min <= fixedValue && fixedValue <= max ? fixedValue : null;\n    }\n\n    return null;\n  }, [step, min, max, formatRangeValue]);\n  var formatValue = React.useCallback(function (val) {\n    var formatNextValue = formatRangeValue(val); // List align values\n\n    var alignValues = markList.map(function (mark) {\n      return mark.value;\n    });\n\n    if (step !== null) {\n      alignValues.push(formatStepValue(val));\n    } // min & max\n\n\n    alignValues.push(min, max); // Align with marks\n\n    var closeValue = alignValues[0];\n    var closeDist = max - min;\n    alignValues.forEach(function (alignValue) {\n      var dist = Math.abs(formatNextValue - alignValue);\n\n      if (dist <= closeDist) {\n        closeValue = alignValue;\n        closeDist = dist;\n      }\n    });\n    return closeValue;\n  }, [min, max, markList, step, formatRangeValue, formatStepValue]); // ========================== Offset ==========================\n  // Single Value\n\n  var offsetValue = function offsetValue(values, offset, valueIndex) {\n    var mode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'unit';\n\n    if (typeof offset === 'number') {\n      var nextValue;\n      var originValue = values[valueIndex]; // Only used for `dist` mode\n\n      var targetDistValue = originValue + offset; // Compare next step value & mark value which is best match\n\n      var potentialValues = [];\n      markList.forEach(function (mark) {\n        potentialValues.push(mark.value);\n      }); // Min & Max\n\n      potentialValues.push(min, max); // In case origin value is align with mark but not with step\n\n      potentialValues.push(formatStepValue(originValue)); // Put offset step value also\n\n      var sign = offset > 0 ? 1 : -1;\n\n      if (mode === 'unit') {\n        potentialValues.push(formatStepValue(originValue + sign * step));\n      } else {\n        potentialValues.push(formatStepValue(targetDistValue));\n      } // Find close one\n\n\n      potentialValues = potentialValues.filter(function (val) {\n        return val !== null;\n      }) // Remove reverse value\n      .filter(function (val) {\n        return offset < 0 ? val <= originValue : val >= originValue;\n      });\n\n      if (mode === 'unit') {\n        // `unit` mode can not contain itself\n        potentialValues = potentialValues.filter(function (val) {\n          return val !== originValue;\n        });\n      }\n\n      var compareValue = mode === 'unit' ? originValue : targetDistValue;\n      nextValue = potentialValues[0];\n      var valueDist = Math.abs(nextValue - compareValue);\n      potentialValues.forEach(function (potentialValue) {\n        var dist = Math.abs(potentialValue - compareValue);\n\n        if (dist < valueDist) {\n          nextValue = potentialValue;\n          valueDist = dist;\n        }\n      }); // Out of range will back to range\n\n      if (nextValue === undefined) {\n        return offset < 0 ? min : max;\n      } // `dist` mode\n\n\n      if (mode === 'dist') {\n        return nextValue;\n      } // `unit` mode may need another round\n\n\n      if (Math.abs(offset) > 1) {\n        var cloneValues = _toConsumableArray(values);\n\n        cloneValues[valueIndex] = nextValue;\n        return offsetValue(cloneValues, offset - sign, valueIndex, mode);\n      }\n\n      return nextValue;\n    } else if (offset === 'min') {\n      return min;\n    } else if (offset === 'max') {\n      return max;\n    }\n  };\n  /** Same as `offsetValue` but return `changed` mark to tell value changed */\n\n\n  var offsetChangedValue = function offsetChangedValue(values, offset, valueIndex) {\n    var mode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'unit';\n    var originValue = values[valueIndex];\n    var nextValue = offsetValue(values, offset, valueIndex, mode);\n    return {\n      value: nextValue,\n      changed: nextValue !== originValue\n    };\n  };\n\n  var needPush = function needPush(dist) {\n    return pushable === null && dist === 0 || typeof pushable === 'number' && dist < pushable;\n  }; // Values\n\n\n  var offsetValues = function offsetValues(values, offset, valueIndex) {\n    var mode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'unit';\n    var nextValues = values.map(formatValue);\n    var originValue = nextValues[valueIndex];\n    var nextValue = offsetValue(nextValues, offset, valueIndex, mode);\n    nextValues[valueIndex] = nextValue;\n\n    if (allowCross === false) {\n      // >>>>> Allow Cross\n      var pushNum = pushable || 0; // ============ AllowCross ===============\n\n      if (valueIndex > 0 && nextValues[valueIndex - 1] !== originValue) {\n        nextValues[valueIndex] = Math.max(nextValues[valueIndex], nextValues[valueIndex - 1] + pushNum);\n      }\n\n      if (valueIndex < nextValues.length - 1 && nextValues[valueIndex + 1] !== originValue) {\n        nextValues[valueIndex] = Math.min(nextValues[valueIndex], nextValues[valueIndex + 1] - pushNum);\n      }\n    } else if (typeof pushable === 'number' || pushable === null) {\n      // >>>>> Pushable\n      // =============== Push ==================\n      // >>>>>> Basic push\n      // End values\n      for (var i = valueIndex + 1; i < nextValues.length; i += 1) {\n        var changed = true;\n\n        while (needPush(nextValues[i] - nextValues[i - 1]) && changed) {\n          var _offsetChangedValue = offsetChangedValue(nextValues, 1, i);\n\n          nextValues[i] = _offsetChangedValue.value;\n          changed = _offsetChangedValue.changed;\n        }\n      } // Start values\n\n\n      for (var _i = valueIndex; _i > 0; _i -= 1) {\n        var _changed = true;\n\n        while (needPush(nextValues[_i] - nextValues[_i - 1]) && _changed) {\n          var _offsetChangedValue2 = offsetChangedValue(nextValues, -1, _i - 1);\n\n          nextValues[_i - 1] = _offsetChangedValue2.value;\n          _changed = _offsetChangedValue2.changed;\n        }\n      } // >>>>> Revert back to safe push range\n      // End to Start\n\n\n      for (var _i2 = nextValues.length - 1; _i2 > 0; _i2 -= 1) {\n        var _changed2 = true;\n\n        while (needPush(nextValues[_i2] - nextValues[_i2 - 1]) && _changed2) {\n          var _offsetChangedValue3 = offsetChangedValue(nextValues, -1, _i2 - 1);\n\n          nextValues[_i2 - 1] = _offsetChangedValue3.value;\n          _changed2 = _offsetChangedValue3.changed;\n        }\n      } // Start to End\n\n\n      for (var _i3 = 0; _i3 < nextValues.length - 1; _i3 += 1) {\n        var _changed3 = true;\n\n        while (needPush(nextValues[_i3 + 1] - nextValues[_i3]) && _changed3) {\n          var _offsetChangedValue4 = offsetChangedValue(nextValues, 1, _i3 + 1);\n\n          nextValues[_i3 + 1] = _offsetChangedValue4.value;\n          _changed3 = _offsetChangedValue4.changed;\n        }\n      }\n    }\n\n    return {\n      value: nextValues[valueIndex],\n      values: nextValues\n    };\n  };\n\n  return [formatValue, offsetValues];\n}","map":{"version":3,"sources":["/Users/dennis.zhang/Desktop/其它代码库/moa-flow/node_modules/rc-slider/es/hooks/useOffset.js"],"names":["_toConsumableArray","React","useOffset","min","max","step","markList","allowCross","pushable","formatRangeValue","useCallback","val","formatNextValue","isFinite","Math","formatStepValue","stepValue","round","getDecimal","num","String","split","length","maxDecimal","fixedValue","Number","toFixed","formatValue","alignValues","map","mark","value","push","closeValue","closeDist","forEach","alignValue","dist","abs","offsetValue","values","offset","valueIndex","mode","arguments","undefined","nextValue","originValue","targetDistValue","potentialValues","sign","filter","compareValue","valueDist","potentialValue","cloneValues","offsetChangedValue","changed","needPush","offsetValues","nextValues","pushNum","i","_offsetChangedValue","_i","_changed","_offsetChangedValue2","_i2","_changed2","_offsetChangedValue3","_i3","_changed3","_offsetChangedValue4"],"mappings":"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","sourcesContent":["import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport * as React from 'react';\nexport default function useOffset(min, max, step, markList, allowCross, pushable) {\n  var formatRangeValue = React.useCallback(function (val) {\n    var formatNextValue = isFinite(val) ? val : min;\n    formatNextValue = Math.min(max, val);\n    formatNextValue = Math.max(min, formatNextValue);\n    return formatNextValue;\n  }, [min, max]);\n  var formatStepValue = React.useCallback(function (val) {\n    if (step !== null) {\n      var stepValue = min + Math.round((formatRangeValue(val) - min) / step) * step; // Cut number in case to be like 0.30000000000000004\n\n      var getDecimal = function getDecimal(num) {\n        return (String(num).split('.')[1] || '').length;\n      };\n\n      var maxDecimal = Math.max(getDecimal(step), getDecimal(max), getDecimal(min));\n      var fixedValue = Number(stepValue.toFixed(maxDecimal));\n      return min <= fixedValue && fixedValue <= max ? fixedValue : null;\n    }\n\n    return null;\n  }, [step, min, max, formatRangeValue]);\n  var formatValue = React.useCallback(function (val) {\n    var formatNextValue = formatRangeValue(val); // List align values\n\n    var alignValues = markList.map(function (mark) {\n      return mark.value;\n    });\n\n    if (step !== null) {\n      alignValues.push(formatStepValue(val));\n    } // min & max\n\n\n    alignValues.push(min, max); // Align with marks\n\n    var closeValue = alignValues[0];\n    var closeDist = max - min;\n    alignValues.forEach(function (alignValue) {\n      var dist = Math.abs(formatNextValue - alignValue);\n\n      if (dist <= closeDist) {\n        closeValue = alignValue;\n        closeDist = dist;\n      }\n    });\n    return closeValue;\n  }, [min, max, markList, step, formatRangeValue, formatStepValue]); // ========================== Offset ==========================\n  // Single Value\n\n  var offsetValue = function offsetValue(values, offset, valueIndex) {\n    var mode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'unit';\n\n    if (typeof offset === 'number') {\n      var nextValue;\n      var originValue = values[valueIndex]; // Only used for `dist` mode\n\n      var targetDistValue = originValue + offset; // Compare next step value & mark value which is best match\n\n      var potentialValues = [];\n      markList.forEach(function (mark) {\n        potentialValues.push(mark.value);\n      }); // Min & Max\n\n      potentialValues.push(min, max); // In case origin value is align with mark but not with step\n\n      potentialValues.push(formatStepValue(originValue)); // Put offset step value also\n\n      var sign = offset > 0 ? 1 : -1;\n\n      if (mode === 'unit') {\n        potentialValues.push(formatStepValue(originValue + sign * step));\n      } else {\n        potentialValues.push(formatStepValue(targetDistValue));\n      } // Find close one\n\n\n      potentialValues = potentialValues.filter(function (val) {\n        return val !== null;\n      }) // Remove reverse value\n      .filter(function (val) {\n        return offset < 0 ? val <= originValue : val >= originValue;\n      });\n\n      if (mode === 'unit') {\n        // `unit` mode can not contain itself\n        potentialValues = potentialValues.filter(function (val) {\n          return val !== originValue;\n        });\n      }\n\n      var compareValue = mode === 'unit' ? originValue : targetDistValue;\n      nextValue = potentialValues[0];\n      var valueDist = Math.abs(nextValue - compareValue);\n      potentialValues.forEach(function (potentialValue) {\n        var dist = Math.abs(potentialValue - compareValue);\n\n        if (dist < valueDist) {\n          nextValue = potentialValue;\n          valueDist = dist;\n        }\n      }); // Out of range will back to range\n\n      if (nextValue === undefined) {\n        return offset < 0 ? min : max;\n      } // `dist` mode\n\n\n      if (mode === 'dist') {\n        return nextValue;\n      } // `unit` mode may need another round\n\n\n      if (Math.abs(offset) > 1) {\n        var cloneValues = _toConsumableArray(values);\n\n        cloneValues[valueIndex] = nextValue;\n        return offsetValue(cloneValues, offset - sign, valueIndex, mode);\n      }\n\n      return nextValue;\n    } else if (offset === 'min') {\n      return min;\n    } else if (offset === 'max') {\n      return max;\n    }\n  };\n  /** Same as `offsetValue` but return `changed` mark to tell value changed */\n\n\n  var offsetChangedValue = function offsetChangedValue(values, offset, valueIndex) {\n    var mode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'unit';\n    var originValue = values[valueIndex];\n    var nextValue = offsetValue(values, offset, valueIndex, mode);\n    return {\n      value: nextValue,\n      changed: nextValue !== originValue\n    };\n  };\n\n  var needPush = function needPush(dist) {\n    return pushable === null && dist === 0 || typeof pushable === 'number' && dist < pushable;\n  }; // Values\n\n\n  var offsetValues = function offsetValues(values, offset, valueIndex) {\n    var mode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'unit';\n    var nextValues = values.map(formatValue);\n    var originValue = nextValues[valueIndex];\n    var nextValue = offsetValue(nextValues, offset, valueIndex, mode);\n    nextValues[valueIndex] = nextValue;\n\n    if (allowCross === false) {\n      // >>>>> Allow Cross\n      var pushNum = pushable || 0; // ============ AllowCross ===============\n\n      if (valueIndex > 0 && nextValues[valueIndex - 1] !== originValue) {\n        nextValues[valueIndex] = Math.max(nextValues[valueIndex], nextValues[valueIndex - 1] + pushNum);\n      }\n\n      if (valueIndex < nextValues.length - 1 && nextValues[valueIndex + 1] !== originValue) {\n        nextValues[valueIndex] = Math.min(nextValues[valueIndex], nextValues[valueIndex + 1] - pushNum);\n      }\n    } else if (typeof pushable === 'number' || pushable === null) {\n      // >>>>> Pushable\n      // =============== Push ==================\n      // >>>>>> Basic push\n      // End values\n      for (var i = valueIndex + 1; i < nextValues.length; i += 1) {\n        var changed = true;\n\n        while (needPush(nextValues[i] - nextValues[i - 1]) && changed) {\n          var _offsetChangedValue = offsetChangedValue(nextValues, 1, i);\n\n          nextValues[i] = _offsetChangedValue.value;\n          changed = _offsetChangedValue.changed;\n        }\n      } // Start values\n\n\n      for (var _i = valueIndex; _i > 0; _i -= 1) {\n        var _changed = true;\n\n        while (needPush(nextValues[_i] - nextValues[_i - 1]) && _changed) {\n          var _offsetChangedValue2 = offsetChangedValue(nextValues, -1, _i - 1);\n\n          nextValues[_i - 1] = _offsetChangedValue2.value;\n          _changed = _offsetChangedValue2.changed;\n        }\n      } // >>>>> Revert back to safe push range\n      // End to Start\n\n\n      for (var _i2 = nextValues.length - 1; _i2 > 0; _i2 -= 1) {\n        var _changed2 = true;\n\n        while (needPush(nextValues[_i2] - nextValues[_i2 - 1]) && _changed2) {\n          var _offsetChangedValue3 = offsetChangedValue(nextValues, -1, _i2 - 1);\n\n          nextValues[_i2 - 1] = _offsetChangedValue3.value;\n          _changed2 = _offsetChangedValue3.changed;\n        }\n      } // Start to End\n\n\n      for (var _i3 = 0; _i3 < nextValues.length - 1; _i3 += 1) {\n        var _changed3 = true;\n\n        while (needPush(nextValues[_i3 + 1] - nextValues[_i3]) && _changed3) {\n          var _offsetChangedValue4 = offsetChangedValue(nextValues, 1, _i3 + 1);\n\n          nextValues[_i3 + 1] = _offsetChangedValue4.value;\n          _changed3 = _offsetChangedValue4.changed;\n        }\n      }\n    }\n\n    return {\n      value: nextValues[valueIndex],\n      values: nextValues\n    };\n  };\n\n  return [formatValue, offsetValues];\n}"]},"metadata":{},"sourceType":"module"}