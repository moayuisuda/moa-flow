{"ast":null,"code":"import { __exports as schedulerTracing_development } from '../../../_virtual/scheduler-tracing.development.js';\nexport { __exports as default } from '../../../_virtual/scheduler-tracing.development.js';\n/** @license React v0.20.2\n * scheduler-tracing.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n(function (exports) {\n  if (process.env.NODE_ENV !== \"production\") {\n    (function () {\n      var DEFAULT_THREAD_ID = 0; // Counters used to generate unique IDs.\n\n      var interactionIDCounter = 0;\n      var threadIDCounter = 0; // Set of currently traced interactions.\n      // Interactions \"stack\"–\n      // Meaning that newly traced interactions are appended to the previously active set.\n      // When an interaction goes out of scope, the previous set (if any) is restored.\n\n      exports.__interactionsRef = null; // Listener(s) to notify when interactions begin and end.\n\n      exports.__subscriberRef = null;\n      {\n        exports.__interactionsRef = {\n          current: new Set()\n        };\n        exports.__subscriberRef = {\n          current: null\n        };\n      }\n\n      function unstable_clear(callback) {\n        var prevInteractions = exports.__interactionsRef.current;\n        exports.__interactionsRef.current = new Set();\n\n        try {\n          return callback();\n        } finally {\n          exports.__interactionsRef.current = prevInteractions;\n        }\n      }\n\n      function unstable_getCurrent() {\n        {\n          return exports.__interactionsRef.current;\n        }\n      }\n\n      function unstable_getThreadID() {\n        return ++threadIDCounter;\n      }\n\n      function unstable_trace(name, timestamp, callback) {\n        var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;\n        var interaction = {\n          __count: 1,\n          id: interactionIDCounter++,\n          name: name,\n          timestamp: timestamp\n        };\n        var prevInteractions = exports.__interactionsRef.current; // Traced interactions should stack/accumulate.\n        // To do that, clone the current interactions.\n        // The previous set will be restored upon completion.\n\n        var interactions = new Set(prevInteractions);\n        interactions.add(interaction);\n        exports.__interactionsRef.current = interactions;\n        var subscriber = exports.__subscriberRef.current;\n        var returnValue;\n\n        try {\n          if (subscriber !== null) {\n            subscriber.onInteractionTraced(interaction);\n          }\n        } finally {\n          try {\n            if (subscriber !== null) {\n              subscriber.onWorkStarted(interactions, threadID);\n            }\n          } finally {\n            try {\n              returnValue = callback();\n            } finally {\n              exports.__interactionsRef.current = prevInteractions;\n\n              try {\n                if (subscriber !== null) {\n                  subscriber.onWorkStopped(interactions, threadID);\n                }\n              } finally {\n                interaction.__count--; // If no async work was scheduled for this interaction,\n                // Notify subscribers that it's completed.\n\n                if (subscriber !== null && interaction.__count === 0) {\n                  subscriber.onInteractionScheduledWorkCompleted(interaction);\n                }\n              }\n            }\n          }\n        }\n\n        return returnValue;\n      }\n\n      function unstable_wrap(callback) {\n        var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;\n        var wrappedInteractions = exports.__interactionsRef.current;\n        var subscriber = exports.__subscriberRef.current;\n\n        if (subscriber !== null) {\n          subscriber.onWorkScheduled(wrappedInteractions, threadID);\n        } // Update the pending async work count for the current interactions.\n        // Update after calling subscribers in case of error.\n\n\n        wrappedInteractions.forEach(function (interaction) {\n          interaction.__count++;\n        });\n        var hasRun = false;\n\n        function wrapped() {\n          var prevInteractions = exports.__interactionsRef.current;\n          exports.__interactionsRef.current = wrappedInteractions;\n          subscriber = exports.__subscriberRef.current;\n\n          try {\n            var returnValue;\n\n            try {\n              if (subscriber !== null) {\n                subscriber.onWorkStarted(wrappedInteractions, threadID);\n              }\n            } finally {\n              try {\n                returnValue = callback.apply(undefined, arguments);\n              } finally {\n                exports.__interactionsRef.current = prevInteractions;\n\n                if (subscriber !== null) {\n                  subscriber.onWorkStopped(wrappedInteractions, threadID);\n                }\n              }\n            }\n\n            return returnValue;\n          } finally {\n            if (!hasRun) {\n              // We only expect a wrapped function to be executed once,\n              // But in the event that it's executed more than once–\n              // Only decrement the outstanding interaction counts once.\n              hasRun = true; // Update pending async counts for all wrapped interactions.\n              // If this was the last scheduled async work for any of them,\n              // Mark them as completed.\n\n              wrappedInteractions.forEach(function (interaction) {\n                interaction.__count--;\n\n                if (subscriber !== null && interaction.__count === 0) {\n                  subscriber.onInteractionScheduledWorkCompleted(interaction);\n                }\n              });\n            }\n          }\n        }\n\n        wrapped.cancel = function cancel() {\n          subscriber = exports.__subscriberRef.current;\n\n          try {\n            if (subscriber !== null) {\n              subscriber.onWorkCanceled(wrappedInteractions, threadID);\n            }\n          } finally {\n            // Update pending async counts for all wrapped interactions.\n            // If this was the last scheduled async work for any of them,\n            // Mark them as completed.\n            wrappedInteractions.forEach(function (interaction) {\n              interaction.__count--;\n\n              if (subscriber && interaction.__count === 0) {\n                subscriber.onInteractionScheduledWorkCompleted(interaction);\n              }\n            });\n          }\n        };\n\n        return wrapped;\n      }\n\n      var subscribers = null;\n      {\n        subscribers = new Set();\n      }\n\n      function unstable_subscribe(subscriber) {\n        {\n          subscribers.add(subscriber);\n\n          if (subscribers.size === 1) {\n            exports.__subscriberRef.current = {\n              onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,\n              onInteractionTraced: onInteractionTraced,\n              onWorkCanceled: onWorkCanceled,\n              onWorkScheduled: onWorkScheduled,\n              onWorkStarted: onWorkStarted,\n              onWorkStopped: onWorkStopped\n            };\n          }\n        }\n      }\n\n      function unstable_unsubscribe(subscriber) {\n        {\n          subscribers.delete(subscriber);\n\n          if (subscribers.size === 0) {\n            exports.__subscriberRef.current = null;\n          }\n        }\n      }\n\n      function onInteractionTraced(interaction) {\n        var didCatchError = false;\n        var caughtError = null;\n        subscribers.forEach(function (subscriber) {\n          try {\n            subscriber.onInteractionTraced(interaction);\n          } catch (error) {\n            if (!didCatchError) {\n              didCatchError = true;\n              caughtError = error;\n            }\n          }\n        });\n\n        if (didCatchError) {\n          throw caughtError;\n        }\n      }\n\n      function onInteractionScheduledWorkCompleted(interaction) {\n        var didCatchError = false;\n        var caughtError = null;\n        subscribers.forEach(function (subscriber) {\n          try {\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\n          } catch (error) {\n            if (!didCatchError) {\n              didCatchError = true;\n              caughtError = error;\n            }\n          }\n        });\n\n        if (didCatchError) {\n          throw caughtError;\n        }\n      }\n\n      function onWorkScheduled(interactions, threadID) {\n        var didCatchError = false;\n        var caughtError = null;\n        subscribers.forEach(function (subscriber) {\n          try {\n            subscriber.onWorkScheduled(interactions, threadID);\n          } catch (error) {\n            if (!didCatchError) {\n              didCatchError = true;\n              caughtError = error;\n            }\n          }\n        });\n\n        if (didCatchError) {\n          throw caughtError;\n        }\n      }\n\n      function onWorkStarted(interactions, threadID) {\n        var didCatchError = false;\n        var caughtError = null;\n        subscribers.forEach(function (subscriber) {\n          try {\n            subscriber.onWorkStarted(interactions, threadID);\n          } catch (error) {\n            if (!didCatchError) {\n              didCatchError = true;\n              caughtError = error;\n            }\n          }\n        });\n\n        if (didCatchError) {\n          throw caughtError;\n        }\n      }\n\n      function onWorkStopped(interactions, threadID) {\n        var didCatchError = false;\n        var caughtError = null;\n        subscribers.forEach(function (subscriber) {\n          try {\n            subscriber.onWorkStopped(interactions, threadID);\n          } catch (error) {\n            if (!didCatchError) {\n              didCatchError = true;\n              caughtError = error;\n            }\n          }\n        });\n\n        if (didCatchError) {\n          throw caughtError;\n        }\n      }\n\n      function onWorkCanceled(interactions, threadID) {\n        var didCatchError = false;\n        var caughtError = null;\n        subscribers.forEach(function (subscriber) {\n          try {\n            subscriber.onWorkCanceled(interactions, threadID);\n          } catch (error) {\n            if (!didCatchError) {\n              didCatchError = true;\n              caughtError = error;\n            }\n          }\n        });\n\n        if (didCatchError) {\n          throw caughtError;\n        }\n      }\n\n      exports.unstable_clear = unstable_clear;\n      exports.unstable_getCurrent = unstable_getCurrent;\n      exports.unstable_getThreadID = unstable_getThreadID;\n      exports.unstable_subscribe = unstable_subscribe;\n      exports.unstable_trace = unstable_trace;\n      exports.unstable_unsubscribe = unstable_unsubscribe;\n      exports.unstable_wrap = unstable_wrap;\n    })();\n  }\n})(schedulerTracing_development);","map":{"version":3,"sources":["/Users/dennis.zhang/Desktop/其它代码库/moa-flow/packages/flow/lib/node_modules/scheduler/cjs/scheduler-tracing.development.js"],"names":["__exports","schedulerTracing_development","default","exports","process","env","NODE_ENV","DEFAULT_THREAD_ID","interactionIDCounter","threadIDCounter","__interactionsRef","__subscriberRef","current","Set","unstable_clear","callback","prevInteractions","unstable_getCurrent","unstable_getThreadID","unstable_trace","name","timestamp","threadID","arguments","length","undefined","interaction","__count","id","interactions","add","subscriber","returnValue","onInteractionTraced","onWorkStarted","onWorkStopped","onInteractionScheduledWorkCompleted","unstable_wrap","wrappedInteractions","onWorkScheduled","forEach","hasRun","wrapped","apply","cancel","onWorkCanceled","subscribers","unstable_subscribe","size","unstable_unsubscribe","delete","didCatchError","caughtError","error"],"mappings":"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","sourcesContent":["import { __exports as schedulerTracing_development } from '../../../_virtual/scheduler-tracing.development.js';\nexport { __exports as default } from '../../../_virtual/scheduler-tracing.development.js';\n\n/** @license React v0.20.2\n * scheduler-tracing.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n(function (exports) {\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n\nvar DEFAULT_THREAD_ID = 0; // Counters used to generate unique IDs.\n\nvar interactionIDCounter = 0;\nvar threadIDCounter = 0; // Set of currently traced interactions.\n// Interactions \"stack\"–\n// Meaning that newly traced interactions are appended to the previously active set.\n// When an interaction goes out of scope, the previous set (if any) is restored.\n\nexports.__interactionsRef = null; // Listener(s) to notify when interactions begin and end.\n\nexports.__subscriberRef = null;\n\n{\n  exports.__interactionsRef = {\n    current: new Set()\n  };\n  exports.__subscriberRef = {\n    current: null\n  };\n}\nfunction unstable_clear(callback) {\n\n  var prevInteractions = exports.__interactionsRef.current;\n  exports.__interactionsRef.current = new Set();\n\n  try {\n    return callback();\n  } finally {\n    exports.__interactionsRef.current = prevInteractions;\n  }\n}\nfunction unstable_getCurrent() {\n  {\n    return exports.__interactionsRef.current;\n  }\n}\nfunction unstable_getThreadID() {\n  return ++threadIDCounter;\n}\nfunction unstable_trace(name, timestamp, callback) {\n  var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;\n\n  var interaction = {\n    __count: 1,\n    id: interactionIDCounter++,\n    name: name,\n    timestamp: timestamp\n  };\n  var prevInteractions = exports.__interactionsRef.current; // Traced interactions should stack/accumulate.\n  // To do that, clone the current interactions.\n  // The previous set will be restored upon completion.\n\n  var interactions = new Set(prevInteractions);\n  interactions.add(interaction);\n  exports.__interactionsRef.current = interactions;\n  var subscriber = exports.__subscriberRef.current;\n  var returnValue;\n\n  try {\n    if (subscriber !== null) {\n      subscriber.onInteractionTraced(interaction);\n    }\n  } finally {\n    try {\n      if (subscriber !== null) {\n        subscriber.onWorkStarted(interactions, threadID);\n      }\n    } finally {\n      try {\n        returnValue = callback();\n      } finally {\n        exports.__interactionsRef.current = prevInteractions;\n\n        try {\n          if (subscriber !== null) {\n            subscriber.onWorkStopped(interactions, threadID);\n          }\n        } finally {\n          interaction.__count--; // If no async work was scheduled for this interaction,\n          // Notify subscribers that it's completed.\n\n          if (subscriber !== null && interaction.__count === 0) {\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\n          }\n        }\n      }\n    }\n  }\n\n  return returnValue;\n}\nfunction unstable_wrap(callback) {\n  var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;\n\n  var wrappedInteractions = exports.__interactionsRef.current;\n  var subscriber = exports.__subscriberRef.current;\n\n  if (subscriber !== null) {\n    subscriber.onWorkScheduled(wrappedInteractions, threadID);\n  } // Update the pending async work count for the current interactions.\n  // Update after calling subscribers in case of error.\n\n\n  wrappedInteractions.forEach(function (interaction) {\n    interaction.__count++;\n  });\n  var hasRun = false;\n\n  function wrapped() {\n    var prevInteractions = exports.__interactionsRef.current;\n    exports.__interactionsRef.current = wrappedInteractions;\n    subscriber = exports.__subscriberRef.current;\n\n    try {\n      var returnValue;\n\n      try {\n        if (subscriber !== null) {\n          subscriber.onWorkStarted(wrappedInteractions, threadID);\n        }\n      } finally {\n        try {\n          returnValue = callback.apply(undefined, arguments);\n        } finally {\n          exports.__interactionsRef.current = prevInteractions;\n\n          if (subscriber !== null) {\n            subscriber.onWorkStopped(wrappedInteractions, threadID);\n          }\n        }\n      }\n\n      return returnValue;\n    } finally {\n      if (!hasRun) {\n        // We only expect a wrapped function to be executed once,\n        // But in the event that it's executed more than once–\n        // Only decrement the outstanding interaction counts once.\n        hasRun = true; // Update pending async counts for all wrapped interactions.\n        // If this was the last scheduled async work for any of them,\n        // Mark them as completed.\n\n        wrappedInteractions.forEach(function (interaction) {\n          interaction.__count--;\n\n          if (subscriber !== null && interaction.__count === 0) {\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\n          }\n        });\n      }\n    }\n  }\n\n  wrapped.cancel = function cancel() {\n    subscriber = exports.__subscriberRef.current;\n\n    try {\n      if (subscriber !== null) {\n        subscriber.onWorkCanceled(wrappedInteractions, threadID);\n      }\n    } finally {\n      // Update pending async counts for all wrapped interactions.\n      // If this was the last scheduled async work for any of them,\n      // Mark them as completed.\n      wrappedInteractions.forEach(function (interaction) {\n        interaction.__count--;\n\n        if (subscriber && interaction.__count === 0) {\n          subscriber.onInteractionScheduledWorkCompleted(interaction);\n        }\n      });\n    }\n  };\n\n  return wrapped;\n}\n\nvar subscribers = null;\n\n{\n  subscribers = new Set();\n}\n\nfunction unstable_subscribe(subscriber) {\n  {\n    subscribers.add(subscriber);\n\n    if (subscribers.size === 1) {\n      exports.__subscriberRef.current = {\n        onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,\n        onInteractionTraced: onInteractionTraced,\n        onWorkCanceled: onWorkCanceled,\n        onWorkScheduled: onWorkScheduled,\n        onWorkStarted: onWorkStarted,\n        onWorkStopped: onWorkStopped\n      };\n    }\n  }\n}\nfunction unstable_unsubscribe(subscriber) {\n  {\n    subscribers.delete(subscriber);\n\n    if (subscribers.size === 0) {\n      exports.__subscriberRef.current = null;\n    }\n  }\n}\n\nfunction onInteractionTraced(interaction) {\n  var didCatchError = false;\n  var caughtError = null;\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onInteractionTraced(interaction);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onInteractionScheduledWorkCompleted(interaction) {\n  var didCatchError = false;\n  var caughtError = null;\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onInteractionScheduledWorkCompleted(interaction);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkScheduled(interactions, threadID) {\n  var didCatchError = false;\n  var caughtError = null;\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onWorkScheduled(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkStarted(interactions, threadID) {\n  var didCatchError = false;\n  var caughtError = null;\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onWorkStarted(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkStopped(interactions, threadID) {\n  var didCatchError = false;\n  var caughtError = null;\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onWorkStopped(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkCanceled(interactions, threadID) {\n  var didCatchError = false;\n  var caughtError = null;\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onWorkCanceled(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nexports.unstable_clear = unstable_clear;\nexports.unstable_getCurrent = unstable_getCurrent;\nexports.unstable_getThreadID = unstable_getThreadID;\nexports.unstable_subscribe = unstable_subscribe;\nexports.unstable_trace = unstable_trace;\nexports.unstable_unsubscribe = unstable_unsubscribe;\nexports.unstable_wrap = unstable_wrap;\n  })();\n}\n}(schedulerTracing_development));\n"]},"metadata":{},"sourceType":"module"}