{"ast":null,"code":"function decasteljau(points, t) {\n  var left = [];\n  var right = [];\n\n  function recurse(points, t) {\n    if (points.length === 1) {\n      left.push(points[0]);\n      right.push(points[0]);\n    } else {\n      var middlePoints = [];\n\n      for (var i = 0; i < points.length - 1; i++) {\n        if (i === 0) {\n          left.push(points[0]);\n        }\n\n        if (i === points.length - 2) {\n          right.push(points[i + 1]);\n        }\n\n        middlePoints[i] = [(1 - t) * points[i][0] + t * points[i + 1][0], (1 - t) * points[i][1] + t * points[i + 1][1]];\n      }\n\n      recurse(middlePoints, t);\n    }\n  }\n\n  if (points.length) {\n    recurse(points, t);\n  }\n\n  return {\n    left: left,\n    right: right.reverse()\n  };\n}\n\nfunction splitCurve(start, end, count) {\n  var points = [[start[1], start[2]]];\n  count = count || 2;\n  var segments = [];\n\n  if (end[0] === 'A') {\n    points.push(end[6]);\n    points.push(end[7]);\n  } else if (end[0] === 'C') {\n    points.push([end[1], end[2]]);\n    points.push([end[3], end[4]]);\n    points.push([end[5], end[6]]);\n  } else if (end[0] === 'S' || end[0] === 'Q') {\n    points.push([end[1], end[2]]);\n    points.push([end[3], end[4]]);\n  } else {\n    points.push([end[1], end[2]]);\n  }\n\n  var leftSegments = points;\n  var t = 1 / count;\n\n  for (var i = 0; i < count - 1; i++) {\n    var rt = t / (1 - t * i);\n    var split = decasteljau(leftSegments, rt);\n    segments.push(split.left);\n    leftSegments = split.right;\n  }\n\n  segments.push(leftSegments);\n  var result = segments.map(function (segment) {\n    var cmd = [];\n\n    if (segment.length === 4) {\n      cmd.push('C');\n      cmd = cmd.concat(segment[2]);\n    }\n\n    if (segment.length >= 3) {\n      if (segment.length === 3) {\n        cmd.push('Q');\n      }\n\n      cmd = cmd.concat(segment[1]);\n    }\n\n    if (segment.length === 2) {\n      cmd.push('L');\n    }\n\n    cmd = cmd.concat(segment[segment.length - 1]);\n    return cmd;\n  });\n  return result;\n}\n\nfunction splitSegment(start, end, count) {\n  if (count === 1) {\n    return [[].concat(start)];\n  }\n\n  var segments = [];\n\n  if (end[0] === 'L' || end[0] === 'C' || end[0] === 'Q') {\n    segments = segments.concat(splitCurve(start, end, count));\n  } else {\n    var temp = [].concat(start);\n\n    if (temp[0] === 'M') {\n      temp[0] = 'L';\n    }\n\n    for (var i = 0; i <= count - 1; i++) {\n      segments.push(temp);\n    }\n  }\n\n  return segments;\n}\n\nexport default function fillPath(source, target) {\n  if (source.length === 1) {\n    return source;\n  }\n\n  var sourceLen = source.length - 1;\n  var targetLen = target.length - 1;\n  var ratio = sourceLen / targetLen;\n  var segmentsToFill = [];\n\n  if (source.length === 1 && source[0][0] === 'M') {\n    for (var i = 0; i < targetLen - sourceLen; i++) {\n      source.push(source[0]);\n    }\n\n    return source;\n  }\n\n  for (var i = 0; i < targetLen; i++) {\n    var index = Math.floor(ratio * i);\n    segmentsToFill[index] = (segmentsToFill[index] || 0) + 1;\n  }\n\n  var filled = segmentsToFill.reduce(function (filled, count, i) {\n    if (i === sourceLen) {\n      return filled.concat(source[sourceLen]);\n    }\n\n    return filled.concat(splitSegment(source[i], source[i + 1], count));\n  }, []);\n  filled.unshift(source[0]);\n\n  if (target[targetLen] === 'Z' || target[targetLen] === 'z') {\n    filled.push('Z');\n  }\n\n  return filled;\n}","map":{"version":3,"mappings":"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","names":["decasteljau","points","t","left","right","recurse","length","push","middlePoints","i","reverse","splitCurve","start","end","count","segments","leftSegments","rt","split","result","map","segment","cmd","concat","splitSegment","temp","fillPath","source","target","sourceLen","targetLen","ratio","segmentsToFill","index","Math","floor","filled","reduce","unshift"],"sources":["/Users/dennis.zhang/Desktop/其它代码库/moa-flow/node_modules/@antv/path-util/src/fill-path.ts"],"sourcesContent":["function decasteljau(points, t) {\n  const left = [];\n  const right = [];\n\n  function recurse(points, t) {\n    if (points.length === 1) {\n      left.push(points[0]);\n      right.push(points[0]);\n    } else {\n      const middlePoints = [];\n      for (let i = 0; i < points.length - 1; i++) {\n        if (i === 0) {\n          left.push(points[0]);\n        }\n        if (i === points.length - 2) {\n          right.push(points[i + 1]);\n        }\n        middlePoints[i] = [ (1 - t) * points[i][0] + t * points[i + 1][0], (1 - t) * points[i][1] + t * points[i + 1][1] ];\n      }\n      recurse(middlePoints, t);\n    }\n  }\n  if (points.length) {\n    recurse(points, t);\n  }\n  return { left, right: right.reverse() };\n}\n\nfunction splitCurve(start, end, count) {\n  const points = [ [ start[1], start[2] ] ];\n  count = count || 2;\n  const segments = [];\n  if (end[0] === 'A') {\n    points.push(end[6]);\n    points.push(end[7]);\n  } else if (end[0] === 'C') {\n    points.push([ end[1], end[2] ]);\n    points.push([ end[3], end[4] ]);\n    points.push([ end[5], end[6] ]);\n  } else if (end[0] === 'S' || end[0] === 'Q') {\n    points.push([ end[1], end[2] ]);\n    points.push([ end[3], end[4] ]);\n  } else {\n    points.push([ end[1], end[2] ]);\n  }\n\n  let leftSegments = points;\n  const t = 1 / count;\n\n  for (let i = 0; i < count - 1; i++) {\n    const rt = t / (1 - t * i);\n    const split = decasteljau(leftSegments, rt);\n    segments.push(split.left);\n    leftSegments = split.right;\n  }\n  segments.push(leftSegments);\n  const result = segments.map((segment) => {\n    let cmd = [];\n    if (segment.length === 4) {\n      cmd.push('C');\n      cmd = cmd.concat(segment[2]);\n    }\n    if (segment.length >= 3) {\n      if (segment.length === 3) {\n        cmd.push('Q');\n      }\n      cmd = cmd.concat(segment[1]);\n    }\n    if (segment.length === 2) {\n      cmd.push('L');\n    }\n    cmd = cmd.concat(segment[segment.length - 1]);\n    return cmd;\n  });\n  return result;\n}\n\nfunction splitSegment(start, end, count) {\n  if (count === 1) {\n    return [ [].concat(start) ];\n  }\n  let segments = [];\n  if (end[0] === 'L' || end[0] === 'C' || end[0] === 'Q') {\n    segments = segments.concat(splitCurve(start, end, count));\n  } else {\n    const temp = [].concat(start);\n    if (temp[0] === 'M') {\n      temp[0] = 'L';\n    }\n    for (let i = 0; i <= count - 1; i++) {\n      segments.push(temp);\n    }\n  }\n  return segments;\n}\n\nexport default function fillPath(source, target) {\n  if (source.length === 1) {\n    return source;\n  }\n  const sourceLen = source.length - 1;\n  const targetLen = target.length - 1;\n  const ratio = sourceLen / targetLen;\n  const segmentsToFill = [];\n  if (source.length === 1 && source[0][0] === 'M') {\n    for (let i = 0; i < targetLen - sourceLen; i++) {\n      source.push(source[0]);\n    }\n    return source;\n  }\n  for (let i = 0; i < targetLen; i++) {\n    const index = Math.floor(ratio * i);\n    segmentsToFill[index] = (segmentsToFill[index] || 0) + 1;\n  }\n  const filled = segmentsToFill.reduce((filled, count, i) => {\n    if (i === sourceLen) {\n      return filled.concat(source[sourceLen]);\n    }\n    return filled.concat(splitSegment(source[i], source[i + 1], count));\n  },                                   []);\n  filled.unshift(source[0]);\n  if (target[targetLen] === 'Z' || target[targetLen] === 'z') {\n    filled.push('Z');\n  }\n  return filled;\n}\n"]},"metadata":{},"sourceType":"module"}