{"ast":null,"code":"import parsePathString from './parse-path-string';\nvar REGEX_MD = /[a-z]/;\n\nfunction toSymmetry(p, c) {\n  return [c[0] + (c[0] - p[0]), c[1] + (c[1] - p[1])];\n}\n\nexport default function pathToAbsolute(pathString) {\n  var pathArray = parsePathString(pathString);\n\n  if (!pathArray || !pathArray.length) {\n    return [['M', 0, 0]];\n  }\n\n  var needProcess = false; // 如果存在小写的命令或者 V,H,T,S 则需要处理\n\n  for (var i = 0; i < pathArray.length; i++) {\n    var cmd = pathArray[i][0]; // 如果存在相对位置的命令，则中断返回\n\n    if (REGEX_MD.test(cmd) || ['V', 'H', 'T', 'S'].indexOf(cmd) >= 0) {\n      needProcess = true;\n      break;\n    }\n  } // 如果不存在相对命令，则直接返回\n  // 如果在业务上都写绝对路径，这种方式最快，仅做了一次检测\n\n\n  if (!needProcess) {\n    return pathArray;\n  }\n\n  var res = [];\n  var x = 0;\n  var y = 0;\n  var mx = 0;\n  var my = 0;\n  var start = 0;\n  var pa0;\n  var dots;\n  var first = pathArray[0];\n\n  if (first[0] === 'M' || first[0] === 'm') {\n    x = +first[1];\n    y = +first[2];\n    mx = x;\n    my = y;\n    start++;\n    res[0] = ['M', x, y];\n  }\n\n  for (var i = start, ii = pathArray.length; i < ii; i++) {\n    var pa = pathArray[i];\n    var preParams = res[i - 1]; // 取前一个已经处理后的节点，否则会出现问题\n\n    var r = [];\n    var cmd = pa[0];\n    var upCmd = cmd.toUpperCase();\n\n    if (cmd !== upCmd) {\n      r[0] = upCmd;\n\n      switch (upCmd) {\n        case 'A':\n          r[1] = pa[1];\n          r[2] = pa[2];\n          r[3] = pa[3];\n          r[4] = pa[4];\n          r[5] = pa[5];\n          r[6] = +pa[6] + x;\n          r[7] = +pa[7] + y;\n          break;\n\n        case 'V':\n          r[1] = +pa[1] + y;\n          break;\n\n        case 'H':\n          r[1] = +pa[1] + x;\n          break;\n\n        case 'M':\n          mx = +pa[1] + x;\n          my = +pa[2] + y;\n          r[1] = mx;\n          r[2] = my;\n          break;\n        // for lint\n\n        default:\n          for (var j = 1, jj = pa.length; j < jj; j++) {\n            r[j] = +pa[j] + (j % 2 ? x : y);\n          }\n\n      }\n    } else {\n      // 如果本来已经大写，则不处理\n      r = pathArray[i];\n    } // 需要在外面统一做，同时处理 V,H,S,T 等特殊指令\n\n\n    switch (upCmd) {\n      case 'Z':\n        x = +mx;\n        y = +my;\n        break;\n\n      case 'H':\n        x = r[1];\n        r = ['L', x, y];\n        break;\n\n      case 'V':\n        y = r[1];\n        r = ['L', x, y];\n        break;\n\n      case 'T':\n        x = r[1];\n        y = r[2]; // 以 x, y 为中心的，上一个控制点的对称点\n        // 需要假设上一个节点的命令为 Q\n\n        var symetricT = toSymmetry([preParams[1], preParams[2]], [preParams[3], preParams[4]]);\n        r = ['Q', symetricT[0], symetricT[1], x, y];\n        break;\n\n      case 'S':\n        x = r[r.length - 2];\n        y = r[r.length - 1]; // 以 x,y 为中心，取上一个控制点，\n        // 需要假设上一个线段为 C 或者 S\n\n        var length_1 = preParams.length;\n        var symetricS = toSymmetry([preParams[length_1 - 4], preParams[length_1 - 3]], [preParams[length_1 - 2], preParams[length_1 - 1]]);\n        r = ['C', symetricS[0], symetricS[1], r[1], r[2], x, y];\n        break;\n\n      case 'M':\n        mx = r[r.length - 2];\n        my = r[r.length - 1];\n        break;\n      // for lint\n\n      default:\n        x = r[r.length - 2];\n        y = r[r.length - 1];\n    }\n\n    res.push(r);\n  }\n\n  return res;\n}","map":{"version":3,"mappings":"AAAA,OAAOA,eAAP,MAA4B,qBAA5B;AACA,IAAMC,QAAQ,GAAG,OAAjB;;AAEA,SAASC,UAAT,CAAoBC,CAApB,EAAuBC,CAAvB,EAAwB;AACtB,SAAO,CACLA,CAAC,CAAC,CAAD,CAAD,IAAQA,CAAC,CAAC,CAAD,CAAD,GAAOD,CAAC,CAAC,CAAD,CAAhB,CADK,EAELC,CAAC,CAAC,CAAD,CAAD,IAAQA,CAAC,CAAC,CAAD,CAAD,GAAOD,CAAC,CAAC,CAAD,CAAhB,CAFK,CAAP;AAID;;AAED,eAAc,SAAUE,cAAV,CAAyBC,UAAzB,EAA2C;AACvD,MAAMC,SAAS,GAAGP,eAAe,CAACM,UAAD,CAAjC;;AAEA,MAAI,CAACC,SAAD,IAAc,CAACA,SAAS,CAACC,MAA7B,EAAqC;AACnC,WAAO,CACL,CAAE,GAAF,EAAO,CAAP,EAAU,CAAV,CADK,CAAP;AAGD;;AACD,MAAIC,WAAW,GAAG,KAAlB,CARuD,CAQ9B;;AACzB,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,SAAS,CAACC,MAA9B,EAAsCE,CAAC,EAAvC,EAA2C;AACzC,QAAMC,GAAG,GAAGJ,SAAS,CAACG,CAAD,CAAT,CAAa,CAAb,CAAZ,CADyC,CAEzC;;AACA,QAAIT,QAAQ,CAACW,IAAT,CAAcD,GAAd,KAAsB,CAAE,GAAF,EAAO,GAAP,EAAY,GAAZ,EAAiB,GAAjB,EAAuBE,OAAvB,CAA+BF,GAA/B,KAAuC,CAAjE,EAAoE;AAClEF,iBAAW,GAAG,IAAd;AACA;AACD;AACF,GAhBsD,CAiBvD;AACA;;;AACA,MAAI,CAACA,WAAL,EAAkB;AAChB,WAAOF,SAAP;AACD;;AAED,MAAMO,GAAG,GAAG,EAAZ;AACA,MAAIC,CAAC,GAAG,CAAR;AACA,MAAIC,CAAC,GAAG,CAAR;AACA,MAAIC,EAAE,GAAG,CAAT;AACA,MAAIC,EAAE,GAAG,CAAT;AACA,MAAIC,KAAK,GAAG,CAAZ;AACA,MAAIC,GAAJ;AACA,MAAIC,IAAJ;AACA,MAAMC,KAAK,GAAGf,SAAS,CAAC,CAAD,CAAvB;;AACA,MAAIe,KAAK,CAAC,CAAD,CAAL,KAAa,GAAb,IAAoBA,KAAK,CAAC,CAAD,CAAL,KAAa,GAArC,EAA0C;AACxCP,KAAC,GAAG,CAACO,KAAK,CAAC,CAAD,CAAV;AACAN,KAAC,GAAG,CAACM,KAAK,CAAC,CAAD,CAAV;AACAL,MAAE,GAAGF,CAAL;AACAG,MAAE,GAAGF,CAAL;AACAG,SAAK;AACLL,OAAG,CAAC,CAAD,CAAH,GAAS,CAAE,GAAF,EAAOC,CAAP,EAAUC,CAAV,CAAT;AACD;;AAED,OAAK,IAAIN,CAAC,GAAGS,KAAR,EAAeI,EAAE,GAAGhB,SAAS,CAACC,MAAnC,EAA2CE,CAAC,GAAGa,EAA/C,EAAmDb,CAAC,EAApD,EAAwD;AACtD,QAAMc,EAAE,GAAGjB,SAAS,CAACG,CAAD,CAApB;AACA,QAAMe,SAAS,GAAGX,GAAG,CAACJ,CAAC,GAAG,CAAL,CAArB,CAFsD,CAExB;;AAC9B,QAAIgB,CAAC,GAAG,EAAR;AACA,QAAMf,GAAG,GAAGa,EAAE,CAAC,CAAD,CAAd;AACA,QAAMG,KAAK,GAAGhB,GAAG,CAACiB,WAAJ,EAAd;;AACA,QAAIjB,GAAG,KAAKgB,KAAZ,EAAmB;AACjBD,OAAC,CAAC,CAAD,CAAD,GAAOC,KAAP;;AACA,cAAQA,KAAR;AACE,aAAK,GAAL;AACED,WAAC,CAAC,CAAD,CAAD,GAAOF,EAAE,CAAC,CAAD,CAAT;AACAE,WAAC,CAAC,CAAD,CAAD,GAAOF,EAAE,CAAC,CAAD,CAAT;AACAE,WAAC,CAAC,CAAD,CAAD,GAAOF,EAAE,CAAC,CAAD,CAAT;AACAE,WAAC,CAAC,CAAD,CAAD,GAAOF,EAAE,CAAC,CAAD,CAAT;AACAE,WAAC,CAAC,CAAD,CAAD,GAAOF,EAAE,CAAC,CAAD,CAAT;AACAE,WAAC,CAAC,CAAD,CAAD,GAAO,CAACF,EAAE,CAAC,CAAD,CAAH,GAAST,CAAhB;AACAW,WAAC,CAAC,CAAD,CAAD,GAAO,CAACF,EAAE,CAAC,CAAD,CAAH,GAASR,CAAhB;AACA;;AACF,aAAK,GAAL;AACEU,WAAC,CAAC,CAAD,CAAD,GAAO,CAACF,EAAE,CAAC,CAAD,CAAH,GAASR,CAAhB;AACA;;AACF,aAAK,GAAL;AACEU,WAAC,CAAC,CAAD,CAAD,GAAO,CAACF,EAAE,CAAC,CAAD,CAAH,GAAST,CAAhB;AACA;;AACF,aAAK,GAAL;AACEE,YAAE,GAAG,CAACO,EAAE,CAAC,CAAD,CAAH,GAAST,CAAd;AACAG,YAAE,GAAG,CAACM,EAAE,CAAC,CAAD,CAAH,GAASR,CAAd;AACAU,WAAC,CAAC,CAAD,CAAD,GAAOT,EAAP;AACAS,WAAC,CAAC,CAAD,CAAD,GAAOR,EAAP;AACA;AAAO;;AACT;AACE,eAAK,IAAIW,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGN,EAAE,CAAChB,MAAxB,EAAgCqB,CAAC,GAAGC,EAApC,EAAwCD,CAAC,EAAzC,EAA6C;AAC3CH,aAAC,CAACG,CAAD,CAAD,GAAO,CAACL,EAAE,CAACK,CAAD,CAAH,IAAWA,CAAC,GAAG,CAAL,GAAUd,CAAV,GAAcC,CAAxB,CAAP;AACD;;AAzBL;AA2BD,KA7BD,MA6BO;AAAE;AACPU,OAAC,GAAGnB,SAAS,CAACG,CAAD,CAAb;AACD,KArCqD,CAsCtD;;;AACA,YAAQiB,KAAR;AACE,WAAK,GAAL;AACEZ,SAAC,GAAG,CAACE,EAAL;AACAD,SAAC,GAAG,CAACE,EAAL;AACA;;AACF,WAAK,GAAL;AACEH,SAAC,GAAGW,CAAC,CAAC,CAAD,CAAL;AACAA,SAAC,GAAG,CAAE,GAAF,EAAOX,CAAP,EAAUC,CAAV,CAAJ;AACA;;AACF,WAAK,GAAL;AACEA,SAAC,GAAGU,CAAC,CAAC,CAAD,CAAL;AACAA,SAAC,GAAG,CAAE,GAAF,EAAOX,CAAP,EAAUC,CAAV,CAAJ;AACA;;AACF,WAAK,GAAL;AACED,SAAC,GAAGW,CAAC,CAAC,CAAD,CAAL;AACAV,SAAC,GAAGU,CAAC,CAAC,CAAD,CAAL,CAFF,CAGE;AACA;;AACA,YAAMK,SAAS,GAAG7B,UAAU,CAAC,CAAEuB,SAAS,CAAC,CAAD,CAAX,EAAgBA,SAAS,CAAC,CAAD,CAAzB,CAAD,EAAiC,CAAEA,SAAS,CAAC,CAAD,CAAX,EAAgBA,SAAS,CAAC,CAAD,CAAzB,CAAjC,CAA5B;AACAC,SAAC,GAAG,CAAE,GAAF,EAAOK,SAAS,CAAC,CAAD,CAAhB,EAAqBA,SAAS,CAAC,CAAD,CAA9B,EAAmChB,CAAnC,EAAsCC,CAAtC,CAAJ;AACA;;AACF,WAAK,GAAL;AACED,SAAC,GAAGW,CAAC,CAACA,CAAC,CAAClB,MAAF,GAAW,CAAZ,CAAL;AACAQ,SAAC,GAAGU,CAAC,CAACA,CAAC,CAAClB,MAAF,GAAW,CAAZ,CAAL,CAFF,CAGE;AACA;;AACA,YAAMwB,QAAM,GAAGP,SAAS,CAACjB,MAAzB;AACA,YAAMyB,SAAS,GAAG/B,UAAU,CAC1B,CAAEuB,SAAS,CAACO,QAAM,GAAG,CAAV,CAAX,EAAyBP,SAAS,CAACO,QAAM,GAAG,CAAV,CAAlC,CAD0B,EAE1B,CAAEP,SAAS,CAACO,QAAM,GAAG,CAAV,CAAX,EAAyBP,SAAS,CAACO,QAAM,GAAG,CAAV,CAAlC,CAF0B,CAA5B;AAGAN,SAAC,GAAG,CAAE,GAAF,EAAOO,SAAS,CAAC,CAAD,CAAhB,EAAqBA,SAAS,CAAC,CAAD,CAA9B,EAAmCP,CAAC,CAAC,CAAD,CAApC,EAAyCA,CAAC,CAAC,CAAD,CAA1C,EAA+CX,CAA/C,EAAkDC,CAAlD,CAAJ;AACA;;AACF,WAAK,GAAL;AACEC,UAAE,GAAGS,CAAC,CAACA,CAAC,CAAClB,MAAF,GAAW,CAAZ,CAAN;AACAU,UAAE,GAAGQ,CAAC,CAACA,CAAC,CAAClB,MAAF,GAAW,CAAZ,CAAN;AACA;AAAO;;AACT;AACEO,SAAC,GAAGW,CAAC,CAACA,CAAC,CAAClB,MAAF,GAAW,CAAZ,CAAL;AACAQ,SAAC,GAAGU,CAAC,CAACA,CAAC,CAAClB,MAAF,GAAW,CAAZ,CAAL;AAtCJ;;AAwCAM,OAAG,CAACoB,IAAJ,CAASR,CAAT;AACD;;AAED,SAAOZ,GAAP;AACD","names":["parsePathString","REGEX_MD","toSymmetry","p","c","pathToAbsolute","pathString","pathArray","length","needProcess","i","cmd","test","indexOf","res","x","y","mx","my","start","pa0","dots","first","ii","pa","preParams","r","upCmd","toUpperCase","j","jj","symetricT","length_1","symetricS","push"],"sources":["/Users/dennis.zhang/Desktop/其它代码库/moa-flow/node_modules/@antv/path-util/src/path-2-absolute.ts"],"sourcesContent":["import parsePathString from './parse-path-string';\nconst REGEX_MD = /[a-z]/;\n\nfunction toSymmetry(p, c) { // 点对称\n  return [\n    c[0] + (c[0] - p[0]),\n    c[1] + (c[1] - p[1]),\n  ];\n}\n\nexport default function pathToAbsolute(pathString: string) {\n  const pathArray = parsePathString(pathString);\n\n  if (!pathArray || !pathArray.length) {\n    return [\n      [ 'M', 0, 0 ],\n    ];\n  }\n  let needProcess = false; // 如果存在小写的命令或者 V,H,T,S 则需要处理\n  for (let i = 0; i < pathArray.length; i++) {\n    const cmd = pathArray[i][0];\n    // 如果存在相对位置的命令，则中断返回\n    if (REGEX_MD.test(cmd) || [ 'V', 'H', 'T', 'S' ].indexOf(cmd) >= 0) {\n      needProcess = true;\n      break;\n    }\n  }\n  // 如果不存在相对命令，则直接返回\n  // 如果在业务上都写绝对路径，这种方式最快，仅做了一次检测\n  if (!needProcess) {\n    return pathArray;\n  }\n\n  const res = [];\n  let x = 0;\n  let y = 0;\n  let mx = 0;\n  let my = 0;\n  let start = 0;\n  let pa0;\n  let dots;\n  const first = pathArray[0];\n  if (first[0] === 'M' || first[0] === 'm') {\n    x = +first[1];\n    y = +first[2];\n    mx = x;\n    my = y;\n    start++;\n    res[0] = [ 'M', x, y ];\n  }\n\n  for (let i = start, ii = pathArray.length; i < ii; i++) {\n    const pa = pathArray[i];\n    const preParams = res[i - 1]; // 取前一个已经处理后的节点，否则会出现问题\n    let r = [];\n    const cmd = pa[0];\n    const upCmd = cmd.toUpperCase();\n    if (cmd !== upCmd) {\n      r[0] = upCmd;\n      switch (upCmd) {\n        case 'A':\n          r[1] = pa[1];\n          r[2] = pa[2];\n          r[3] = pa[3];\n          r[4] = pa[4];\n          r[5] = pa[5];\n          r[6] = +pa[6] + x;\n          r[7] = +pa[7] + y;\n          break;\n        case 'V':\n          r[1] = +pa[1] + y;\n          break;\n        case 'H':\n          r[1] = +pa[1] + x;\n          break;\n        case 'M':\n          mx = +pa[1] + x;\n          my = +pa[2] + y;\n          r[1] = mx;\n          r[2] = my;\n          break; // for lint\n        default:\n          for (let j = 1, jj = pa.length; j < jj; j++) {\n            r[j] = +pa[j] + ((j % 2) ? x : y);\n          }\n      }\n    } else { // 如果本来已经大写，则不处理\n      r = pathArray[i];\n    }\n    // 需要在外面统一做，同时处理 V,H,S,T 等特殊指令\n    switch (upCmd) {\n      case 'Z':\n        x = +mx;\n        y = +my;\n        break;\n      case 'H':\n        x = r[1];\n        r = [ 'L', x, y ];\n        break;\n      case 'V':\n        y = r[1];\n        r = [ 'L', x, y ];\n        break;\n      case 'T':\n        x = r[1];\n        y = r[2];\n        // 以 x, y 为中心的，上一个控制点的对称点\n        // 需要假设上一个节点的命令为 Q\n        const symetricT = toSymmetry([ preParams[1], preParams[2] ], [ preParams[3], preParams[4] ]);\n        r = [ 'Q', symetricT[0], symetricT[1], x, y ];\n        break;\n      case 'S':\n        x = r[r.length - 2];\n        y = r[r.length - 1];\n        // 以 x,y 为中心，取上一个控制点，\n        // 需要假设上一个线段为 C 或者 S\n        const length = preParams.length;\n        const symetricS = toSymmetry(\n          [ preParams[length - 4], preParams[length - 3] ],\n          [ preParams[length - 2], preParams[length - 1] ]);\n        r = [ 'C', symetricS[0], symetricS[1], r[1], r[2], x, y ];\n        break;\n      case 'M':\n        mx = r[r.length - 2];\n        my = r[r.length - 1];\n        break; // for lint\n      default:\n        x = r[r.length - 2];\n        y = r[r.length - 1];\n    }\n    res.push(r);\n  }\n\n  return res;\n}\n"]},"metadata":{},"sourceType":"module"}