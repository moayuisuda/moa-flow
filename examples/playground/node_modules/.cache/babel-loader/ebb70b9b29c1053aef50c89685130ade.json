{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst util = require(\"util\");\n\nconst deprecateContext = util.deprecate(() => {}, \"Hook.context is deprecated and will be removed\");\n\nconst CALL_DELEGATE = function () {\n  this.call = this._createCall(\"sync\");\n  return this.call(...arguments);\n};\n\nconst CALL_ASYNC_DELEGATE = function () {\n  this.callAsync = this._createCall(\"async\");\n  return this.callAsync(...arguments);\n};\n\nconst PROMISE_DELEGATE = function () {\n  this.promise = this._createCall(\"promise\");\n  return this.promise(...arguments);\n};\n\nclass Hook {\n  constructor() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    this._args = args;\n    this.name = name;\n    this.taps = [];\n    this.interceptors = [];\n    this._call = CALL_DELEGATE;\n    this.call = CALL_DELEGATE;\n    this._callAsync = CALL_ASYNC_DELEGATE;\n    this.callAsync = CALL_ASYNC_DELEGATE;\n    this._promise = PROMISE_DELEGATE;\n    this.promise = PROMISE_DELEGATE;\n    this._x = undefined;\n    this.compile = this.compile;\n    this.tap = this.tap;\n    this.tapAsync = this.tapAsync;\n    this.tapPromise = this.tapPromise;\n  }\n\n  compile(options) {\n    throw new Error(\"Abstract: should be overridden\");\n  }\n\n  _createCall(type) {\n    return this.compile({\n      taps: this.taps,\n      interceptors: this.interceptors,\n      args: this._args,\n      type: type\n    });\n  }\n\n  _tap(type, options, fn) {\n    if (typeof options === \"string\") {\n      options = {\n        name: options.trim()\n      };\n    } else if (typeof options !== \"object\" || options === null) {\n      throw new Error(\"Invalid tap options\");\n    }\n\n    if (typeof options.name !== \"string\" || options.name === \"\") {\n      throw new Error(\"Missing name for tap\");\n    }\n\n    if (typeof options.context !== \"undefined\") {\n      deprecateContext();\n    }\n\n    options = Object.assign({\n      type,\n      fn\n    }, options);\n    options = this._runRegisterInterceptors(options);\n\n    this._insert(options);\n  }\n\n  tap(options, fn) {\n    this._tap(\"sync\", options, fn);\n  }\n\n  tapAsync(options, fn) {\n    this._tap(\"async\", options, fn);\n  }\n\n  tapPromise(options, fn) {\n    this._tap(\"promise\", options, fn);\n  }\n\n  _runRegisterInterceptors(options) {\n    for (const interceptor of this.interceptors) {\n      if (interceptor.register) {\n        const newOptions = interceptor.register(options);\n\n        if (newOptions !== undefined) {\n          options = newOptions;\n        }\n      }\n    }\n\n    return options;\n  }\n\n  withOptions(options) {\n    const mergeOptions = opt => Object.assign({}, options, typeof opt === \"string\" ? {\n      name: opt\n    } : opt);\n\n    return {\n      name: this.name,\n      tap: (opt, fn) => this.tap(mergeOptions(opt), fn),\n      tapAsync: (opt, fn) => this.tapAsync(mergeOptions(opt), fn),\n      tapPromise: (opt, fn) => this.tapPromise(mergeOptions(opt), fn),\n      intercept: interceptor => this.intercept(interceptor),\n      isUsed: () => this.isUsed(),\n      withOptions: opt => this.withOptions(mergeOptions(opt))\n    };\n  }\n\n  isUsed() {\n    return this.taps.length > 0 || this.interceptors.length > 0;\n  }\n\n  intercept(interceptor) {\n    this._resetCompilation();\n\n    this.interceptors.push(Object.assign({}, interceptor));\n\n    if (interceptor.register) {\n      for (let i = 0; i < this.taps.length; i++) {\n        this.taps[i] = interceptor.register(this.taps[i]);\n      }\n    }\n  }\n\n  _resetCompilation() {\n    this.call = this._call;\n    this.callAsync = this._callAsync;\n    this.promise = this._promise;\n  }\n\n  _insert(item) {\n    this._resetCompilation();\n\n    let before;\n\n    if (typeof item.before === \"string\") {\n      before = new Set([item.before]);\n    } else if (Array.isArray(item.before)) {\n      before = new Set(item.before);\n    }\n\n    let stage = 0;\n\n    if (typeof item.stage === \"number\") {\n      stage = item.stage;\n    }\n\n    let i = this.taps.length;\n\n    while (i > 0) {\n      i--;\n      const x = this.taps[i];\n      this.taps[i + 1] = x;\n      const xStage = x.stage || 0;\n\n      if (before) {\n        if (before.has(x.name)) {\n          before.delete(x.name);\n          continue;\n        }\n\n        if (before.size > 0) {\n          continue;\n        }\n      }\n\n      if (xStage > stage) {\n        continue;\n      }\n\n      i++;\n      break;\n    }\n\n    this.taps[i] = item;\n  }\n\n}\n\nObject.setPrototypeOf(Hook.prototype, null);\nmodule.exports = Hook;","map":{"version":3,"sources":["/Users/dennis.zhang/Desktop/其它代码库/moa-flow/node_modules/tapable/lib/Hook.js"],"names":["util","require","deprecateContext","deprecate","CALL_DELEGATE","call","_createCall","CALL_ASYNC_DELEGATE","callAsync","PROMISE_DELEGATE","promise","Hook","constructor","args","name","undefined","_args","taps","interceptors","_call","_callAsync","_promise","_x","compile","tap","tapAsync","tapPromise","options","Error","type","_tap","fn","trim","context","Object","assign","_runRegisterInterceptors","_insert","interceptor","register","newOptions","withOptions","mergeOptions","opt","intercept","isUsed","length","_resetCompilation","push","i","item","before","Set","Array","isArray","stage","x","xStage","has","delete","size","setPrototypeOf","prototype","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst util = require(\"util\");\n\nconst deprecateContext = util.deprecate(() => {},\n\"Hook.context is deprecated and will be removed\");\n\nconst CALL_DELEGATE = function(...args) {\n\tthis.call = this._createCall(\"sync\");\n\treturn this.call(...args);\n};\nconst CALL_ASYNC_DELEGATE = function(...args) {\n\tthis.callAsync = this._createCall(\"async\");\n\treturn this.callAsync(...args);\n};\nconst PROMISE_DELEGATE = function(...args) {\n\tthis.promise = this._createCall(\"promise\");\n\treturn this.promise(...args);\n};\n\nclass Hook {\n\tconstructor(args = [], name = undefined) {\n\t\tthis._args = args;\n\t\tthis.name = name;\n\t\tthis.taps = [];\n\t\tthis.interceptors = [];\n\t\tthis._call = CALL_DELEGATE;\n\t\tthis.call = CALL_DELEGATE;\n\t\tthis._callAsync = CALL_ASYNC_DELEGATE;\n\t\tthis.callAsync = CALL_ASYNC_DELEGATE;\n\t\tthis._promise = PROMISE_DELEGATE;\n\t\tthis.promise = PROMISE_DELEGATE;\n\t\tthis._x = undefined;\n\n\t\tthis.compile = this.compile;\n\t\tthis.tap = this.tap;\n\t\tthis.tapAsync = this.tapAsync;\n\t\tthis.tapPromise = this.tapPromise;\n\t}\n\n\tcompile(options) {\n\t\tthrow new Error(\"Abstract: should be overridden\");\n\t}\n\n\t_createCall(type) {\n\t\treturn this.compile({\n\t\t\ttaps: this.taps,\n\t\t\tinterceptors: this.interceptors,\n\t\t\targs: this._args,\n\t\t\ttype: type\n\t\t});\n\t}\n\n\t_tap(type, options, fn) {\n\t\tif (typeof options === \"string\") {\n\t\t\toptions = {\n\t\t\t\tname: options.trim()\n\t\t\t};\n\t\t} else if (typeof options !== \"object\" || options === null) {\n\t\t\tthrow new Error(\"Invalid tap options\");\n\t\t}\n\t\tif (typeof options.name !== \"string\" || options.name === \"\") {\n\t\t\tthrow new Error(\"Missing name for tap\");\n\t\t}\n\t\tif (typeof options.context !== \"undefined\") {\n\t\t\tdeprecateContext();\n\t\t}\n\t\toptions = Object.assign({ type, fn }, options);\n\t\toptions = this._runRegisterInterceptors(options);\n\t\tthis._insert(options);\n\t}\n\n\ttap(options, fn) {\n\t\tthis._tap(\"sync\", options, fn);\n\t}\n\n\ttapAsync(options, fn) {\n\t\tthis._tap(\"async\", options, fn);\n\t}\n\n\ttapPromise(options, fn) {\n\t\tthis._tap(\"promise\", options, fn);\n\t}\n\n\t_runRegisterInterceptors(options) {\n\t\tfor (const interceptor of this.interceptors) {\n\t\t\tif (interceptor.register) {\n\t\t\t\tconst newOptions = interceptor.register(options);\n\t\t\t\tif (newOptions !== undefined) {\n\t\t\t\t\toptions = newOptions;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn options;\n\t}\n\n\twithOptions(options) {\n\t\tconst mergeOptions = opt =>\n\t\t\tObject.assign({}, options, typeof opt === \"string\" ? { name: opt } : opt);\n\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\ttap: (opt, fn) => this.tap(mergeOptions(opt), fn),\n\t\t\ttapAsync: (opt, fn) => this.tapAsync(mergeOptions(opt), fn),\n\t\t\ttapPromise: (opt, fn) => this.tapPromise(mergeOptions(opt), fn),\n\t\t\tintercept: interceptor => this.intercept(interceptor),\n\t\t\tisUsed: () => this.isUsed(),\n\t\t\twithOptions: opt => this.withOptions(mergeOptions(opt))\n\t\t};\n\t}\n\n\tisUsed() {\n\t\treturn this.taps.length > 0 || this.interceptors.length > 0;\n\t}\n\n\tintercept(interceptor) {\n\t\tthis._resetCompilation();\n\t\tthis.interceptors.push(Object.assign({}, interceptor));\n\t\tif (interceptor.register) {\n\t\t\tfor (let i = 0; i < this.taps.length; i++) {\n\t\t\t\tthis.taps[i] = interceptor.register(this.taps[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\t_resetCompilation() {\n\t\tthis.call = this._call;\n\t\tthis.callAsync = this._callAsync;\n\t\tthis.promise = this._promise;\n\t}\n\n\t_insert(item) {\n\t\tthis._resetCompilation();\n\t\tlet before;\n\t\tif (typeof item.before === \"string\") {\n\t\t\tbefore = new Set([item.before]);\n\t\t} else if (Array.isArray(item.before)) {\n\t\t\tbefore = new Set(item.before);\n\t\t}\n\t\tlet stage = 0;\n\t\tif (typeof item.stage === \"number\") {\n\t\t\tstage = item.stage;\n\t\t}\n\t\tlet i = this.taps.length;\n\t\twhile (i > 0) {\n\t\t\ti--;\n\t\t\tconst x = this.taps[i];\n\t\t\tthis.taps[i + 1] = x;\n\t\t\tconst xStage = x.stage || 0;\n\t\t\tif (before) {\n\t\t\t\tif (before.has(x.name)) {\n\t\t\t\t\tbefore.delete(x.name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (before.size > 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (xStage > stage) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\tthis.taps[i] = item;\n\t}\n}\n\nObject.setPrototypeOf(Hook.prototype, null);\n\nmodule.exports = Hook;\n"]},"metadata":{},"sourceType":"script"}