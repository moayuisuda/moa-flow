{"ast":null,"code":"import { __decorate, __metadata } from \"tslib\";\nimport { inject, singleton } from 'mana-syringe';\nimport { vec3 } from 'gl-matrix';\nimport { CullingStrategyContribution } from './CullingPlugin';\nimport { AABB, Mask } from '../shapes';\nimport { DefaultCamera, Camera } from '../camera/Camera';\nimport { Shape } from '../types'; // group is not a 2d shape\n\nvar shape2D = [Shape.CIRCLE, Shape.ELLIPSE, Shape.IMAGE, Shape.RECT, Shape.LINE, Shape.POLYLINE, Shape.POLYGON, Shape.TEXT, Shape.PATH, Shape.HTML];\n\nvar FrustumCullingStrategy =\n/** @class */\nfunction () {\n  function FrustumCullingStrategy() {}\n\n  FrustumCullingStrategy.prototype.isVisible = function (object) {\n    // return true;\n    var _a, _b;\n\n    var cullable = object.cullable;\n\n    if (!cullable.enable) {\n      return true;\n    }\n\n    var renderBounds = object.getRenderBounds();\n\n    if (AABB.isEmpty(renderBounds)) {\n      return false;\n    } // get VP matrix from camera\n\n\n    var frustum = this.camera.getFrustum();\n    var parentVisibilityPlaneMask = (_b = (_a = object.parentNode) === null || _a === void 0 ? void 0 : _a.cullable) === null || _b === void 0 ? void 0 : _b.visibilityPlaneMask;\n    cullable.visibilityPlaneMask = this.computeVisibilityWithPlaneMask(object, renderBounds, parentVisibilityPlaneMask || Mask.INDETERMINATE, frustum.planes);\n    cullable.visible = cullable.visibilityPlaneMask !== Mask.OUTSIDE;\n    return cullable.visible;\n  };\n  /**\n   *\n   * @see「Optimized View Frustum Culling Algorithms for Bounding Boxes」\n   * @see https://github.com/antvis/GWebGPUEngine/issues/3\n   *\n   * * 基础相交测试 the basic intersection test\n   * * 标记 masking @see https://cesium.com/blog/2015/08/04/fast-hierarchical-culling/\n   * * TODO: 平面一致性测试 the plane-coherency test\n   * * TODO: 支持 mesh 指定自身的剔除策略，参考 Babylon.js @see https://doc.babylonjs.com/how_to/optimizing_your_scene#changing-mesh-culling-strategy\n   *\n   * @param aabb aabb\n   * @param parentPlaneMask mask of parent\n   * @param planes planes of frustum\n   */\n\n\n  FrustumCullingStrategy.prototype.computeVisibilityWithPlaneMask = function (object, aabb, parentPlaneMask, planes) {\n    if (parentPlaneMask === Mask.OUTSIDE || parentPlaneMask === Mask.INSIDE) {\n      // 父节点完全位于视锥内或者外部，直接返回\n      return parentPlaneMask;\n    } // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.\n    // (Because if there are fewer than 31 planes, the upper bits wont be changed.)\n\n\n    var mask = Mask.INSIDE;\n    var isShape2D = shape2D.indexOf(object.nodeName) > -1; // Use viewport culling for 2D shapes\n    // @see https://github.com/antvis/g/issues/914\n\n    for (var k = 0, len = planes.length; k < len; ++k) {\n      // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.\n      var flag = 1 << k;\n\n      if ((parentPlaneMask & flag) === 0) {\n        // 父节点处于当前面内部，可以跳过\n        continue;\n      } // skip near & far planes when testing 2D shapes\n\n\n      if (isShape2D && (k === 4 || k === 5)) {\n        continue;\n      } // p-vertex n-vertex <-|plane p-vertex n-vertex\n      // 使用 p-vertex 和 n-vertex 加速，避免进行平面和 aabb 全部顶点的相交检测\n\n\n      var _a = planes[k],\n          normal = _a.normal,\n          distance = _a.distance;\n\n      if (vec3.dot(normal, aabb.getPositiveFarPoint(planes[k])) + distance < 0) {\n        return Mask.OUTSIDE;\n      }\n\n      if (vec3.dot(normal, aabb.getNegativeFarPoint(planes[k])) + distance < 0) {\n        // 和当前面相交，对应位置为1，继续检测下一个面\n        mask |= flag;\n      }\n    }\n\n    return mask;\n  };\n\n  __decorate([inject(DefaultCamera), __metadata(\"design:type\", Camera)], FrustumCullingStrategy.prototype, \"camera\", void 0);\n\n  FrustumCullingStrategy = __decorate([singleton({\n    contrib: CullingStrategyContribution\n  })], FrustumCullingStrategy);\n  return FrustumCullingStrategy;\n}();\n\nexport { FrustumCullingStrategy };","map":{"version":3,"sources":["/Users/dennis.zhang/Desktop/其它代码库/moa-flow/node_modules/@antv/g/es/plugins/FrustumCullingStrategy.js"],"names":["__decorate","__metadata","inject","singleton","vec3","CullingStrategyContribution","AABB","Mask","DefaultCamera","Camera","Shape","shape2D","CIRCLE","ELLIPSE","IMAGE","RECT","LINE","POLYLINE","POLYGON","TEXT","PATH","HTML","FrustumCullingStrategy","prototype","isVisible","object","_a","_b","cullable","enable","renderBounds","getRenderBounds","isEmpty","frustum","camera","getFrustum","parentVisibilityPlaneMask","parentNode","visibilityPlaneMask","computeVisibilityWithPlaneMask","INDETERMINATE","planes","visible","OUTSIDE","aabb","parentPlaneMask","INSIDE","mask","isShape2D","indexOf","nodeName","k","len","length","flag","normal","distance","dot","getPositiveFarPoint","getNegativeFarPoint","contrib"],"mappings":"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","sourcesContent":["import { __decorate, __metadata } from \"tslib\";\nimport { inject, singleton } from 'mana-syringe';\nimport { vec3 } from 'gl-matrix';\nimport { CullingStrategyContribution } from './CullingPlugin';\nimport { AABB, Mask } from '../shapes';\nimport { DefaultCamera, Camera } from '../camera/Camera';\nimport { Shape } from '../types'; // group is not a 2d shape\n\nvar shape2D = [Shape.CIRCLE, Shape.ELLIPSE, Shape.IMAGE, Shape.RECT, Shape.LINE, Shape.POLYLINE, Shape.POLYGON, Shape.TEXT, Shape.PATH, Shape.HTML];\n\nvar FrustumCullingStrategy =\n/** @class */\nfunction () {\n  function FrustumCullingStrategy() {}\n\n  FrustumCullingStrategy.prototype.isVisible = function (object) {\n    // return true;\n    var _a, _b;\n\n    var cullable = object.cullable;\n\n    if (!cullable.enable) {\n      return true;\n    }\n\n    var renderBounds = object.getRenderBounds();\n\n    if (AABB.isEmpty(renderBounds)) {\n      return false;\n    } // get VP matrix from camera\n\n\n    var frustum = this.camera.getFrustum();\n    var parentVisibilityPlaneMask = (_b = (_a = object.parentNode) === null || _a === void 0 ? void 0 : _a.cullable) === null || _b === void 0 ? void 0 : _b.visibilityPlaneMask;\n    cullable.visibilityPlaneMask = this.computeVisibilityWithPlaneMask(object, renderBounds, parentVisibilityPlaneMask || Mask.INDETERMINATE, frustum.planes);\n    cullable.visible = cullable.visibilityPlaneMask !== Mask.OUTSIDE;\n    return cullable.visible;\n  };\n  /**\n   *\n   * @see「Optimized View Frustum Culling Algorithms for Bounding Boxes」\n   * @see https://github.com/antvis/GWebGPUEngine/issues/3\n   *\n   * * 基础相交测试 the basic intersection test\n   * * 标记 masking @see https://cesium.com/blog/2015/08/04/fast-hierarchical-culling/\n   * * TODO: 平面一致性测试 the plane-coherency test\n   * * TODO: 支持 mesh 指定自身的剔除策略，参考 Babylon.js @see https://doc.babylonjs.com/how_to/optimizing_your_scene#changing-mesh-culling-strategy\n   *\n   * @param aabb aabb\n   * @param parentPlaneMask mask of parent\n   * @param planes planes of frustum\n   */\n\n\n  FrustumCullingStrategy.prototype.computeVisibilityWithPlaneMask = function (object, aabb, parentPlaneMask, planes) {\n    if (parentPlaneMask === Mask.OUTSIDE || parentPlaneMask === Mask.INSIDE) {\n      // 父节点完全位于视锥内或者外部，直接返回\n      return parentPlaneMask;\n    } // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.\n    // (Because if there are fewer than 31 planes, the upper bits wont be changed.)\n\n\n    var mask = Mask.INSIDE;\n    var isShape2D = shape2D.indexOf(object.nodeName) > -1; // Use viewport culling for 2D shapes\n    // @see https://github.com/antvis/g/issues/914\n\n    for (var k = 0, len = planes.length; k < len; ++k) {\n      // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.\n      var flag = 1 << k;\n\n      if ((parentPlaneMask & flag) === 0) {\n        // 父节点处于当前面内部，可以跳过\n        continue;\n      } // skip near & far planes when testing 2D shapes\n\n\n      if (isShape2D && (k === 4 || k === 5)) {\n        continue;\n      } // p-vertex n-vertex <-|plane p-vertex n-vertex\n      // 使用 p-vertex 和 n-vertex 加速，避免进行平面和 aabb 全部顶点的相交检测\n\n\n      var _a = planes[k],\n          normal = _a.normal,\n          distance = _a.distance;\n\n      if (vec3.dot(normal, aabb.getPositiveFarPoint(planes[k])) + distance < 0) {\n        return Mask.OUTSIDE;\n      }\n\n      if (vec3.dot(normal, aabb.getNegativeFarPoint(planes[k])) + distance < 0) {\n        // 和当前面相交，对应位置为1，继续检测下一个面\n        mask |= flag;\n      }\n    }\n\n    return mask;\n  };\n\n  __decorate([inject(DefaultCamera), __metadata(\"design:type\", Camera)], FrustumCullingStrategy.prototype, \"camera\", void 0);\n\n  FrustumCullingStrategy = __decorate([singleton({\n    contrib: CullingStrategyContribution\n  })], FrustumCullingStrategy);\n  return FrustumCullingStrategy;\n}();\n\nexport { FrustumCullingStrategy };"]},"metadata":{},"sourceType":"module"}