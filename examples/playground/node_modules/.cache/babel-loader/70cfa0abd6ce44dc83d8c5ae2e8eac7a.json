{"ast":null,"code":"import { vec2 } from 'gl-matrix';\n\nfunction smoothBezier(points, smooth, isLoop, constraint) {\n  var cps = [];\n  var hasConstraint = !!constraint;\n  var prevPoint;\n  var nextPoint;\n  var min;\n  var max;\n  var nextCp0;\n  var cp1;\n  var cp0;\n\n  if (hasConstraint) {\n    min = constraint[0], max = constraint[1];\n\n    for (var i = 0, l = points.length; i < l; i += 1) {\n      var point = points[i];\n      min = vec2.min([0, 0], min, point);\n      max = vec2.max([0, 0], max, point);\n    }\n  }\n\n  for (var i = 0, len = points.length; i < len; i += 1) {\n    var point = points[i];\n\n    if (i === 0 && !isLoop) {\n      cp0 = point;\n    } else if (i === len - 1 && !isLoop) {\n      cp1 = point;\n      cps.push(cp0);\n      cps.push(cp1);\n    } else {\n      var prevIdx = [i ? i - 1 : len - 1, i - 1][isLoop ? 0 : 1];\n      prevPoint = points[prevIdx];\n      nextPoint = points[isLoop ? (i + 1) % len : i + 1];\n      var v = [0, 0];\n      v = vec2.sub(v, nextPoint, prevPoint);\n      v = vec2.scale(v, v, smooth);\n      var d0 = vec2.distance(point, prevPoint);\n      var d1 = vec2.distance(point, nextPoint);\n      var sum = d0 + d1;\n\n      if (sum !== 0) {\n        d0 /= sum;\n        d1 /= sum;\n      }\n\n      var v1 = vec2.scale([0, 0], v, -d0);\n      var v2 = vec2.scale([0, 0], v, d1);\n      cp1 = vec2.add([0, 0], point, v1);\n      nextCp0 = vec2.add([0, 0], point, v2); // 下一个控制点必须在这个点和下一个点之间\n\n      nextCp0 = vec2.min([0, 0], nextCp0, vec2.max([0, 0], nextPoint, point));\n      nextCp0 = vec2.max([0, 0], nextCp0, vec2.min([0, 0], nextPoint, point)); // 重新计算 cp1 的值\n\n      v1 = vec2.sub([0, 0], nextCp0, point);\n      v1 = vec2.scale([0, 0], v1, -d0 / d1);\n      cp1 = vec2.add([0, 0], point, v1); // 上一个控制点必须要在上一个点和这一个点之间\n\n      cp1 = vec2.min([0, 0], cp1, vec2.max([0, 0], prevPoint, point));\n      cp1 = vec2.max([0, 0], cp1, vec2.min([0, 0], prevPoint, point)); // 重新计算 nextCp0 的值\n\n      v2 = vec2.sub([0, 0], point, cp1);\n      v2 = vec2.scale([0, 0], v2, d1 / d0);\n      nextCp0 = vec2.add([0, 0], point, v2);\n\n      if (hasConstraint) {\n        cp1 = vec2.max([0, 0], cp1, min);\n        cp1 = vec2.min([0, 0], cp1, max);\n        nextCp0 = vec2.max([0, 0], nextCp0, min);\n        nextCp0 = vec2.min([0, 0], nextCp0, max);\n      }\n\n      cps.push(cp0);\n      cps.push(cp1);\n      cp0 = nextCp0;\n    }\n  }\n\n  if (isLoop) {\n    cps.push(cps.shift());\n  }\n\n  return cps;\n}\n/**\n * create bezier spline from catmull rom spline\n * @param {Array} crp Catmull Rom Points\n * @param {boolean} z Spline is loop\n * @param {Array} constraint Constraint\n */\n\n\nfunction catmullRom2Bezier(crp, z, constraint) {\n  if (z === void 0) {\n    z = false;\n  }\n\n  if (constraint === void 0) {\n    constraint = [[0, 0], [1, 1]];\n  }\n\n  var isLoop = !!z;\n  var pointList = [];\n\n  for (var i = 0, l = crp.length; i < l; i += 2) {\n    pointList.push([crp[i], crp[i + 1]]);\n  }\n\n  var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);\n  var len = pointList.length;\n  var d1 = [];\n  var cp1;\n  var cp2;\n  var p;\n\n  for (var i = 0; i < len - 1; i += 1) {\n    cp1 = controlPointList[i * 2];\n    cp2 = controlPointList[i * 2 + 1];\n    p = pointList[i + 1];\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n\n  if (isLoop) {\n    cp1 = controlPointList[len];\n    cp2 = controlPointList[len + 1];\n    p = pointList[0];\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n\n  return d1;\n}\n\nexport default catmullRom2Bezier;","map":{"version":3,"mappings":"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","names":["vec2","smoothBezier","points","smooth","isLoop","constraint","cps","hasConstraint","prevPoint","nextPoint","min","max","nextCp0","cp1","cp0","i","l","length","point","len","push","prevIdx","v","sub","scale","d0","distance","d1","sum","v1","v2","add","shift","catmullRom2Bezier","crp","z","pointList","controlPointList","cp2","p"],"sources":["/Users/dennis.zhang/Desktop/其它代码库/moa-flow/node_modules/@antv/path-util/src/catmull-rom-2-bezier.ts"],"sourcesContent":["import { vec2 } from 'gl-matrix';\nimport type { PathCommand } from './types';\n\ntype Pos = [number, number];\n\nfunction smoothBezier(points: Pos[], smooth: number, isLoop: boolean, constraint: Pos[]) {\n  const cps: vec2[] = [];\n  const hasConstraint = !!constraint;\n\n  let prevPoint: Pos;\n  let nextPoint: Pos;\n  let min: vec2;\n  let max: vec2;\n  let nextCp0: vec2;\n  let cp1: vec2;\n  let cp0: vec2;\n\n  if (hasConstraint) {\n    [min, max] = constraint;\n    for (let i = 0, l = points.length; i < l; i += 1) {\n      const point = points[i];\n      min = vec2.min([0, 0], min, point);\n      max = vec2.max([0, 0], max, point);\n    }\n  }\n\n  for (let i = 0, len = points.length; i < len; i += 1) {\n    const point = points[i];\n    if (i === 0 && !isLoop) {\n      cp0 = point;\n    } else if (i === len - 1 && !isLoop) {\n      cp1 = point;\n      cps.push(cp0);\n      cps.push(cp1);\n    } else {\n      const prevIdx = [i ? i - 1 : len - 1, i - 1][isLoop ? 0 : 1];\n      prevPoint = points[prevIdx];\n      nextPoint = points[isLoop ? (i + 1) % len : i + 1];\n\n      let v: vec2 = [0, 0];\n      v = vec2.sub(v, nextPoint, prevPoint);\n      v = vec2.scale(v, v, smooth);\n\n      let d0 = vec2.distance(point, prevPoint);\n      let d1 = vec2.distance(point, nextPoint);\n\n      const sum = d0 + d1;\n      if (sum !== 0) {\n        d0 /= sum;\n        d1 /= sum;\n      }\n\n      let v1 = vec2.scale([0, 0], v, -d0);\n      let v2 = vec2.scale([0, 0], v, d1);\n\n      cp1 = vec2.add([0, 0], point, v1);\n      nextCp0 = vec2.add([0, 0], point, v2);\n\n      // 下一个控制点必须在这个点和下一个点之间\n      nextCp0 = vec2.min([0, 0], nextCp0, vec2.max([0, 0], nextPoint, point));\n      nextCp0 = vec2.max([0, 0], nextCp0, vec2.min([0, 0], nextPoint, point));\n\n      // 重新计算 cp1 的值\n      v1 = vec2.sub([0, 0], nextCp0, point);\n      v1 = vec2.scale([0, 0], v1, -d0 / d1);\n      cp1 = vec2.add([0, 0], point, v1);\n\n      // 上一个控制点必须要在上一个点和这一个点之间\n      cp1 = vec2.min([0, 0], cp1, vec2.max([0, 0], prevPoint, point));\n      cp1 = vec2.max([0, 0], cp1, vec2.min([0, 0], prevPoint, point));\n\n      // 重新计算 nextCp0 的值\n      v2 = vec2.sub([0, 0], point, cp1);\n      v2 = vec2.scale([0, 0], v2, d1 / d0);\n      nextCp0 = vec2.add([0, 0], point, v2);\n\n      if (hasConstraint) {\n        cp1 = vec2.max([0, 0], cp1, min);\n        cp1 = vec2.min([0, 0], cp1, max);\n        nextCp0 = vec2.max([0, 0], nextCp0, min);\n        nextCp0 = vec2.min([0, 0], nextCp0, max);\n      }\n\n      cps.push(cp0);\n      cps.push(cp1);\n      cp0 = nextCp0;\n    }\n  }\n\n  if (isLoop) {\n    cps.push(cps.shift());\n  }\n\n  return cps;\n}\n\n/**\n * create bezier spline from catmull rom spline\n * @param {Array} crp Catmull Rom Points\n * @param {boolean} z Spline is loop\n * @param {Array} constraint Constraint\n */\nfunction catmullRom2Bezier(\n  crp: number[],\n  z: boolean = false,\n  constraint: Pos[] = [\n    [0, 0],\n    [1, 1],\n  ]\n): PathCommand[] {\n  const isLoop = !!z;\n  const pointList: Pos[] = [];\n  for (let i = 0, l = crp.length; i < l; i += 2) {\n    pointList.push([crp[i], crp[i + 1]]);\n  }\n\n  const controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);\n  const len = pointList.length;\n  const d1: PathCommand[] = [];\n\n  let cp1: vec2;\n  let cp2: vec2;\n  let p: Pos;\n\n  for (let i = 0; i < len - 1; i += 1) {\n    cp1 = controlPointList[i * 2];\n    cp2 = controlPointList[i * 2 + 1];\n    p = pointList[i + 1];\n\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n\n  if (isLoop) {\n    cp1 = controlPointList[len];\n    cp2 = controlPointList[len + 1];\n    [p] = pointList;\n\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n  return d1;\n}\n\nexport default catmullRom2Bezier;\n"]},"metadata":{},"sourceType":"module"}