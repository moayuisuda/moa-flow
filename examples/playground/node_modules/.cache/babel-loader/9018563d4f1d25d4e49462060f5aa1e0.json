{"ast":null,"code":"import { isArray } from 'lodash-es';\nvar SPACES = '\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029';\nvar PATH_COMMAND = new RegExp('([a-z])[' + SPACES + ',]*((-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?[' + SPACES + ']*,?[' + SPACES + ']*)+)', 'ig');\nvar PATH_VALUES = new RegExp('(-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?)[' + SPACES + ']*,?[' + SPACES + ']*', 'ig'); // Parses given path string into an array of arrays of path segments\n\nexport default function parsePathString(pathString) {\n  if (!pathString) {\n    return null;\n  }\n\n  if (isArray(pathString)) {\n    return pathString;\n  }\n\n  var paramCounts = {\n    a: 7,\n    c: 6,\n    o: 2,\n    h: 1,\n    l: 2,\n    m: 2,\n    r: 4,\n    q: 4,\n    s: 4,\n    t: 2,\n    v: 1,\n    u: 3,\n    z: 0\n  };\n  var data = [];\n  String(pathString).replace(PATH_COMMAND, function (a, b, c) {\n    var params = [];\n    var name = b.toLowerCase();\n    c.replace(PATH_VALUES, function (a, b) {\n      b && params.push(+b);\n    });\n\n    if (name === 'm' && params.length > 2) {\n      data.push([b].concat(params.splice(0, 2)));\n      name = 'l';\n      b = b === 'm' ? 'l' : 'L';\n    }\n\n    if (name === 'o' && params.length === 1) {\n      data.push([b, params[0]]);\n    }\n\n    if (name === 'r') {\n      data.push([b].concat(params));\n    } else {\n      while (params.length >= paramCounts[name]) {\n        data.push([b].concat(params.splice(0, paramCounts[name])));\n\n        if (!paramCounts[name]) {\n          break;\n        }\n      }\n    }\n\n    return '';\n  });\n  return data;\n}","map":{"version":3,"mappings":"AAAA,SAASA,OAAT,QAAwB,WAAxB;AAEA,IAAMC,MAAM,GACV,0IADF;AAEA,IAAMC,YAAY,GAAG,IAAIC,MAAJ,CACnB,aAAaF,MAAb,GAAsB,uCAAtB,GAAgEA,MAAhE,GAAyE,OAAzE,GAAmFA,MAAnF,GAA4F,OADzE,EAEnB,IAFmB,CAArB;AAIA,IAAMG,WAAW,GAAG,IAAID,MAAJ,CAAW,uCAAuCF,MAAvC,GAAgD,OAAhD,GAA0DA,MAA1D,GAAmE,IAA9E,EAAoF,IAApF,CAApB,C,CAEA;;AACA,eAAc,SAAUI,eAAV,CAA0BC,UAA1B,EAA4C;AACxD,MAAI,CAACA,UAAL,EAAiB;AACf,WAAO,IAAP;AACD;;AAED,MAAIN,OAAO,CAACM,UAAD,CAAX,EAAyB;AACvB,WAAOA,UAAP;AACD;;AACD,MAAMC,WAAW,GAAG;AAClBC,KAAC,EAAE,CADe;AAElBC,KAAC,EAAE,CAFe;AAGlBC,KAAC,EAAE,CAHe;AAIlBC,KAAC,EAAE,CAJe;AAKlBC,KAAC,EAAE,CALe;AAMlBC,KAAC,EAAE,CANe;AAOlBC,KAAC,EAAE,CAPe;AAQlBC,KAAC,EAAE,CARe;AASlBC,KAAC,EAAE,CATe;AAUlBC,KAAC,EAAE,CAVe;AAWlBC,KAAC,EAAE,CAXe;AAYlBC,KAAC,EAAE,CAZe;AAalBC,KAAC,EAAE;AAbe,GAApB;AAeA,MAAMC,IAAI,GAAG,EAAb;AAEAC,QAAM,CAAChB,UAAD,CAAN,CAAmBiB,OAAnB,CAA2BrB,YAA3B,EAAyC,UAAUM,CAAV,EAAagB,CAAb,EAAgBf,CAAhB,EAAiB;AACxD,QAAMgB,MAAM,GAAG,EAAf;AACA,QAAIC,IAAI,GAAGF,CAAC,CAACG,WAAF,EAAX;AACAlB,KAAC,CAACc,OAAF,CAAUnB,WAAV,EAAuB,UAAUI,CAAV,EAAagB,CAAb,EAAc;AACnCA,OAAC,IAAIC,MAAM,CAACG,IAAP,CAAY,CAACJ,CAAb,CAAL;AACD,KAFD;;AAGA,QAAIE,IAAI,KAAK,GAAT,IAAgBD,MAAM,CAACI,MAAP,GAAgB,CAApC,EAAuC;AACrCR,UAAI,CAACO,IAAL,CAAU,CAACJ,CAAD,EAAIM,MAAJ,CAAWL,MAAM,CAACM,MAAP,CAAc,CAAd,EAAiB,CAAjB,CAAX,CAAV;AACAL,UAAI,GAAG,GAAP;AACAF,OAAC,GAAGA,CAAC,KAAK,GAAN,GAAY,GAAZ,GAAkB,GAAtB;AACD;;AACD,QAAIE,IAAI,KAAK,GAAT,IAAgBD,MAAM,CAACI,MAAP,KAAkB,CAAtC,EAAyC;AACvCR,UAAI,CAACO,IAAL,CAAU,CAACJ,CAAD,EAAIC,MAAM,CAAC,CAAD,CAAV,CAAV;AACD;;AACD,QAAIC,IAAI,KAAK,GAAb,EAAkB;AAChBL,UAAI,CAACO,IAAL,CAAU,CAACJ,CAAD,EAAIM,MAAJ,CAAWL,MAAX,CAAV;AACD,KAFD,MAEO;AACL,aAAOA,MAAM,CAACI,MAAP,IAAiBtB,WAAW,CAACmB,IAAD,CAAnC,EAA2C;AACzCL,YAAI,CAACO,IAAL,CAAU,CAACJ,CAAD,EAAIM,MAAJ,CAAWL,MAAM,CAACM,MAAP,CAAc,CAAd,EAAiBxB,WAAW,CAACmB,IAAD,CAA5B,CAAX,CAAV;;AACA,YAAI,CAACnB,WAAW,CAACmB,IAAD,CAAhB,EAAwB;AACtB;AACD;AACF;AACF;;AACD,WAAO,EAAP;AACD,GAzBD;AA2BA,SAAOL,IAAP;AACD","names":["isArray","SPACES","PATH_COMMAND","RegExp","PATH_VALUES","parsePathString","pathString","paramCounts","a","c","o","h","l","m","r","q","s","t","v","u","z","data","String","replace","b","params","name","toLowerCase","push","length","concat","splice"],"sources":["/Users/dennis.zhang/Desktop/其它代码库/moa-flow/node_modules/@antv/path-util/src/parse-path-string.ts"],"sourcesContent":["import { isArray } from 'lodash-es';\n\nconst SPACES =\n  '\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029';\nconst PATH_COMMAND = new RegExp(\n  '([a-z])[' + SPACES + ',]*((-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?[' + SPACES + ']*,?[' + SPACES + ']*)+)',\n  'ig'\n);\nconst PATH_VALUES = new RegExp('(-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?)[' + SPACES + ']*,?[' + SPACES + ']*', 'ig');\n\n// Parses given path string into an array of arrays of path segments\nexport default function parsePathString(pathString: string) {\n  if (!pathString) {\n    return null;\n  }\n\n  if (isArray(pathString)) {\n    return pathString;\n  }\n  const paramCounts = {\n    a: 7,\n    c: 6,\n    o: 2,\n    h: 1,\n    l: 2,\n    m: 2,\n    r: 4,\n    q: 4,\n    s: 4,\n    t: 2,\n    v: 1,\n    u: 3,\n    z: 0,\n  };\n  const data = [];\n\n  String(pathString).replace(PATH_COMMAND, function (a, b, c) {\n    const params = [];\n    let name = b.toLowerCase();\n    c.replace(PATH_VALUES, function (a, b) {\n      b && params.push(+b);\n    });\n    if (name === 'm' && params.length > 2) {\n      data.push([b].concat(params.splice(0, 2)));\n      name = 'l';\n      b = b === 'm' ? 'l' : 'L';\n    }\n    if (name === 'o' && params.length === 1) {\n      data.push([b, params[0]]);\n    }\n    if (name === 'r') {\n      data.push([b].concat(params));\n    } else {\n      while (params.length >= paramCounts[name]) {\n        data.push([b].concat(params.splice(0, paramCounts[name])));\n        if (!paramCounts[name]) {\n          break;\n        }\n      }\n    }\n    return '';\n  });\n\n  return data;\n}\n"]},"metadata":{},"sourceType":"module"}