{"ast":null,"code":"import { __read, __spreadArray } from \"tslib\";\nimport { path2Absolute, path2Segments, path2Curve } from '@antv/path-util';\nimport { Cubic as CubicUtil } from '@antv/g-math';\nimport { clonePath, equalizeSegments, getDrawDirection, getRotatedCurve, reverseCurve } from '../../utils/path';\nimport { Rectangle } from '../../shapes/Rectangle';\nexport function parsePath(path) {\n  var absolutePath = path2Absolute(path);\n  var hasArc = hasArcOrBezier(absolutePath);\n  var clonedAbsolutePath = absolutePath.slice();\n\n  var _a = extractPolygons(clonedAbsolutePath),\n      polygons = _a.polygons,\n      polylines = _a.polylines; // convert to curves to do morphing & picking later\n  // @see http://thednp.github.io/kute.js/svgCubicMorph.html\n\n\n  var _b = __read(path2Curve(clonedAbsolutePath, true), 2),\n      curve = _b[0],\n      zCommandIndexes = _b[1];\n\n  var segments = path2Segments(clonedAbsolutePath);\n\n  var _c = calcLength(curve),\n      totalLength = _c.totalLength,\n      curveSegments = _c.curveSegments;\n\n  return {\n    absolutePath: absolutePath,\n    hasArc: hasArc,\n    segments: segments,\n    polygons: polygons,\n    polylines: polylines,\n    curve: curve,\n    totalLength: totalLength,\n    curveSegments: curveSegments,\n    zCommandIndexes: zCommandIndexes,\n    rect: getPathBBox(curve)\n  };\n}\n\nfunction hasArcOrBezier(path) {\n  var hasArc = false;\n  var count = path.length;\n\n  for (var i = 0; i < count; i++) {\n    var params = path[i];\n    var cmd = params[0];\n\n    if (cmd === 'C' || cmd === 'A' || cmd === 'Q') {\n      hasArc = true;\n      break;\n    }\n  }\n\n  return hasArc;\n}\n\nfunction extractPolygons(pathArray) {\n  var polygons = [];\n  var polylines = [];\n  var points = []; // 防止第一个命令不是 'M'\n\n  for (var i = 0; i < pathArray.length; i++) {\n    var params = pathArray[i];\n    var cmd = params[0];\n\n    if (cmd === 'M') {\n      // 遇到 'M' 判定是否是新数组，新数组中没有点\n      if (points.length) {\n        // 如果存在点，则说明没有遇到 'Z'，开始了一个新的多边形\n        polylines.push(points);\n        points = []; // 创建新的点\n      }\n\n      points.push([params[1], params[2]]);\n    } else if (cmd === 'Z') {\n      if (points.length) {\n        // 存在点\n        polygons.push(points);\n        points = []; // 开始新的点集合\n      } // 如果不存在点，同时 'Z'，则说明是错误，不处理\n\n    } else {\n      points.push([params[1], params[2]]);\n    }\n  } // 说明 points 未放入 polygons 或者 polyline\n  // 仅当只有一个 M，没有 Z 时会发生这种情况\n\n\n  if (points.length > 0) {\n    polylines.push(points);\n  }\n\n  return {\n    polygons: polygons,\n    polylines: polylines\n  };\n}\n\nfunction calcLength(curve) {\n  var totalLength = 0;\n  var tempLength = 0; // 每段 curve 对应起止点的长度比例列表，形如: [[0, 0.25], [0.25, 0.6]. [0.6, 0.9], [0.9, 1]]\n\n  var curveSegments = [];\n  var segmentT;\n  var segmentL;\n  var segmentN;\n  var l;\n\n  if (!curve) {\n    return {\n      curveSegments: [],\n      totalLength: totalLength\n    };\n  }\n\n  curve.forEach(function (segment, i) {\n    segmentN = curve[i + 1];\n    l = segment.length;\n\n    if (segmentN) {\n      totalLength += CubicUtil.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]) || 0;\n    }\n  });\n\n  if (totalLength === 0) {\n    return {\n      curveSegments: [],\n      totalLength: totalLength\n    };\n  }\n\n  curve.forEach(function (segment, i) {\n    segmentN = curve[i + 1];\n    l = segment.length;\n\n    if (segmentN) {\n      segmentT = [];\n      segmentT[0] = tempLength / totalLength;\n      segmentL = CubicUtil.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]); // 当 path 不连续时，segmentL 可能为空，为空时需要作为 0 处理\n\n      tempLength += segmentL || 0;\n      segmentT[1] = tempLength / totalLength;\n      curveSegments.push(segmentT);\n    }\n  });\n  return {\n    curveSegments: curveSegments,\n    totalLength: totalLength\n  };\n}\n\nfunction getPathBBox(segments) {\n  var x = 0;\n  var y = 0;\n  var X = [];\n  var Y = [];\n  segments.forEach(function (segment) {\n    var _a = __read(segment.slice(-2), 2),\n        s1 = _a[0],\n        s2 = _a[1];\n\n    if (segment[0] === 'M') {\n      x = s1;\n      y = s2;\n      X.push(s1);\n      Y.push(s2);\n    } else if (segment[0] === 'C') {\n      // @ts-ignore\n      var dim = CubicUtil.box.apply(CubicUtil, __spreadArray([], __read([x, y].concat(segment.slice(1))), false));\n      X = X.concat(dim.x, dim.x + dim.width);\n      Y = Y.concat(dim.y, dim.y + dim.height);\n      x = s1;\n      y = s2;\n    }\n  });\n  var xTop = Math.min.apply(0, X);\n  var yTop = Math.min.apply(0, Y);\n  var xBot = Math.max.apply(0, X);\n  var yBot = Math.max.apply(0, Y);\n  var width = xBot - xTop;\n  var height = yBot - yTop;\n  return new Rectangle(xTop, yTop, width, height);\n}\n\nexport function mergePaths(left, right, object) {\n  var curve1 = left.curve;\n  var curve2 = right.curve;\n  var curves = [curve1, curve2];\n\n  if (curve1.length !== curve2.length) {\n    curves = equalizeSegments(curve1, curve2);\n  }\n\n  var curve0 = getDrawDirection(curves[0]) !== getDrawDirection(curves[1]) ? reverseCurve(curves[0]) : clonePath(curves[0]);\n  return [curve0, getRotatedCurve(curves[1], curve0), function (pathArray) {\n    // need converting to path string?\n    return pathArray;\n  }];\n}","map":{"version":3,"sources":["/Users/dennis.zhang/Desktop/其它代码库/moa-flow/node_modules/@antv/g/es/css/parser/path.js"],"names":["__read","__spreadArray","path2Absolute","path2Segments","path2Curve","Cubic","CubicUtil","clonePath","equalizeSegments","getDrawDirection","getRotatedCurve","reverseCurve","Rectangle","parsePath","path","absolutePath","hasArc","hasArcOrBezier","clonedAbsolutePath","slice","_a","extractPolygons","polygons","polylines","_b","curve","zCommandIndexes","segments","_c","calcLength","totalLength","curveSegments","rect","getPathBBox","count","length","i","params","cmd","pathArray","points","push","tempLength","segmentT","segmentL","segmentN","l","forEach","segment","x","y","X","Y","s1","s2","dim","box","apply","concat","width","height","xTop","Math","min","yTop","xBot","max","yBot","mergePaths","left","right","object","curve1","curve2","curves","curve0"],"mappings":"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","sourcesContent":["import { __read, __spreadArray } from \"tslib\";\nimport { path2Absolute, path2Segments, path2Curve } from '@antv/path-util';\nimport { Cubic as CubicUtil } from '@antv/g-math';\nimport { clonePath, equalizeSegments, getDrawDirection, getRotatedCurve, reverseCurve } from '../../utils/path';\nimport { Rectangle } from '../../shapes/Rectangle';\nexport function parsePath(path) {\n  var absolutePath = path2Absolute(path);\n  var hasArc = hasArcOrBezier(absolutePath);\n  var clonedAbsolutePath = absolutePath.slice();\n\n  var _a = extractPolygons(clonedAbsolutePath),\n      polygons = _a.polygons,\n      polylines = _a.polylines; // convert to curves to do morphing & picking later\n  // @see http://thednp.github.io/kute.js/svgCubicMorph.html\n\n\n  var _b = __read(path2Curve(clonedAbsolutePath, true), 2),\n      curve = _b[0],\n      zCommandIndexes = _b[1];\n\n  var segments = path2Segments(clonedAbsolutePath);\n\n  var _c = calcLength(curve),\n      totalLength = _c.totalLength,\n      curveSegments = _c.curveSegments;\n\n  return {\n    absolutePath: absolutePath,\n    hasArc: hasArc,\n    segments: segments,\n    polygons: polygons,\n    polylines: polylines,\n    curve: curve,\n    totalLength: totalLength,\n    curveSegments: curveSegments,\n    zCommandIndexes: zCommandIndexes,\n    rect: getPathBBox(curve)\n  };\n}\n\nfunction hasArcOrBezier(path) {\n  var hasArc = false;\n  var count = path.length;\n\n  for (var i = 0; i < count; i++) {\n    var params = path[i];\n    var cmd = params[0];\n\n    if (cmd === 'C' || cmd === 'A' || cmd === 'Q') {\n      hasArc = true;\n      break;\n    }\n  }\n\n  return hasArc;\n}\n\nfunction extractPolygons(pathArray) {\n  var polygons = [];\n  var polylines = [];\n  var points = []; // 防止第一个命令不是 'M'\n\n  for (var i = 0; i < pathArray.length; i++) {\n    var params = pathArray[i];\n    var cmd = params[0];\n\n    if (cmd === 'M') {\n      // 遇到 'M' 判定是否是新数组，新数组中没有点\n      if (points.length) {\n        // 如果存在点，则说明没有遇到 'Z'，开始了一个新的多边形\n        polylines.push(points);\n        points = []; // 创建新的点\n      }\n\n      points.push([params[1], params[2]]);\n    } else if (cmd === 'Z') {\n      if (points.length) {\n        // 存在点\n        polygons.push(points);\n        points = []; // 开始新的点集合\n      } // 如果不存在点，同时 'Z'，则说明是错误，不处理\n\n    } else {\n      points.push([params[1], params[2]]);\n    }\n  } // 说明 points 未放入 polygons 或者 polyline\n  // 仅当只有一个 M，没有 Z 时会发生这种情况\n\n\n  if (points.length > 0) {\n    polylines.push(points);\n  }\n\n  return {\n    polygons: polygons,\n    polylines: polylines\n  };\n}\n\nfunction calcLength(curve) {\n  var totalLength = 0;\n  var tempLength = 0; // 每段 curve 对应起止点的长度比例列表，形如: [[0, 0.25], [0.25, 0.6]. [0.6, 0.9], [0.9, 1]]\n\n  var curveSegments = [];\n  var segmentT;\n  var segmentL;\n  var segmentN;\n  var l;\n\n  if (!curve) {\n    return {\n      curveSegments: [],\n      totalLength: totalLength\n    };\n  }\n\n  curve.forEach(function (segment, i) {\n    segmentN = curve[i + 1];\n    l = segment.length;\n\n    if (segmentN) {\n      totalLength += CubicUtil.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]) || 0;\n    }\n  });\n\n  if (totalLength === 0) {\n    return {\n      curveSegments: [],\n      totalLength: totalLength\n    };\n  }\n\n  curve.forEach(function (segment, i) {\n    segmentN = curve[i + 1];\n    l = segment.length;\n\n    if (segmentN) {\n      segmentT = [];\n      segmentT[0] = tempLength / totalLength;\n      segmentL = CubicUtil.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]); // 当 path 不连续时，segmentL 可能为空，为空时需要作为 0 处理\n\n      tempLength += segmentL || 0;\n      segmentT[1] = tempLength / totalLength;\n      curveSegments.push(segmentT);\n    }\n  });\n  return {\n    curveSegments: curveSegments,\n    totalLength: totalLength\n  };\n}\n\nfunction getPathBBox(segments) {\n  var x = 0;\n  var y = 0;\n  var X = [];\n  var Y = [];\n  segments.forEach(function (segment) {\n    var _a = __read(segment.slice(-2), 2),\n        s1 = _a[0],\n        s2 = _a[1];\n\n    if (segment[0] === 'M') {\n      x = s1;\n      y = s2;\n      X.push(s1);\n      Y.push(s2);\n    } else if (segment[0] === 'C') {\n      // @ts-ignore\n      var dim = CubicUtil.box.apply(CubicUtil, __spreadArray([], __read([x, y].concat(segment.slice(1))), false));\n      X = X.concat(dim.x, dim.x + dim.width);\n      Y = Y.concat(dim.y, dim.y + dim.height);\n      x = s1;\n      y = s2;\n    }\n  });\n  var xTop = Math.min.apply(0, X);\n  var yTop = Math.min.apply(0, Y);\n  var xBot = Math.max.apply(0, X);\n  var yBot = Math.max.apply(0, Y);\n  var width = xBot - xTop;\n  var height = yBot - yTop;\n  return new Rectangle(xTop, yTop, width, height);\n}\n\nexport function mergePaths(left, right, object) {\n  var curve1 = left.curve;\n  var curve2 = right.curve;\n  var curves = [curve1, curve2];\n\n  if (curve1.length !== curve2.length) {\n    curves = equalizeSegments(curve1, curve2);\n  }\n\n  var curve0 = getDrawDirection(curves[0]) !== getDrawDirection(curves[1]) ? reverseCurve(curves[0]) : clonePath(curves[0]);\n  return [curve0, getRotatedCurve(curves[1], curve0), function (pathArray) {\n    // need converting to path string?\n    return pathArray;\n  }];\n}"]},"metadata":{},"sourceType":"module"}