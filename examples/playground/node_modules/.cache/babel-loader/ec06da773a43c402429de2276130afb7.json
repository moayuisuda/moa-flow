{"ast":null,"code":"import line from './line';\nimport { distance } from './util';\n\nfunction analyzePoints(points) {\n  // 计算每段的长度和总的长度\n  var totalLength = 0;\n  var segments = [];\n\n  for (var i = 0; i < points.length - 1; i++) {\n    var from = points[i];\n    var to = points[i + 1];\n    var length_1 = distance(from[0], from[1], to[0], to[1]);\n    var seg = {\n      from: from,\n      to: to,\n      length: length_1\n    };\n    segments.push(seg);\n    totalLength += length_1;\n  }\n\n  return {\n    segments: segments,\n    totalLength: totalLength\n  };\n}\n\nexport function lengthOfSegment(points) {\n  if (points.length < 2) {\n    return 0;\n  }\n\n  var totalLength = 0;\n\n  for (var i = 0; i < points.length - 1; i++) {\n    var from = points[i];\n    var to = points[i + 1];\n    totalLength += distance(from[0], from[1], to[0], to[1]);\n  }\n\n  return totalLength;\n}\n/**\n * 按照比例在数据片段中获取点\n * @param {array} points 点的集合\n * @param {number} t 百分比 0-1\n * @return {object} 点的坐标\n */\n\nexport function pointAtSegments(points, t) {\n  // 边界判断\n  if (t > 1 || t < 0 || points.length < 2) {\n    return null;\n  }\n\n  var _a = analyzePoints(points),\n      segments = _a.segments,\n      totalLength = _a.totalLength; // 多个点有可能重合\n\n\n  if (totalLength === 0) {\n    return {\n      x: points[0][0],\n      y: points[0][1]\n    };\n  } // 计算比例\n\n\n  var startRatio = 0;\n  var point = null;\n\n  for (var i = 0; i < segments.length; i++) {\n    var seg = segments[i];\n    var from = seg.from,\n        to = seg.to;\n    var currentRatio = seg.length / totalLength;\n\n    if (t >= startRatio && t <= startRatio + currentRatio) {\n      var localRatio = (t - startRatio) / currentRatio;\n      point = line.pointAt(from[0], from[1], to[0], to[1], localRatio);\n      break;\n    }\n\n    startRatio += currentRatio;\n  }\n\n  return point;\n}\n/**\n * 按照比例在数据片段中获取切线的角度\n * @param {array} points 点的集合\n * @param {number} t 百分比 0-1\n */\n\nexport function angleAtSegments(points, t) {\n  // 边界判断\n  if (t > 1 || t < 0 || points.length < 2) {\n    return 0;\n  }\n\n  var _a = analyzePoints(points),\n      segments = _a.segments,\n      totalLength = _a.totalLength; // 计算比例\n\n\n  var startRatio = 0;\n  var angle = 0;\n\n  for (var i = 0; i < segments.length; i++) {\n    var seg = segments[i];\n    var from = seg.from,\n        to = seg.to;\n    var currentRatio = seg.length / totalLength;\n\n    if (t >= startRatio && t <= startRatio + currentRatio) {\n      angle = Math.atan2(to[1] - from[1], to[0] - from[0]);\n      break;\n    }\n\n    startRatio += currentRatio;\n  }\n\n  return angle;\n}\nexport function distanceAtSegment(points, x, y) {\n  var minDistance = Infinity;\n\n  for (var i = 0; i < points.length - 1; i++) {\n    var point = points[i];\n    var nextPoint = points[i + 1];\n    var distance_1 = line.pointDistance(point[0], point[1], nextPoint[0], nextPoint[1], x, y);\n\n    if (distance_1 < minDistance) {\n      minDistance = distance_1;\n    }\n  }\n\n  return minDistance;\n}","map":{"version":3,"sources":["/Users/dennis.zhang/Desktop/其它代码库/moa-flow/node_modules/@antv/g-math/es/segments.js"],"names":["line","distance","analyzePoints","points","totalLength","segments","i","length","from","to","length_1","seg","push","lengthOfSegment","pointAtSegments","t","_a","x","y","startRatio","point","currentRatio","localRatio","pointAt","angleAtSegments","angle","Math","atan2","distanceAtSegment","minDistance","Infinity","nextPoint","distance_1","pointDistance"],"mappings":"AAAA,OAAOA,IAAP,MAAiB,QAAjB;AACA,SAASC,QAAT,QAAyB,QAAzB;;AAEA,SAASC,aAAT,CAAuBC,MAAvB,EAA+B;AAC7B;AACA,MAAIC,WAAW,GAAG,CAAlB;AACA,MAAIC,QAAQ,GAAG,EAAf;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,MAAM,CAACI,MAAP,GAAgB,CAApC,EAAuCD,CAAC,EAAxC,EAA4C;AAC1C,QAAIE,IAAI,GAAGL,MAAM,CAACG,CAAD,CAAjB;AACA,QAAIG,EAAE,GAAGN,MAAM,CAACG,CAAC,GAAG,CAAL,CAAf;AACA,QAAII,QAAQ,GAAGT,QAAQ,CAACO,IAAI,CAAC,CAAD,CAAL,EAAUA,IAAI,CAAC,CAAD,CAAd,EAAmBC,EAAE,CAAC,CAAD,CAArB,EAA0BA,EAAE,CAAC,CAAD,CAA5B,CAAvB;AACA,QAAIE,GAAG,GAAG;AACRH,MAAAA,IAAI,EAAEA,IADE;AAERC,MAAAA,EAAE,EAAEA,EAFI;AAGRF,MAAAA,MAAM,EAAEG;AAHA,KAAV;AAKAL,IAAAA,QAAQ,CAACO,IAAT,CAAcD,GAAd;AACAP,IAAAA,WAAW,IAAIM,QAAf;AACD;;AAED,SAAO;AACLL,IAAAA,QAAQ,EAAEA,QADL;AAELD,IAAAA,WAAW,EAAEA;AAFR,GAAP;AAID;;AAED,OAAO,SAASS,eAAT,CAAyBV,MAAzB,EAAiC;AACtC,MAAIA,MAAM,CAACI,MAAP,GAAgB,CAApB,EAAuB;AACrB,WAAO,CAAP;AACD;;AAED,MAAIH,WAAW,GAAG,CAAlB;;AAEA,OAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,MAAM,CAACI,MAAP,GAAgB,CAApC,EAAuCD,CAAC,EAAxC,EAA4C;AAC1C,QAAIE,IAAI,GAAGL,MAAM,CAACG,CAAD,CAAjB;AACA,QAAIG,EAAE,GAAGN,MAAM,CAACG,CAAC,GAAG,CAAL,CAAf;AACAF,IAAAA,WAAW,IAAIH,QAAQ,CAACO,IAAI,CAAC,CAAD,CAAL,EAAUA,IAAI,CAAC,CAAD,CAAd,EAAmBC,EAAE,CAAC,CAAD,CAArB,EAA0BA,EAAE,CAAC,CAAD,CAA5B,CAAvB;AACD;;AAED,SAAOL,WAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASU,eAAT,CAAyBX,MAAzB,EAAiCY,CAAjC,EAAoC;AACzC;AACA,MAAIA,CAAC,GAAG,CAAJ,IAASA,CAAC,GAAG,CAAb,IAAkBZ,MAAM,CAACI,MAAP,GAAgB,CAAtC,EAAyC;AACvC,WAAO,IAAP;AACD;;AAED,MAAIS,EAAE,GAAGd,aAAa,CAACC,MAAD,CAAtB;AAAA,MACIE,QAAQ,GAAGW,EAAE,CAACX,QADlB;AAAA,MAEID,WAAW,GAAGY,EAAE,CAACZ,WAFrB,CANyC,CAQP;;;AAGlC,MAAIA,WAAW,KAAK,CAApB,EAAuB;AACrB,WAAO;AACLa,MAAAA,CAAC,EAAEd,MAAM,CAAC,CAAD,CAAN,CAAU,CAAV,CADE;AAELe,MAAAA,CAAC,EAAEf,MAAM,CAAC,CAAD,CAAN,CAAU,CAAV;AAFE,KAAP;AAID,GAhBwC,CAgBvC;;;AAGF,MAAIgB,UAAU,GAAG,CAAjB;AACA,MAAIC,KAAK,GAAG,IAAZ;;AAEA,OAAK,IAAId,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,QAAQ,CAACE,MAA7B,EAAqCD,CAAC,EAAtC,EAA0C;AACxC,QAAIK,GAAG,GAAGN,QAAQ,CAACC,CAAD,CAAlB;AACA,QAAIE,IAAI,GAAGG,GAAG,CAACH,IAAf;AAAA,QACIC,EAAE,GAAGE,GAAG,CAACF,EADb;AAEA,QAAIY,YAAY,GAAGV,GAAG,CAACJ,MAAJ,GAAaH,WAAhC;;AAEA,QAAIW,CAAC,IAAII,UAAL,IAAmBJ,CAAC,IAAII,UAAU,GAAGE,YAAzC,EAAuD;AACrD,UAAIC,UAAU,GAAG,CAACP,CAAC,GAAGI,UAAL,IAAmBE,YAApC;AACAD,MAAAA,KAAK,GAAGpB,IAAI,CAACuB,OAAL,CAAaf,IAAI,CAAC,CAAD,CAAjB,EAAsBA,IAAI,CAAC,CAAD,CAA1B,EAA+BC,EAAE,CAAC,CAAD,CAAjC,EAAsCA,EAAE,CAAC,CAAD,CAAxC,EAA6Ca,UAA7C,CAAR;AACA;AACD;;AAEDH,IAAAA,UAAU,IAAIE,YAAd;AACD;;AAED,SAAOD,KAAP;AACD;AACD;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASI,eAAT,CAAyBrB,MAAzB,EAAiCY,CAAjC,EAAoC;AACzC;AACA,MAAIA,CAAC,GAAG,CAAJ,IAASA,CAAC,GAAG,CAAb,IAAkBZ,MAAM,CAACI,MAAP,GAAgB,CAAtC,EAAyC;AACvC,WAAO,CAAP;AACD;;AAED,MAAIS,EAAE,GAAGd,aAAa,CAACC,MAAD,CAAtB;AAAA,MACIE,QAAQ,GAAGW,EAAE,CAACX,QADlB;AAAA,MAEID,WAAW,GAAGY,EAAE,CAACZ,WAFrB,CANyC,CAQP;;;AAGlC,MAAIe,UAAU,GAAG,CAAjB;AACA,MAAIM,KAAK,GAAG,CAAZ;;AAEA,OAAK,IAAInB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,QAAQ,CAACE,MAA7B,EAAqCD,CAAC,EAAtC,EAA0C;AACxC,QAAIK,GAAG,GAAGN,QAAQ,CAACC,CAAD,CAAlB;AACA,QAAIE,IAAI,GAAGG,GAAG,CAACH,IAAf;AAAA,QACIC,EAAE,GAAGE,GAAG,CAACF,EADb;AAEA,QAAIY,YAAY,GAAGV,GAAG,CAACJ,MAAJ,GAAaH,WAAhC;;AAEA,QAAIW,CAAC,IAAII,UAAL,IAAmBJ,CAAC,IAAII,UAAU,GAAGE,YAAzC,EAAuD;AACrDI,MAAAA,KAAK,GAAGC,IAAI,CAACC,KAAL,CAAWlB,EAAE,CAAC,CAAD,CAAF,GAAQD,IAAI,CAAC,CAAD,CAAvB,EAA4BC,EAAE,CAAC,CAAD,CAAF,GAAQD,IAAI,CAAC,CAAD,CAAxC,CAAR;AACA;AACD;;AAEDW,IAAAA,UAAU,IAAIE,YAAd;AACD;;AAED,SAAOI,KAAP;AACD;AACD,OAAO,SAASG,iBAAT,CAA2BzB,MAA3B,EAAmCc,CAAnC,EAAsCC,CAAtC,EAAyC;AAC9C,MAAIW,WAAW,GAAGC,QAAlB;;AAEA,OAAK,IAAIxB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,MAAM,CAACI,MAAP,GAAgB,CAApC,EAAuCD,CAAC,EAAxC,EAA4C;AAC1C,QAAIc,KAAK,GAAGjB,MAAM,CAACG,CAAD,CAAlB;AACA,QAAIyB,SAAS,GAAG5B,MAAM,CAACG,CAAC,GAAG,CAAL,CAAtB;AACA,QAAI0B,UAAU,GAAGhC,IAAI,CAACiC,aAAL,CAAmBb,KAAK,CAAC,CAAD,CAAxB,EAA6BA,KAAK,CAAC,CAAD,CAAlC,EAAuCW,SAAS,CAAC,CAAD,CAAhD,EAAqDA,SAAS,CAAC,CAAD,CAA9D,EAAmEd,CAAnE,EAAsEC,CAAtE,CAAjB;;AAEA,QAAIc,UAAU,GAAGH,WAAjB,EAA8B;AAC5BA,MAAAA,WAAW,GAAGG,UAAd;AACD;AACF;;AAED,SAAOH,WAAP;AACD","sourcesContent":["import line from './line';\nimport { distance } from './util';\n\nfunction analyzePoints(points) {\n  // 计算每段的长度和总的长度\n  var totalLength = 0;\n  var segments = [];\n\n  for (var i = 0; i < points.length - 1; i++) {\n    var from = points[i];\n    var to = points[i + 1];\n    var length_1 = distance(from[0], from[1], to[0], to[1]);\n    var seg = {\n      from: from,\n      to: to,\n      length: length_1\n    };\n    segments.push(seg);\n    totalLength += length_1;\n  }\n\n  return {\n    segments: segments,\n    totalLength: totalLength\n  };\n}\n\nexport function lengthOfSegment(points) {\n  if (points.length < 2) {\n    return 0;\n  }\n\n  var totalLength = 0;\n\n  for (var i = 0; i < points.length - 1; i++) {\n    var from = points[i];\n    var to = points[i + 1];\n    totalLength += distance(from[0], from[1], to[0], to[1]);\n  }\n\n  return totalLength;\n}\n/**\n * 按照比例在数据片段中获取点\n * @param {array} points 点的集合\n * @param {number} t 百分比 0-1\n * @return {object} 点的坐标\n */\n\nexport function pointAtSegments(points, t) {\n  // 边界判断\n  if (t > 1 || t < 0 || points.length < 2) {\n    return null;\n  }\n\n  var _a = analyzePoints(points),\n      segments = _a.segments,\n      totalLength = _a.totalLength; // 多个点有可能重合\n\n\n  if (totalLength === 0) {\n    return {\n      x: points[0][0],\n      y: points[0][1]\n    };\n  } // 计算比例\n\n\n  var startRatio = 0;\n  var point = null;\n\n  for (var i = 0; i < segments.length; i++) {\n    var seg = segments[i];\n    var from = seg.from,\n        to = seg.to;\n    var currentRatio = seg.length / totalLength;\n\n    if (t >= startRatio && t <= startRatio + currentRatio) {\n      var localRatio = (t - startRatio) / currentRatio;\n      point = line.pointAt(from[0], from[1], to[0], to[1], localRatio);\n      break;\n    }\n\n    startRatio += currentRatio;\n  }\n\n  return point;\n}\n/**\n * 按照比例在数据片段中获取切线的角度\n * @param {array} points 点的集合\n * @param {number} t 百分比 0-1\n */\n\nexport function angleAtSegments(points, t) {\n  // 边界判断\n  if (t > 1 || t < 0 || points.length < 2) {\n    return 0;\n  }\n\n  var _a = analyzePoints(points),\n      segments = _a.segments,\n      totalLength = _a.totalLength; // 计算比例\n\n\n  var startRatio = 0;\n  var angle = 0;\n\n  for (var i = 0; i < segments.length; i++) {\n    var seg = segments[i];\n    var from = seg.from,\n        to = seg.to;\n    var currentRatio = seg.length / totalLength;\n\n    if (t >= startRatio && t <= startRatio + currentRatio) {\n      angle = Math.atan2(to[1] - from[1], to[0] - from[0]);\n      break;\n    }\n\n    startRatio += currentRatio;\n  }\n\n  return angle;\n}\nexport function distanceAtSegment(points, x, y) {\n  var minDistance = Infinity;\n\n  for (var i = 0; i < points.length - 1; i++) {\n    var point = points[i];\n    var nextPoint = points[i + 1];\n    var distance_1 = line.pointDistance(point[0], point[1], nextPoint[0], nextPoint[1], x, y);\n\n    if (distance_1 < minDistance) {\n      minDistance = distance_1;\n    }\n  }\n\n  return minDistance;\n}"]},"metadata":{},"sourceType":"module"}